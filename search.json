[{"title":"Obsidian 的插件使用","url":"/posts/d62035eb/","content":"\n\n前言整理了一些常用的 Obsidian 插件。\n\n\n更新\n\n\n24-06-20 初始记录\n\n工具\nFile Tree 定位\n\n更好的文件管理方式。\n介绍：内链：[[Obsidian + Git + Hexo + 图床 = Blog + 个人笔记体系#File Tree 定位]]\n外链：File Tree 定位\n\n\n\n插件名称：File Tree Alternative\n\n\n分享地址：obsidian://show-plugin?id=table-editor-obsidian\n\n\nAdvanced Tables\n\n更快的表格创建方式。\n\n\n\n插件名称：Advanced Tables\n\n\n分享链接：obsidian://show-plugin?id=table-editor-obsidian\n\n\nAnnotator\n\nPDF 阅读器。\n\n\n\n插件名称：Annotator\n\n\n分享链接：obsidian://show-plugin?id=obsidian-annotator\n\n\nEmoji Toolbar\n\n在文章中插入 emoji。\n\n\n\n插件名称：Emoji Toolbar\n\n\n分享链接：obsidian://show-plugin?id=obsidian-emoji-toolbar\n\n\nePub Reader\n\nePub 格式文件阅读器。\n\n\n\n插件名称：ePub Reader\n\n\n分享链接：obsidian://show-plugin?id=obsidian-epub-plugin\n\n\nExcalidraw\n\nExcalidraw 绘图工具\n\n\n\n插件名称：Excalidraw\n\n\n分享链接：obsidian://show-plugin?id=obsidian-excalidraw-plugin\n\n\nLatex Suite\n\n数学公式支持\n\n\n\n插件名称：Latex Suite\n\n\n分享链接：obsidian://show-plugin?id=obsidian-latex-suite\n\n\nPandoc\n\n将 Markdown 格式文件导出成其他格式文件。\n\n\n\n插件名称：Pandoc\n\n\n分享链接：obsidian://show-plugin?id=obsidian-pandoc\n\n\nPrivacy Glasses\n\n模糊处理文件，如果在公共场合处理文件可以用到这个。\n\n\n\n插件名称：Privacy Glasses\n\n\n分享链接：obsidian://show-plugin?id=privacy-glasses\n\n\n美化\nLinter\n\nMarkdown 文件格式化工具。（包括中日韩语与英文之间的空格，非常好用）\n\n\n\n插件名称：Linter\n\n\n分享链接：obsidian://show-plugin?id=obsidian-linter\n\n\nBlue Topaz + Style Settings\n\n目前在使用的主题，主题可以直接在 Obsidian 中搜索。可以配合 Style Settings 一起使用（非常好用）。\n\n\n\n插件名称：Style Settings\n\n\n分享地址：obsidian://show-plugin?id=obsidian-style-settings\n\n\n","categories":["博客"],"tags":["博客","Obsidian"]},{"title":"优化 Hexo 网站的永久链接格式","url":"/posts/ff783527/","content":"\n\n前言浏览之前引用的文章地址，突然发现，地址全部变成了 404。后来发现每次发布，地址链接都会改变。所以记录一下，怎么处理这个问题。\n\n\n参考文章\n\n\n\n优化 Hexo 网站的永久链接格式\nHexo的SEO优化-使用abbrlink设置永久链接为随机值\n\n\n更新\n\n24.05.22 初始记录24.06.12 替换插件为abbrlink\n\n打开 Hexo 配置文件可以看到原先的配置处为：\nurl: https://kiml.github.iopermalink: :year/:month/:hash.htmlpermalink_defaults:pretty_urls:  trailing_index: true # Set to false to remove trailing &#x27;index.html&#x27; from permalinks  trailing_html: true # Set to false to remove trailing &#x27;.html&#x27; from permalinks\n照理说这样配置也是没有问题的，由于 hash 值的计算与文章标题有关，可能是因为这样，重新发布后，有部分页面会直接变成 404 的状态。\n优化\n安装插件\n在 Hexo 根目录打开终端安装插件。之前使用 abbrlink2，但是 clean 之后所有的链接都重排失效了。替换新的插件，这个会在文章前生成 abbrlink 值，只要不删除链接就不会变化。\nnpm install hexo-abbrlink --save\n修改配置\n修改 Hexo 的配置文件的 permalink 字段。当永久链接参数为 permalink: posts/:abbrlink/ 时，生成的文章链接类似于 /post/cd6eb56d/,例如 https://xxx.com/post/cd6eb56d/。\nurl: https://kiml.github.iopermalink: posts/:abbrlink/\tpermalink_defaults:\n设置 abbrlink，在配置中添加\nabbrlink:  alg: crc32  #support crc16(default) and crc32  rep: hex    #support dec(default) and hex\nabbrlink 参数说明\n参数：alg 对应随机值算法参数，可选为 crc16 和 crc32 参数\nrep 对应生成链接的表示方法，hex：十六进制，dec: 十进制\n对于 crc16 算法生成的随机值，具有一个最大限度，为 65536。\n使用 abbrlink\n清除之前的链接缓存，并重新生成更新\nhexo clean &amp; hexo g\n","categories":["博客"]},{"title":"Git及常用命令","url":"/posts/41401b09/","content":"\n\n前言\nGit 部分知识以及常用命令\n\n\n更新\n\n\n23.07.11 初始记录24.09.05 更新Mac电脑相关操作\n\n安装\nWindows\n之前在写 [[Obsidian + Git + Hexo + 图床 = Blog + 个人笔记体系]] 这篇笔记的时候有提到过 Git 的安装。这里就直接把步骤贴过来，具体安装地址 (https://git-scm.com/)\n\n\n访问 git 官方地址，下载对应的安装包，进行安装（简单的点击下一步）。\n\n\n安装好之后，鼠标右键可以看到：Git Bash Here，点击后打开了。\n\n\n输入：git --version\n出现版本号说明安装成功。\n\n\nMac\nMac 安装非常简单。在终端运行 git --version 指令，如果本机没有安装，会弹出安装弹窗，直接安装就行。\nLinux\n\n\nlinux 安装使用以下命令\n\n\nsudo apt-get install git\ngit 配置 SSH key\nGit 是分布式的代码管理工具，远程的代码管理是基于 SSH 的，所以要使用远程的 Git 则需要 SSH 的配置。\n一、设置 Git 的 user name 和 email：\n$ git config --global user.name &quot;kiml&quot;  $ git config --global user.email &quot;1162278448@qq.com&quot;\n二、生成 SSH 密钥\n\n内链：[[Obsidian + Git + Hexo + 图床 = Blog + 个人笔记体系#git配置 SSH key]]\n外链：[Obsidian + Git + Hexo + 图床 = Blog + 个人笔记体系](https://kiml.site/posts/121fccfa/#git 配置 SSH key)\n\nMac 系统配置多个 ssh 源（邮箱不同）\n\n\n生成 ssh 密钥（这边可以先生成其中一个邮箱的地址）\n\n\nssh-keygen -t rsa -C &quot;邮件地址&quot; # 该邮箱地址是绑定github账号的地址\n\n\n在对应的平台保存公钥\n\n\n测试是否成功\n\n\nssh -T git@github.com\n出现  You've successfully authenticated, but GitHub does not provide shell access. 说明成功\n\n\n失败可以通过命令 -v 指令输出详细的日志信息（这里记录遇到过的一种情况：查看日志发现连接没有尝试新生成的私钥）\n\n\n# ssh强制添加密钥 这个会被重置ssh-add ~/.ssh/id_rsa\n\n\n多源的配置文件到 .ssh 目录下新建 config 文件（可以解决 4 的问题）\n\n\nHost github    User 按实填写    Hostname github.com    PreferredAuthentications publickey    IdentityFile ~/.ssh/id_rsa_116Host company-git    User 按实填写    Hostname xxx    PreferredAuthentications publickey    IdentityFile ~/.ssh/id_rsa\ngit 工具\nGitHub Desktop\n\n平时更多使用 IntelliJ IDEA 自带的 git 工具，偶然发现这个工具，近期打算使用官方文档：(https://docs.github.com/zh/desktop/installing-and-configuring-github-desktop/overview/getting-started-with-github-desktop)\n\n常用命令\nclone 到本地\ngit clone git@gitee.com:kiml_rgb/blog.git\n提交代码\n# 进入项目工程目录cd hello/# 将当前修改的文件添加到暂存区git add .# 提交代码git commit -m &quot;first commit&quot;\n推送代码\ngit push\n拉取代码\ngit pull\n创建并提交分支\n# 切换并从当前分支创建一个dev分支git checkout -b dev# 将新创建的dev分支推送到远程仓库git push origin dev\n其他常用命令\n# 切换到dev分支git checkout dev# 查看本地仓库文件状况git status# 查看本地所有分支git branch# 查看提交记录git log\n","categories":["环境搭建"],"tags":["Git"]},{"title":"IntelliJ 系列产品常用设置","url":"/posts/ce75656e/","content":"\n\n前言\nIntelliJ 系列产品 常用设置。这些设置不同软件间都可以导出共用，卸载安装也可以选择静默选项。\n\n\n更新\n\n\n23.07.02 初始记录23.07.09 基本设置（初始）23.07.16 基本设置完成 推荐插件（初始）23.08.28 三个插件的添加24.06.06 LeetCode插件24.09.09 编译大项目设置 三个插件的添加24.11.20 代码模板插件\n\nIntelliJ IDEA 常用设置\n基本设置\n基本风格及 UI 字体大小\n\n设置打开 IDEA 不直接打开项目\n\n这样默认打开 IDEA 时就是如下画面：\n\n点击 Customize 里的 All settings，就可以为所有新项目设置配置。\n设置项目文件编码格式（很重要）\n建议将所有都设置成 UTF-8 格式，Maven 下载不成功有时候和这个有关\n\n设置代码提示的匹配格式\n\n设置新建类文件的注释模板\n/** * @author $&#123;USER&#125; * @since: $&#123;DATE&#125; $&#123;TIME&#125;*/\n\n设置多个类同时打开并不重叠隐藏\n\n设置 maven 配置\n\n设置 SQL 自动补全\n\n\n启用 IDEA 的 database 插件\n\n\n针对项目进行 SQL Dialects 配置\n\n\n内存设置\n\n\n基本设置导出\n为了更方便的迁移 IDEA，可以将基本设置导出。（不同平台最好不要这么操作，容易出 bug）\n\nMaven 编译跳过测试\n-Dmaven.test.skip=true\n\n推荐插件\nLombok\n\n通过注解不再需要编写 getter、setter、equals 等方法，可以在编译时自动生成，开发时常用的插件。IDEA 在目前使用的版本中已经内置，SpringBoot 2.1.x 之后的版本也在 Starter 中内置了 Lombok 依赖。\n\n集成\n在项目的 pom.xml 文件中可以添加 Lombok 依赖，SpringBoot 2.1.x 版本后无需指定 Lombok 版本，SpringBoot 在 spring-boot-dependencies 中已经内置。\n&lt;!--lombok依赖--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;    &lt;artifactId&gt;lombok&lt;/artifactId&gt;    &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;\nMyBatisX\n\nMybatisX 是一款基于 IDEA 的快速开发插件，为效率而生。\n\nMaven Helper\n\n可以右键项目快速完成项目 maven 的各个阶段。\npom.xml 文件点击后，显示右边多了 Dependency Analyzer 的 Tab 选项，可以查看依赖冲突。同时也可以快速排除冲突的文件。\n\nGit Commit Template\n\n为 git 的提交提供模板。例子：fix(DAO): 用户查询缺少 username 属性 feat(Controller): 用户查询接口开发\n\n参数详解：\n\n\n\n参数\n类型\nshuoming\n\n\n\n\ntype(必须)\n\n用于说明 git commit 的类别，只允许使用下面的标识。\n\n\n\nfeat\n新功能（feature）\n\n\n\nfix/to\n修复 bug，可以是 QA 发现的 BUG，也可以是研发自己发现的 BUG。\n\n\n\nfix\n产生 diff 并自动修复此问题。适合于一次提交直接修复问题\n\n\n\nto\n只产生 diff 不自动修复此问题。适合于多次提交。最终修复问题提交时使用 fix。\n\n\n\ndocs\n文档（documentation）\n\n\n\nstyle\n格式（不影响代码运行的变动）。\n\n\n\nrefactor\n重构（即不是新增功能，也不是修改 bug 的代码变动）。\n\n\n\nperf\n优化相关，比如提升性能、体验。\n\n\n\ntest\n增加测试。\n\n\n\nchore\n构建过程或辅助工具的变动。\n\n\n\nrevert\n回滚到上一个版本。\n\n\n\nmerge\n代码合并。\n\n\n\nsync\n同步主线或分支的 Bug。\n\n\nscope(可选)\n\nscope 用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。\n\n\nsubject(必须)\n\nsubject 是 commit 目的的简短描述，不超过 50 个字符\n\n\n\nStatistic\n\n代码统计器\n\nLeetCode Editor\n\nLeetCode 刷题\n\n中文乱码问题：\n在 Help-&gt;Edit Custom VM Options 添加如下：\n-Dfile.encoding=utf-8\nTranslation\n\n翻译插件\n\nKey Promoter X\n\n快捷键提示\n\nEasyCode\n\n代码模板\n\n这里提供公司内使用的一个模板：(https://blog-resources.oss-cn-hangzhou.aliyuncs.com/Z2409-12/11/EasyCodeConfig.json)\nWebStorm 常用设置\n基本设置\n因为是同一家公司，一些基本的配置与 IntelliJ IDEA 是相同的，这里就不再赘述了。\n推荐插件\nESLint Restart Service Action\n\n使用 ESLint 自动格式化代码。\n\n\nGitToolBox\n\n显示更详细的 git 信息很多 Git 的功能增强，比如自动 fetch 代码，状态栏中显示当前 Git 分支的未提交和落后提交数显示，过时分支清理，commit 窗口支持 emoji 表情，Inline Blame 可以看到每行代码是谁提交的、什么时候提交的、以及 commit 信息等等，如果你经常用 Git，这个插件必装了。\n\nHighlightBracketPair\n\n高亮括号\n\nIntelliVue\n\nWebstorm 上对 Vue 支持很棒的插件，现在已经支持 Vue3 的一些语法，可以快速创建 Vue2 的 data、methods 等，或者 Vue3 的 setup method 等，帮你少些一些模板代码。\n\n.ignore\n\n.ignore 插件支持创建多种 .ignore 文件比如 .gitignore、.eslintignore、.dockerignore 等等，我们最常用的基本都支持，新建的时候支持选择不同类型的框架或库常用的忽略配置，如 node_modules、dist、.cache 等。\n\n","categories":["环境搭建"],"tags":["IDEA"]},{"title":"Windows 自带的 Linux 子系统","url":"/posts/ba3da13b/","content":"\n\n前言本来想在阿里云服务器上安装 jenkins，但是配置高的服务器价格太贵，配置低的非常容易 cpu 100%，不利于测试。所以打算直接用台式机做虚拟云主机。\n\n\n参考文章\nWin10 系统安装 Linux 子系统教程(WSL2 + Ubuntu 20.04 + Gnome 桌面 ）\n\n\n更新\n\n\n24-09-22 初始记录\n\n安装 WSL\n安装 WSL1\n\n\n管理员身份运行 PowerShell\n\n\n输入命令，启用适用于 Linux 的 Windows 子系统功能\n\n\ndism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart\n\n\n在 Microsoft Store 中选择中意的 Linux 分发版本，并安装\n\n\n为新的 Linux 分发版创建用户账户和密码\n\n\n升级到 WSL2\n\n\n开启“虚拟机平台”可选功能\n\n\ndism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart\n\n\n重启电脑\n\n\n下载 Linux 内核更新包适用于 x64 计算机的 WSL Linux 内核更新包\n\n\n设置 WSL 版本\n\n\nPS C:\\Users\\user-name&gt; wsl --set-version Ubuntu-20.04 2正在进行转换，这可能需要几分钟时间...有关与 WSL 2 的主要区别的信息，请访问 https://aka.ms/wsl2转换完成。\n使用 WSL\n启动和退出 Linux\n进入 Linux 子系统有以下几种方式：\n（1）和正常软件一样启动，如在开始菜单中点击其图标、双击桌面快捷方式\n（2）在 Windows 中打开一个终端，如 PowerShell，输入命令 wsl\n（3）在终端中输入命令 Linux 发行版名称.exe，如 ubuntu20.04.exe\n退出 Linux 子系统的方式：\n（1）直接关闭终端\n（2）在终端中输入命令 exit，此时退出了 WSL，然后输入命令 wsl -t Ubuntu-20.04，关闭 ubuntu 子系统。\n# 列出所有分发的名称、运行状态、对应的 WSL 版本wsl -l -v# 终止指定的 Linux 分发wsl -t &lt;distro&gt;# 注销分发wsl --unregister &lt;distro&gt;# 终止所有正在运行的分发和 WSL2 轻型工具虚拟机wsl --shutdown\n换源\n使用 Linux 子系统时，为了提高软件的安装速度，需要将软件源换成国内的镜像源。\n\n\n备份原来的数据源配置文件\n\n\nsudo cp /etc/apt/sources.list /etc/apt/sources.list_backup\n\n\n修改数据源配置文件\n\n\nsudo vi /etc/apt/sources.list\n# 默认注释了源码仓库，如有需要可自行取消注释deb https://mirrors.ustc.edu.cn/ubuntu/ focal main restricted universe multiverse# deb-src https://mirrors.ustc.edu.cn/ubuntu/ focal main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ focal-security main restricted universe multiverse# deb-src https://mirrors.ustc.edu.cn/ubuntu/ focal-security main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ focal-updates main restricted universe multiverse# deb-src https://mirrors.ustc.edu.cn/ubuntu/ focal-updates main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ focal-backports main restricted universe multiverse# deb-src https://mirrors.ustc.edu.cn/ubuntu/ focal-backports main restricted universe multiverse# 预发布软件源，不建议启用# deb https://mirrors.ustc.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse# deb-src https://mirrors.ustc.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse\n\n\n更新源，升级软件\n\n\nsudo apt-get updatesudo apt-get upgrade\n使用 SSH 登录 Linux 子系统\n开启 SSH 并允许 root 登录\n\n\n安装 SSH 服务器\n\n\nsudo apt updatesudo apt install openssh-server\n\n\n修改配置端口为 22，允许密码和 root 登录。\n\n\nsudo nano /etc/ssh/sshd_config\n找到下面的内容并去掉注释在前面的#号，其中把 PermitRootLogin prohibit-password 更改为 PermitRootLogin yes 这是允许用 root 登录的。\nPort 22PermitRootLogin prohibit-passwordPasswordAuthentication yes\n\n\n重启 SSH 服务\n\n\nservice ssh restart# 或者运行这个命令sudo service ssh --full-restart\n\n\n终端测试连接输入指令，格式为：ssh 用户名@域名/IP\n\n\nssh root@0.0.0.0ssh 127.0.0.1\n\n\n确保 SSH 服务器会在系统启动时自动启动\n\n\nsudo systemctl enable ssh\n\n\n配置永久解决方案将上述的命令保存为 service.sh，保存在 home 目录下\n\n\n# &gt;&gt;&gt; service ssh restart &gt;&gt;&gt;# for Xshell connectionsudo service ssh --full-restart# &lt;&lt;&lt; service ssh restart &lt;&lt;&lt;\n配置好之后，下次开机，只需要在 Linux 子系统的默认终端运行 sh service.sh 命令后，关掉终端改用 xshell 登录即可。\n\n\n查看 SSH 监听端口\n\n\nsudo ss -tuln | grep 22\n\n\nSSH 服务器状态\n\n\nsudo service ssh status\n设置默认使用 root 登录系统\n\n\n切换 root 权限\n\n\nsudo -i# 然后输入密码\n\n\n创建/打开 /etc/wsl.conf ，添加以下内容\n\n\n[user]default=root\n\n\n运行以下命令重新启动 WSL 以应用更改\n\n\nwsl --shutdown\n设置端口转发\n\n为了能够从外部连接到你的 WSL Linux 子系统，你需要确保系统具有公共 IP 地址，或者设置端口转发以将流量路由到 WSL 子系统的局域网 IP 地址。请检查你的网络配置，确保 WSL 子系统能够访问公共网络，并且有一个可供外部访问的 IP 地址。\n\n\n\n增加转发的命令：\n\n\nnetsh interface portproxy add v4tov4 listenaddress=0.0.0.0 listenport=22 connectaddress=[IP] connectport=[PORT]# 这里的IP为WSL中使用ipconfig查看的IP地址，PORT为WSL的PORT# 还需要在windows防火墙中添加对应的入站规则，设置完成后可以通过ip地址远程访问wsl\n\n\n删除转发的命令：\n\n\nnetsh interface portproxy delete v4tov4 listenport=22 listenaddress=0.0.0.0\n\n\n使用以下命令列出当前的端口转发规则：\n\n\nnetsh interface portproxy show all\n\n\n测试连接的命令：\n\n\nssh username@ip -p 22\n\n这里测试连接的 ip 可以在 linux 内使用命令 hostname -I 进行查看\n\n卸载 Linux 系统\nwsl --unregister Ubuntu\nSSH 安全\n","categories":["环境搭建"],"tags":["Linux"]},{"title":"装机-软件安装","url":"/posts/89b09b58/","content":"\n\n前言找到工作之后每天就是躺平，好久没有更新技术上的内容了，之前学的好多东西也忘了……甚至 md 语法都忘了好多（每天 CRUD，但是也很消耗精力。必须要不断学习，好痛苦，什么时候能退休😢）趁着 618 配了一台新电脑，顺便用半个多月的时间用新电脑打游戏。。。正好最近在装软件，整理一下装机要注意的事，以及一些必备软件，便于后面再次装机使用。\n\n\n更新\n\n\n23.06.24 初始记录23.07.02 IDEA常用插件 + 基本设置23.07.09 编程环境Java + MySQL23.07.11 Git23.08.28 Maven\n\n初始装机\n这部分都是照着 b 站上的视频完成的。总之时间就分两大块，把零件装上去，理线。具体可参照以下视频：B站 赵德柱装机\n系统安装\n系统安装需要准备一个 U 盘装系统。具体步骤可以参照以下视频：B站 赵德柱装系统\n安装系统完毕第一件事就是去对应官网安装对应驱动，这个依据配置不同，需要下载的东西也不一样。可以检查以下项目的驱动是否安装，每项都需要到对应的官网去下载对应的驱动包：\n\n\ncpu 驱动\n\n\n主板驱动（涉及较多）\n\n\n显卡驱动\n\n\n鼠标驱动（调光需要）\n\n\n键盘驱动（调光需要）\n\n\n软件安装\n常用软件\nOffice 全家桶\n这个直接登录原来的微软账户就可以安装了，之前买笔记本有配有家庭版可以直接使用。有的笔记本没有送，这个需要注意原来的不要卸载，不然重新下载比较麻烦（这是个付费软件）。直接去买个激活码就行\nSteam\n装机第一件事\nUU加速器\n用了这么多，最常用的还是这个，加速商店是足够用了，想要加速游戏可以进一步去贴吧下载\nChrome\n插件就不提供了，自己后续需要再搜，最好还是能整个账号，不然每次装机都要重新把收藏夹的导出来有点麻烦。\nSnipaste\n很好用的截屏软件，U 盘里带有安装包，直接解压缩，开启后就可以 F1 截图了\nScreenToGif\n制作 Gif 的软件，以前下载过但是没有用到的机会\nToDesk\n远程连接工具，不想背电脑回家就带这个\nObsidian\n目前在用的 All in One 笔记软件，好用但是太繁琐了，一开始大半时间都浪费在插件和布局上面，目前用着还行，希望后面能完全用起来。当个 md 编辑器还是不错的。\nTypora\n一款 Markdown 编辑器和阅读器。更便捷的浏览工具。\n网盘\n百度网盘\n之前参加活动，容量已经到 5T 了，但是不充会员完全没法使用，现在就是一个吉祥物的存在，有时候网上购买资源会发网盘链接，还是需要下载一个软件。\n阿里云盘\n需要备用一个\n编程专用\n开发环境\nJava\n目前用的还是 1.8 版本，在 U 盘内存了常用的几版 JDK。有安装包双击下载就行，下载之后需要配置一下环境变量\nMySQL\n目前使用的是 5.7.20 版本，官网下载就行。同样也需要配置环境变量。\nRedis\n安装与 SpringBoot 下的使用方法如下：\n\n内链：[[Spring Data Redis]]\n外链：Spring Data Redis\n\nMaven\n一个 Java 项目管理工具，window 需要官网下载可用的.zip 包，之后解压到一个没有中文没有空格的路径下，同时也需要配置相应的环境变量。（可能出现 IDEA 不适配需要降低 maven 版本，当前 IDEA 2020.3.2，可以安装 Maven 3.6.3）\n打开安装目录 conf/settings.xml 文件，进行以下两项配置。\n\n\n其他\n还有很多其他环境配置，包括开发用的其他中间件。听说 Windows 也能配置 Docker 了，这部分应该会单独写文章。\n开发工具\nIntelliJ IDEA\n这个不用多说，U 盘里存了一个可用的破解版，从大学用到现在了。安装后还需要进行一些常用的设置。具体可以参考以下\n\n内链：[[IntelliJ 系类产品常用设置]]\n外链：IntelliJ IDEA常用设置\n\nWebStorm\n前端的 IDEA，打算抛弃 Vs Code 用这个了。看了很多对比测评。用 JetBrains 的产品习惯了。\nPycharm\nPython 的 IDEA，也是 JetBrains 家的。\nTabby\n一款终端工具，之前用的一直是 FinalShell，后来想转成 XSHELL，才知道 XSHELL &amp; XFTP 的家庭版是免费的，后来是看博客，知道了一款 22 年的终端 Tabby（不过这么多具体哪个好用确实也是不太了解，换成这个的原因主要是他可以结合远程连接和远程传输两块的内容。也看到把数据库连接，服务器监控，终端都结合在一起的工具，但是数据库工具还是比较习惯用 navicat，所以暂时决定是先把终端工具换成 Tabby）具体使用步骤参考（后面有时间再整理到自己的笔记里面吧）：(https://www.macrozheng.com/tool/tabby_start.html)\nNavicat\n一款好用的数据库管理工具，提供 14 天免费试用。但是这种一般都是有破解的，网盘里存了一个（会被杀毒软件杀掉）\nGit\n版本控制工具。（目前使用的博客工具 Hexo 也是依靠 Git 部署）\n具体使用介绍如下\n\n内链：[[Git 及常用命令]]\n外链：Git及常用命令\n\n其他\n翻墙\n目前使用的教程是 (https://github.com/Alvin9999/new-pac/blob/master/自建v2ray服务器教程.md)\nps. 建议直接机场购买，搞这个没用的速度又慢还贵\n","categories":["环境搭建"],"tags":["工具"]},{"title":"装机-软件安装（Linux）","url":"/posts/dada24a1/","content":"\n\n前言记录 Linux 安装教程\n\n\n更新\n\n\n24-09-12 初始记录\n\n默认操作为 root 权限，权限不足命令前加 sudo\nMySQL\n\n\nMySQL 8.0.26 下载\n\n\nwget https://downloads.mysql.com/archives/get/p/23/file/mysql-8.0.26-linux-glibc2.12-x86_64.tar.xz\n\n\n解压缩文件\n\n\ntar -xvf mysql-8.0.26-linux-glibc2.12-x86_64.tar.xz\n\n\n移动文件\n\n\nmv mysql-8.0.26-linux-glibc2.12-x86_64 /usr/local/mysql\n\n\n创建数据存放目录\n\n\n# cd到安装目录下mkdir data\n\n\n创建用户组和用户\n\n\ngroupadd mysqluseradd -g mysql mysql\n\n\n改变 mysql 目录权限\n\n\nchown -R mysql.mysql /usr/local/mysql/chown -R mysql .chgrp -R mysql .\n\n\n数据库初始化（需要记住临时密码）\n\n\n./bin/mysqld --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data --initialize\n\n\n修改 my.cnf 文件\n\n\nvim /etc/my.cnf# 文件内内容[mysqld]    basedir = /usr/local/mysql    datadir = /usr/local/mysql/data    socket = /usr/local/mysql/mysql.sock    character-set-server=utf8    port = 3306   sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES [client]   socket = /usr/local/mysql/mysql.sock   default-character-set=utf8\n\n\n创建 mysql 服务\n\n\n# 将 mysql.server 启动文件复制到 /etc/init.d 目录cp -a /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld# 赋予权限chmod +x /etc/rc.d/init.d/mysqld# 创建 mysql 服务chkconfig --add mysqld# 检查服务是否生效chkconfig --list mysqld\n\n\n配置全局环境\n\n\nvim /etc/profile# 添加如下配置export PATH=$PATH:/usr/local/mysql/bin:/usr/local/mysql/libexport PATH# 使环境变量设置生效source /etc/profile\n\n\n启动 mysql 服务\n\n\nservice mysql startservice mysql status\n\n\n登录 mysql 修改密码\n\n\n# 密码为之前的临时密码mysql -uroot -p# 修改密码ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123456&#x27;;\n\n\n设置 mysql 远程登录\n\n\nuse mysql;-- 允许任何主机使用 root 进行连接update user set host=&#x27;%&#x27; where user=&#x27;root&#x27; limit 1;-- 创建一个允许远程访问的 MySQL 账户CREATE USER &#x27;your_user&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;your_password&#x27;; GRANT ALL PRIVILEGES ON *.* TO &#x27;your_user&#x27;@&#x27;%&#x27; WITH GRANT OPTION;flush privileges;\nRedis\n\n\n源码安装与编译\n\n\nwget http://download.redis.io/redis-stable.tar.gztar -xzvf redis-stable.tar.gzcd redis-stablemake\n执行完 make 命令后，src 目录下会出现编译后的 redis 服务程序 redis-server，还有用于测试的客户端程序 redis-cli，两个程序位于安装目录 src 目录下\n\n\n安装可执行程序到 /usr/local/bin\n\n\nmake install\n\n\n前台运行启动\n\n\nredis-server# 使用指定配置文件启动cp redis.conf /etc/redis.confredis-server /etc/redis.conf\n\n\n其他命令\n\n\nredis-cliredis&gt; set foo barOKredis&gt; get foo&quot;bar&quot;redis-cli shutdown#直接关闭不保存内存redis-cli shutdown nosave\n\n\n配置 Redis 为后台服务将配置文件中的 daemonize no 改成 daemonize yes，配置 redis 为后台启动。\n\n\nRedis 设置访问密码在配置文件中找到 requirepass，去掉前面的注释，并修改后面的密码。\n\n\n设置远程可访问\n\n\n在配置文件中找到 bind 127.0.0.1 这一行，注释。\n如果 redis3.2 版本以上的，需要将保护模式（protected-mode）修改成 no\n\n\n常用的配置文件\n\n\n#默认端口6379port 6379#绑定ip，如果是内网可以直接绑定 127.0.0.1, 或者忽略, 0.0.0.0是外网bind 0.0.0.0#守护进程启动daemonize yes#超时timeout 300loglevel notice#分区databases 16save 900 1save 300 10save 60 10000rdbcompression yes#存储文件dbfilename dump.rdb#密码 abcd123requirepass abcd123\nDocker 和 Docker-compose\n\n\n安装 GCC 相关的环境\n\n\nyum -y install gccyum -y install gcc-c++\n\n\n安装 Docker 需要的依赖软件包\n\n\nyum install -y yum-utils device-mapper-persistent-data lvm2\n\n\n设置国内的镜像\n\n\nyum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n\n\n更新 yum 软件包索引\n\n\nyum makecache fast\n\n\n安装 DOCKER CE(注意：Docker 分为 CE 版和 EE 版，一般我们用 CE 版就够用了)\n\n\nyum -y install docker-ce\n\n\n启动 Docker\n\n\nsystemctl start dockerdocker version\n\n\n下载 Docker Compose 的当前稳定版本\n\n\nsudo curl -L &quot;https://github.com/docker/compose/releases/download/1.24.1/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose\n\n\n将可执行权限应用于二进制文件\n\n\nsudo chmod +x /usr/local/bin/docker-compose\n\n\n创建软链\n\n\nsudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose\n\n\n测试是否安装成功\n\n\ndocker-compose --version\nMinio\n\n\n服务器安装\n\n\nwget https://dl.min.io/server/minio/release/linux-amd64/miniochmod +x minioMINIO_ROOT_USER=admin MINIO_ROOT_PASSWORD=password ./minio server /mnt/data --console-address &quot;:9001&quot;\n\n\n客户端安装\n\n\nwget https://dl.min.io/client/mc/release/linux-amd64/mc chmod +x mc mc alias set myminio/ http://MINIO-SERVER MYUSER MYPASSWORD\n","categories":["环境搭建"],"tags":["Linux","工具"]},{"title":"设计模式-责任链模式","url":"/posts/b6c1490f/","content":"\n\n前言\n设计模式 - 责任链模式\n\n\n更新\n\n\n24-09-13 初始记录\n\n简单理解\n可以简单的理解为，针对一个请求，做多层处理（ 不分先后），并且这些处理可能随着业务需求进行不断变更，这个时候就可以用责任链模式。比如说 Spring 中的 Filter 使用的就是责任链模式。* 这里理解与策略模式的不同在于：责任链有点像 if return 会每个匹配比较，而策略像 map get key 直接匹配一个；责任链多用于解耦，策略多用于封装 *\n一般来说，这种多层处理可能代码中使用多个 if 来进行处理。处理方式可以如下：\n\n\n将处理的各个流程抽象为各个类（本来 Handler 里边有多个 if 和 方法)\n\n\n将多个类用 Chain 链起来，暴露一个方法给 Handler 使用\n\n\npublic interface Filter &#123;      // 过滤      void doFilter(String data);  &#125;    class Filter1 implements Filter &#123;      @Override      public void doFilter(String data) &#123;          //doSomething      &#125;  &#125;    class Filter2 implements Filter &#123;      @Override      public void doFilter(String data) &#123;          //doSomething      &#125;  &#125;    class Filter3 implements Filter &#123;      @Override      public void doFilter(String data) &#123;          //doSomething      &#125;  &#125;\npublic class FilterChain &#123;      List&lt;Filter&gt; filters = new ArrayList&lt;&gt;();        public FilterChain() &#123;          filters.add(new Filter1());          filters.add(new Filter2());          filters.add(new Filter3());    &#125;          public void processData(String data) &#123;          for (Filter filter : filters) &#123;              filter.doFilter(data);          &#125;      &#125;  &#125;\npublic class Handler &#123;      public void handlerRequest(Request request) &#123;          // 得到请求的数据          String data = request.getData();          FilterChain filterChain = new FilterChain();          // 处理数据          filterChain.processData(data);      &#125;  &#125;\n通用代码\n\n\n业务执行器接口，所有的业务实现都会实现该接口\n\n\n/**   * 业务执行器 */  public interface BusinessProcess &#123;      void process(ProcessContext context);  &#125;\n\n\n责任链上下文\n\n\n/**   * 责任链上下文 */  public class ProcessContext &#123;      // 标识责任链的code      private String code;      // 存储上下文的真正载体      private Model model;      // 责任链中断的标识      private Boolean needBreak = false;  &#125;\n\n\n业务执行模板（把责任链的逻辑串起来）\n\n\n/**   * 业务执行模板（把责任链的逻辑串起来）  */  public class ProcessTemplate &#123;      private List&lt;BusinessProcess&gt; processList;      public List&lt;BusinessProcess&gt; getProcessList() &#123;          return processList;      &#125;      public void setProcessList(List&lt;BusinessProcess&gt; processList) &#123;          this.processList = processList;      &#125;  &#125;\n\n\n责任链的流程控制器\n\n\n/**   * 责任链的流程控制器（整个责任链的执行流程通用控制） */  @Data  public class ProcessController &#123;            // 不同的code 对应不同的责任链      private Map&lt;String, ProcessTemplate&gt; templateConfig = null;        public void process(ProcessContext context) &#123;          //根据上下文的Code 执行不同的责任链          String businessCode = context.getCode();          ProcessTemplate processTemplate = templateConfig.get(businessCode);          List&lt;BusinessProcess&gt; actionList = processTemplate.getProcessList();          //遍历某个责任链的流程节点          for (BusinessProcess action : actionList) &#123;              try &#123;                  action.process(context);                  if (context.getNeedBreak()) &#123;                      break;                  &#125;              &#125; catch (Exception e2) &#123;                  //...              &#125;          &#125;      &#125;  &#125;\n\n\n举例用的两个实现\n\n\n/**   * 白名单处理器 */  @Service  public class WhiteListProcess implements BusinessProcess &#123;      @Override      public void process(ProcessContext context) &#123;          UserModel user = (UserModel) context.getModel();          if (&quot;3y&quot;.equals(user.getName())) &#123;              context.setNeedBreak(true);          &#125;      &#125;  &#125;    /**   * 发消息处理器 */  @Service  public class SendMessageProcess implements BusinessProcess &#123;        @Override      public void process(ProcessContext context) &#123;          UserModel user = (UserModel) context.getModel();          System.out.println(&quot;给&quot;+user.getName()+&quot;发消息&quot;);      &#125;  &#125;\n\n\n把处理器添加到 ProcessTemplate 模板，把 ProcessTemplate 添加到 ProcessController 的 Map 上\n\n\n&lt;!--发送消息的责任链--&gt;&lt;bean id=&quot;sendMessageTemplate&quot; class=&quot;com.chainofresponsibility.ProcessTemplate&quot;&gt;    &lt;property name=&quot;processList&quot;&gt;      &lt;list&gt;        &lt;ref bean=&quot;whiteListProcess&quot;&gt;&lt;/ref&gt;        &lt;ref bean=&quot;sendMessageProcess&quot;&gt;&lt;/ref&gt;      &lt;/list&gt;    &lt;/property&gt;  &lt;/bean&gt;    &lt;!--通用流程处理器，维护多条责任链--&gt;&lt;bean id=&quot;processController&quot; class=&quot;com.chainofresponsibility.ProcessController&quot;&gt;    &lt;property name=&quot;templateConfig&quot;&gt;      &lt;map&gt;        &lt;entry key=&quot;sendMessage&quot; value-ref=&quot;sendMessageTemplate&quot; /&gt;      &lt;/map&gt;    &lt;/property&gt;  &lt;/bean&gt;\n\n\n接口里执行责任链\n\n\n@RestControllerpublic class UserController &#123;    @Autowired    private ProcessController processController;      @RequestMapping(&quot;/send&quot;)    public void send(String userName) &#123;        // 构建上下文        ProcessContext processContext = new ProcessContext();          UserModel userModel = new UserModel();        userModel.setAge(&quot;24&quot;);        userModel.setName(userName);        processContext.setModel(userModel);        processContext.setCode(&quot;sendMessage&quot;);                processController.process(processContext);    &#125;&#125;\nPipeline\nRedis 会用 Pipeline 去做批量的操作。它是「责任链模式」的实现之一。\n// 具体分析 todo\n","categories":["设计模式"],"tags":["设计模式","责任链模式"]},{"title":"Docker拉取失败","url":"/posts/4512ff84/","content":"\n\n前言参考文章：彻底解决docker：docker: Get https://registry-1.docker.io/v2/: net/http: request canceled 报错\n\n\n更新\n\n\n24-12-12 初始记录\n\n问题\ndocker配置了镜像，拉取失败。报错信息：ERROR: Get &quot;https://registry-1.docker.io/v2/&quot;: net/http: request canceled while waiting for connection\n原因\n镜像地址失效。\n解决\n换源\n\n本次未使用，需要换源重启，但是原docker中含有跳板机，需要跳板机才能连接上服务器，重启会导致跳板机连接失败。\n\n\n\n修改 /etc/docker/daemon.json文件\n\n\n加入镜像配置\n\n\n重启\n\n\nsystemctl daemon-reload   systemctl restart docker\n修改DNS服务配置\n\n未使用\n\n手动拉取\n\n解决。需要注意的是手动拉取后，使用docker-compose进行部署，需要填写拉取的镜像（加上仓库名），不然依旧会从原地址拉取\n\ndocker pull 仓库名/镜像名:版本号# 暂时可用的一个仓库docker.m.daocloud.io\n给docker配置一个代理\n\n未使用。\n\n","categories":["bug记录","2024"],"tags":["docker"]},{"title":"Keep 主题更新 tools 功能报错 btoa is not defined","url":"/posts/9344475e/","content":"\n\n前言不是专业前端，此问题通过 Chat GLM 解决\n\n\n更新\n\n\n24-06-17 初始记录\n\n问题\nKeep 主题更新 tools 功能，但是访问 tools 模板页面报错：btoa is not defined。\n原因\n根据 Chat GLM 的描述。\n\n如果你遇到了 btoa is not defined 的错误，这意味着 btoa 函数在你的环境中不可用。btoa 是浏览器环境中用于将字符串编码为 Base64 的函数，而在 Node.js 环境中没有这个全局函数。\n在 Node.js 中，你可以使用 Buffer 类来实现相似的功能。下面是一个不使用 btoa 的替代方案，它可以在 Node.js 和浏览器环境中都工作。\n\n解决\n找到 node_module 中 keep 主题的安装位置：一般在这个地方（…/blog/node_modules/hexo-theme-keep/layout/_template）。在这个文件夹中的 tools-nav.ejs 为更新后的 tools 页面模板文件。\n修改开始部分代码，注释第一行，改成使用 Buffer 转换的方式（这部分也是 Chat GLM 给出的建议）：\n&lt;%  // const btoaStr = (str) =&gt; btoa(encodeURIComponent(str)).trim().replaceAll(&#x27;=&#x27;, &#x27;&#x27;)  const btoaStr = (str) =&gt; &#123;      // 使用 Buffer 将字符串转换为 Base64 编码      const base64 = Buffer.from(str).toString(&#x27;base64&#x27;);        // 去除 Base64 编码字符串中的等号      const base64Url = base64.replace(/\\+/g, &#x27;-&#x27;).replace(/\\//g, &#x27;_&#x27;).replace(/=/g, &#x27;&#x27;);        return base64Url;  &#125;;  const tools_data = theme.source_data.tools  const tools_nav_data = theme.source_data.tools.filter((t) =&gt; t?.category)  %&gt;\n","categories":["bug记录","2024"]},{"title":"Leetcode与本地结果不一致问题","url":"/posts/f9d0f046/","content":"\n\n前言参考文章：Leetcode与本地结果不一致问题解决及分析\n\n\n更新\n\n\n24.06.08 初始记录\n\n问题\nLeetcode 提交的代码，测试用例不通过。想在本地调式查看，但是本地是没有问题的。\n原因\n本地在 main 方法中直接调试，部分全局变量使用了 static 关键字，Leetcode 只加载了一次 Solution 类。导致全局变量没有恢复初始值。\n解决\n全部变量再提交到 Leetcode 时，手动删除 static 关键字。\n","categories":["bug记录","2024"]},{"title":"Long长度大于17位时，精度丢失","url":"/posts/b4cd8fc4/","content":"\n\n更新\n\n\n24.06.06 初始记录\n\n问题\n前端 JS 在 Long 长度大于 17 位时，出现精度丢失的问题\n解决\n在此处添加注 解将返回给前端的门店 ID 自动转为 string 类型。\n\n\n使用 jackson 来完成自动转换，添加依赖\n\n\n&lt;dependency&gt;      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;      &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;    &lt;version&gt;2.9.8&lt;/version&gt;&lt;/dependency&gt;\n\n\n在对应的实体类中添加注解\n\n\n@JsonSerialize(using= ToStringSerializer.class) private Long id;\n","categories":["bug记录","2024"],"tags":["BUG","Java"]},{"title":"RestTemplate使用GET请求，返回中文乱码","url":"/posts/419abf20/","content":"\n\n更新\n\n\n24.05.23 初始记录\n\n问题\n测试 RestTemplate 的 Get 请求，返回中文乱码。\n原因\n当 RestTemplate 默认使用 String 存储 body 内容时默认使用 ISO_8859_1 字符集。\n解决\n配置 StringHttpMessageConverter 消息转换器，使用 utf-8 字符集。\n@Bean  public RestTemplate restTemplate() &#123;      RestTemplate restTemplate = new RestTemplate(new OkHttp3ClientHttpRequestFactory());      //消息转换器列表      List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters = restTemplate.getMessageConverters();      //配置消息转换器StringHttpMessageConverter，并设置utf‐8      messageConverters.set(1, new StringHttpMessageConverter(StandardCharsets.UTF_8));      return restTemplate;  &#125;\n","categories":["bug记录","2024"],"tags":["BUG","Java","RestTemplate"]},{"title":"MybatisPlus多表联查分页，Total计数异常","url":"/posts/ae58dfcb/","content":"\n\n更新\n\n\n24.04.19 初始记录\n\n问题\n使用 MP 的分表联查，出现了查询出 10 条数据，但是 Total 数量显示 4 的问题。一开始以为是 SQL 书写错误，但是看了同样一张表的另一个 SQL，只是加上了 GROUP BY，就可以显示正确的 Total 数。\nDEBUG\n控制台输出 SQL 语句，发现 count() 语句的记录只到了 left join 前，所以计数异常。\n解决\n使用 page 方法时：加上以下语句\n// 需要手动把sql的优化关闭。不然计数的时候只会查主表的记录数page.setOptimizeCountSql(false);  \n这里在源码中默认是开启的\n\n如果不关闭将会导致计算总记录数据的时候，sql 语句会丢弃后面的子查询，造成记录数结果不正确。\n","categories":["bug记录","2024"],"tags":["BUG","Java","MybatisPlus"]},{"title":"使用 git 提交报错：error RPC failed; HTTP 413 curl 22 The requested URL returned error 413","url":"/posts/5a672f0a/","content":"\n\n前言参考文章：使用git提交时报错：error: RPC failed； HTTP 413 curl 22 The requested URL returned error: 413 Request Entity\n\n\n更新\n\n\n24-07-19 初始记录\n\n问题\n使用 git push 时报错\nTotal 254 (delta 50), reused 0 (delta 0), pack-reused 0error: RPC failed; HTTP 413 curl 22 The requested URL returned error: 413send-pack: unexpected disconnect while reading sideband packetfatal: the remote end hung up unexpectedly\n原因\n\n413 Request Entity Too Large 服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。\n\n解决\n\n\n修改上传的数据限制好像没用\n\n\ngit config --global http.postBuffer 52428800\n\n\n使用 ssh 方式上传还是不行\n\n\n（1）查看当前 git 的提交地址\ngit remote -v\n（2）查看 ssh 仓库地址\n（3）设置更换远程仓库地址\ngit remote set-url origin 复制过来的ssh地址\n（4）再次提交\n\n\n原先在提交目录下加了一个 1G 多的 doc 目录，删除了这个文件，但是返回如下报错信息。\n\n\nremote: This repository(including wiki) size 2.25 GB, exceeds 1024.00 MB.        remote: You only have 3 push opportunities        remote: HelpLink:       https://gitee.com/help/articles/4232        remote: Repository GC:  https://gitee.com/kiml_rgb/shanjupay/settings#git-gcerror: File: 1e079cdcb1b8f36ed4bb8a17a78df5582ca9db14 2.24 GB, exceeds 100.00 MB.    \n（1）按照提示执行命令查看超大的文件\ngit rev-list --objects --all | grep 1e079cdcb1b8f36ed4bb8a17a78df5582ca9db14\n（2）执行命令忽略掉超大的文件\ngit rm --cached file_name#如果是文件夹git rm -r --cached directory_name\n（3）在 commit 的提交历史里面去除这个超大文件（注意这里要填写步骤 1 查询出的文件全称，包括文件路径）\ngit filter-branch --tree-filter &#x27;rm -f 文件名&#x27; HEAD\n（4）如果报错：\nWARNING: git-filter-branch has a glut of gotchas generating mangled history         rewrites.  Hit Ctrl-C before proceeding to abort, then use an         alternative filtering tool such as &#x27;git filter-repo&#x27;         (https://github.com/newren/git-filter-repo/) instead.  See the         filter-branch manual page for more details; to squelch this warning,         set FILTER_BRANCH_SQUELCH_WARNING=1.\n执行以下命令，然后重新执行移除命令：\ngit stash\n出现 … was rewritten 记录说明执行成功。再次使用 git push 成功。\n","categories":["bug记录","2024"],"tags":["Git","BUG"]},{"title":"使用mapstruct转换对象，报错Cannot find implementation for……","url":"/posts/82c00b85/","content":"\n\n前言参考文章：mapstruct 报错 java.lang.ClassNotFoundException: Cannot find implementation for\n\n\n更新\n\n\n24.06.05 初始记录\n\n问题\n使用 mapstruct 转换对象，接口可以启动，但是执行报错：\njava.lang.ClassNotFoundException: Cannot find implementation for com.…….convert.AuthorizationPrivilegeConvert\n原因\n注解没有引用全。\n解决\n添加依赖，重启服务。\n&lt;dependency&gt;   &lt;groupId&gt;org.mapstruct&lt;/groupId&gt;   &lt;artifactId&gt;mapstruct-jdk8&lt;/artifactId&gt;   &lt;version&gt;……&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.mapstruct&lt;/groupId&gt;    &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt;    &lt;version&gt;……&lt;/version&gt;&lt;/dependency&gt;\n","categories":["bug记录","2024"],"tags":["BUG","Java"]},{"title":"跨域产生的原因及解决方案","url":"/posts/f5b0876a/","content":"\n\n前言\n面试必会，总结一下\n\n\n更新\n\n\n24-08-22 初始记录\n\n跨域的原因\n跨域是是因为浏览器的同源策略限制，是浏览器的一种安全机制，服务端之间是不存在跨域的。\n所谓同源指的是两个页面具有相同的协议、主机和端口，三者有任一不相同即会产生跨域。\n跨域举例\n\n\n\n当前页面 url\n被请求页面 url\n是否跨域\n原因\n\n\n\n\nhttp://www.test.com/\nhttp://www.test.com/index.html\n否\n同源（协议、域名、端口号相同）\n\n\nhttp://www.test.com/\nhttps://www.test.com/index.html\n跨域\n协议不同\n\n\nhttp://www.test.com/\nhttp://www.baidu.com/\n跨域\n主域名不同\n\n\nhttp://www.test.com/\nhttp://blog.test.com/\n跨域\n子域名不同\n\n\nhttp://www.test.com:8080/\nhttp://www.test.com:7071/\n跨域\n端口号不同\n\n\n\n跨域的解决办法\n以下跨域解决方式选择一种，重复配置不会生效。\nJava 配置\n\n\n\n使用 @CrossOrigin 注解实现跨域【局域类跨域】（一般不用，没有记录）\n\n\n通过配置文件实现跨域【全局跨域】\n\n\n通过 CorsFilter 对象实现跨域【全局跨域】\n\n\n通过 Response 对象实现跨域【局域方法跨域】（一般不用，没有记录）\n\n\n通过实现 ResponseBodyAdvice 实现跨域【全局跨域】（一般不用，没有记录）\n\n\n\n\n\n通过配置文件实现跨域（重写 WebMvcConfigurer）\n\n\n@Configurationpublic class CorsConfig implements WebMvcConfigurer &#123;     @Override    public void addCorsMappings(CorsRegistry registry) &#123;        registry.addMapping(&quot;/**&quot;)                .allowedOrigins(&quot;*&quot;)                .allowedHeaders(&quot;*&quot;)                .allowCredentials(true)                .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;OPTIONS&quot;, &quot;DELETE&quot;, &quot;PUT&quot;, &quot;PATCH&quot;)                .maxAge(3600);    &#125;&#125;\n\n\n返回新的 CorsFilter（跨域配置）\n\n\n@Configurationpublic class GlobalCorsConfig &#123;     @Bean    public CorsFilter corsFilter() &#123;        //1. 添加 CORS配置信息        CorsConfiguration config = new CorsConfiguration();        // 放行哪些原始域        config.addAllowedOrigin(&quot;*&quot;);        // 是否发送 Cookie        config.setAllowCredentials(true);        // 放行哪些请求方式        config.addAllowedMethod(&quot;*&quot;);        // 放行哪些原始请求头部信息        config.addAllowedHeader(&quot;*&quot;);        // 暴露哪些头部信息        config.addExposedHeader(&quot;*&quot;);        //2. 添加映射路径        UrlBasedCorsConfigurationSource corsConfigurationSource = new UrlBasedCorsConfigurationSource();        corsConfigurationSource.registerCorsConfiguration(&quot;/**&quot;,config);        //3. 返回新的CorsFilter        return new CorsFilter(corsConfigurationSource);    &#125;&#125;\nNginx 配置\nserver &#123;    listen       80;    server_name  your_domain.com;    location /api &#123;        # 允许跨域请求的域名，* 表示允许所有域名访问        add_header &#x27;Access-Control-Allow-Origin&#x27; &#x27;*&#x27;;        # 允许跨域请求的方法        add_header &#x27;Access-Control-Allow-Methods&#x27; &#x27;GET, POST, OPTIONS&#x27;;        # 允许跨域请求的自定义 Header        add_header &#x27;Access-Control-Allow-Headers&#x27; &#x27;Origin, X-Requested-With, Content-Type, Accept&#x27;;        # 允许跨域请求的 Credential        add_header &#x27;Access-Control-Allow-Credentials&#x27; &#x27;true&#x27;;        # 预检请求的存活时间，即 Options 请求的响应缓存时间        add_header &#x27;Access-Control-Max-Age&#x27; 3600;        # 处理预检请求        if ($request_method = &#x27;OPTIONS&#x27;) &#123;            return 204;        &#125;    &#125;    # 其他配置...&#125;\nGateway 网关配置\n\n\n\n通过在配置文件中配置跨域实现。\n\n\n通过在框架中添加 CorsWebFilter 来解决跨域问题。\n\n\n\n\n\n通过在配置文件中配置跨域实现。\n\n\nspring:  cloud:\tgateway:  \t  globalcors:  \t    cors-configurations:  \t      &#x27;[/**]&#x27;: # 匹配所有请求  \t        allowedHeaders: &quot;*&quot;  \t        allowedOrigins: &quot;*&quot; #跨域处理 允许所有的域  \t        allowedMethods: # 支持的方法  \t          - GET  \t          - POST  \t          - PUT  \t          - DELETE  \t          - OPTIONS\n\n\n通过在框架中添加 CorsWebFilter 来解决跨域问题。\n\n\n// 在 Spring-Framework 从 5.3 版本之前，使用以下代码可以让 Spring Cloud Gateway 网关允许跨域：@Configurationpublic class GlobalCorsConfig &#123;    @Bean    public CorsWebFilter corsWebFilter() &#123;        CorsConfiguration config = new CorsConfiguration();        // 这里仅为了说明问题，配置为放行所有域名，生产环境请对此进行修改        config.addAllowedOrigin(&quot;*&quot;);        // 放行的请求头        config.addAllowedHeader(&quot;*&quot;);        // 放行的请求类型，有 GET, POST, PUT, DELETE, OPTIONS        config.addAllowedMethod(&quot;*&quot;);         // 暴露头部信息        config.addExposedHeader(&quot;*&quot;);         // 是否允许发送 Cookie        config.setAllowCredentials(true);         UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();        source.registerCorsConfiguration(&quot;/**&quot;, config);        return new CorsWebFilter(source);    &#125;&#125;// 而 Spring-Framework 5.3 版本之后，关于 CORS 跨域配置类 CorsConfiguration 中将 addAllowedOrigin 方法名修改为 addAllowedOriginPattern，因此配置了变成了以下这样：@Configurationpublic class GlobalCorsConfig &#123;    @Bean    public CorsWebFilter corsWebFilter() &#123;        CorsConfiguration config = new CorsConfiguration();        // 这里仅为了说明问题，配置为放行所有域名，生产环境请对此进行修改        config.addAllowedOriginPattern(&quot;*&quot;);        // 放行的请求头        config.addAllowedHeader(&quot;*&quot;);        // 放行的请求类型，有 GET, POST, PUT, DELETE, OPTIONS        config.addAllowedMethod(&quot;*&quot;);         // 暴露头部信息        config.addExposedHeader(&quot;*&quot;);         // 是否允许发送 Cookie        config.setAllowCredentials(true);         UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();        source.registerCorsConfiguration(&quot;/**&quot;, config);        return new CorsWebFilter(source);    &#125;&#125;\n","categories":["bug记录","2024"]},{"title":"Freemarker 基础","url":"/posts/e9ae925d/","content":"\n\n前言\nJava 开发的模板引擎。官网模板：Template + data-model = output - Apache FreeMarker Manual\n\n\n更新\n\n\n24-07-23 初始记录24-07-26 bug记录\n\n快速入门\nfreemarker 作为 Spring MVC 一种视图格式，默认情况下 SpringMVC 支持 freemarker 视图格式。\nMaven 依赖\n&lt;!--父工程指定SpringBoot版本--&gt;&lt;parent&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring‐boot‐starter‐parent&lt;/artifactId&gt;      &lt;version&gt;2.1.3.RELEASE&lt;/version&gt;  &lt;/parent&gt;&lt;!--freemarker依赖--&gt;&lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring‐boot‐starter‐freemarker&lt;/artifactId&gt;  &lt;/dependency&gt;\n配置文件\n# freemarker基本配置spring:  freemarker:    charset: utf-8    request‐context‐attribute: rc    content‐type: text/html    suffix: .html    enabled: trueresources:  add‐mappings: false #关闭工程中默认的资源处理mvc:  throw‐exception‐if‐no‐handler‐found: true #出现错误时直接抛出异常\n代码使用\n\n\n添加 view 映射\n\n\n@Component  public class WebMvcConfig implements WebMvcConfigurer &#123;      @Override      public void addViewControllers(ViewControllerRegistry registry) &#123;  \t    // 注意这里不要添加后缀        registry.addViewController(&quot;/pay-page&quot;).setViewName(&quot;pay&quot;);          registry.addViewController(&quot;/pay-error&quot;).setViewName(&quot;pay_error&quot;);       &#125;  &#125;\n\n\n返回 Controller 注解不要加 @ResponseBody 或 @RestController（这个注解把返回的信息转成 json 返回，不能实现页面跳转的功能）\n\n\n返回使用 forward:\n\n\nreturn &quot;forward:/pay-error&quot;;\n基础指令\n\n1、注释，即 &lt;#‐‐和‐‐&gt;，介于其之间的内容会被 freemarker 忽略\n2、插值（Interpolation）：即 $&#123;..&#125; 部分，freemarker 会用真实的值代替 $&#123;..&#125; \n3、FTL 指令：和 HTML 标记类似，名字前加 # 予以区分，Freemarker 会解析标签中的表达式或逻辑。\n4、文本，仅文本信息，这些不是 freemarker 的注释、插值、FTL 指令的内容会被 freemarker 忽略解析，直接输出内容。\n\nList 指令\n\n说明： _index：得到循环的下标，使用方法是在 stu 后边加 _index，它的值是从 0 开始\n\nList&lt;Student&gt; stus = new ArrayList&lt;&gt;();\n&lt;table&gt;  &lt;tr&gt;    &lt;td&gt;序号&lt;/td&gt;\t&lt;td&gt;姓名&lt;/td&gt;\t&lt;td&gt;年龄&lt;/td&gt;\t&lt;td&gt;钱包&lt;/td&gt;  &lt;/tr&gt;  &lt;#list stus as stu&gt;    &lt;tr&gt;\t  &lt;td&gt;$&#123;stu_index + 1&#125;&lt;/td&gt;\t  &lt;td&gt;$&#123;stu.name&#125;&lt;/td&gt;\t  &lt;td&gt;$&#123;stu.age&#125;&lt;/td&gt;\t  &lt;td&gt;$&#123;stu.mondy&#125;&lt;/td&gt;\t&lt;/tr&gt;  &lt;/#list&gt;&lt;/table&gt;\nMap 指令\nHashMap&lt;String,Student&gt; stuMap = new HashMap&lt;&gt;();\n输出stu1的学生信息：&lt;br/&gt;姓名：$&#123;stuMap[&#x27;stu1&#x27;].name&#125;&lt;br/&gt;年龄：$&#123;stuMap[&#x27;stu1&#x27;].age&#125;&lt;br/&gt;输出stu1的学生信息：&lt;br/&gt;姓名：$&#123;stuMap.stu1.name&#125;&lt;br/&gt;年龄：$&#123;stuMap.stu1.age&#125;&lt;br/&gt;遍历输出两个学生信息：&lt;br/&gt;&lt;table&gt;  &lt;tr&gt;    &lt;td&gt;序号&lt;/td&gt;    &lt;td&gt;姓名&lt;/td&gt;    &lt;td&gt;年龄&lt;/td&gt;    &lt;td&gt;钱包&lt;/td&gt;  &lt;/tr&gt;  &lt;#list stuMap?keys as k&gt;    &lt;tr&gt;  \t  &lt;td&gt;$&#123;k_index + 1&#125;&lt;/td&gt;  \t  &lt;td&gt;$&#123;stuMap[k].name&#125;&lt;/td&gt;  \t  &lt;td&gt;$&#123;stuMap[k].age&#125;&lt;/td&gt;  \t  &lt;td&gt;$&#123;stuMap[k].mondy&#125;&lt;/td&gt;    &lt;/tr&gt;  &lt;/#list&gt;&lt;/table&gt;\nif 指令\n&lt;table&gt;  &lt;tr&gt;    &lt;td&gt;姓名&lt;/td&gt;    &lt;td&gt;年龄&lt;/td&gt;    &lt;td&gt;钱包&lt;/td&gt;  &lt;/tr&gt;  &lt;#list stus as stu&gt;    &lt;tr&gt;      &lt;td &lt;#if stu.name ==&#x27;小明&#x27;&gt;style=&quot;background:red;&quot;&lt;/#if&gt;&gt;$&#123;stu.name&#125;&lt;/td&gt;      &lt;td&gt;$&#123;stu.age&#125;&lt;/td&gt;      &lt;td&gt;$&#123;stu.mondy&#125;&lt;/td&gt;    &lt;/tr&gt;  &lt;/#list&gt;&lt;/table&gt;\n运算符\n\n\n算数运算符 FreeMarker 表达式中完全支持算术运算，FreeMarker 支持的算术运算符包括:+, - , * , / , %\n\n\n逻辑 运算符 逻辑运算符有如下几个: 逻辑与 &amp;&amp; 逻辑或 || 逻辑非 ! 逻辑运算符只能作用于布尔值，否则将产生错误\n\n\n比较运算符 表达式中支持的比较运算符有如下几个:\n\n= 或者 == 判断两个值是否相等\n!= 判断两个值是否不等\n&gt; 或者 gt 判断左边值是否大于右边值\n&gt;= 或者 gte 判断左边值是否大于等于右边值\n&lt; 或者 lt 判断左边值是否小于右边值\n&lt;= 或者 lte 判断左边值是否小于等于右边值\n\n\n\n\n注意：= 和 != 可以用于字符串，数值和日期来比较是否相等，但 = 和 != 两边必须是相同类型的值，否则会产生错误，而且 FreeMarker 是精确比较，“x”,&quot;x &quot;,“X” 是不等的。其它的运行符可以作用于数字和日期，但不能作用于字符串，大部分的时候,使用 gt 等字母运算符代替 &gt; 会有更好的效果,因为 FreeMarker 会把 &gt; 解释成 FTL 标签的结束字符,当然,也可以使用括号来避免这种情况，如：&lt;#if (x&gt;y)&gt;\n\n空值处理\n\n\n判断某变量是否存在使用 ?? 用法为：variable??，如果该变量存在，返回 true，否则返回 false\n\n\n&lt;#if stus??&gt;&lt;#list stus as stu&gt;...\n\n\n缺失变量默认值使用 ! 使用 ! 要以指定一个默认值，当变量为空时显示默认值。\n\n\n&lt;#--如果name为空显示空字符串。--&gt;$&#123;name!&#x27;&#x27;&#125;&lt;#--如果stu或bestFriend或name为空默认显示空字符串。--&gt;$&#123;(stu.bestFriend.name)!&#x27;&#x27;&#125;\n内置对象\n在 freemarker 中可以访问 Request、Session 等内置对象。\nRequest： 用于获取 Request 对象中的 attribute 对象。\nSession：用于获取 Session 对象中的 attribute 对象。\nRequestParameters：用于获取 Request 对象的 parameter 参数（浏览器端发送的请求数据）\n\n\n配置\n\n\nspring:   freemarker:     request‐context‐attribute: rc #把Spring的RequestContext对象暴露为变量rc     expose‐request‐attributes: true     expose‐session‐attributes: true\n\n\n例子在 Controller 中设置 request、session 的属性值\n\n\n//测试内置对象 request.setAttribute(&quot;attr1&quot;,&quot;test&quot;); HttpSession session = request.getSession(); session.setAttribute(&quot;session1&quot;, &quot;user1&quot;);\n页面获取数据\nurl请求参数：$&#123;RequestParameters[&#x27;param1&#x27;]!&quot;&quot;&#125; request Attribute:$&#123;Request[&quot;attr1&quot;]!&quot;&quot;&#125; session Attribute:$&#123;Session[&quot;session1&quot;]!&quot;&quot;&#125; 工程路径：$&#123;rc.contextPath&#125; 请求地址: $&#123;rc.requestUri&#125;\nBUG\n访问报错 404\n\n\n检查是否添加了 view 映射，注意不要加后缀。\n\n\n检查 Controller 层使用的注解：不要加 @ResponseBody 或 @RestController（这个注解把返回的信息转成 json 返回，不能实现页面跳转的功能）\n\n\nnacos 配置文件读取失败（不确定原因重启 nacos 后就好了）：使用 nacos 读取配置文件，出现自动装配时 suffix 没有读取到的情况。（本地配置使用.html 可以读取成功，但是放到 nacos 后，FreeMarkerProperties 中的 suffix 属性始终为默认的 .ftl，并且从springboot2.0开始默认的 suffix 为 .ftlh）\n\n但是这里还是建议使用 .ftl，不然后序接口调用处可能会出 bug\n\n\n\n","categories":["后端项目","准备工作"],"tags":["Java","Freemarker"]},{"title":"Jenkins + k8s 实现 CICD（持续集成和持续部署）","url":"/posts/60f8da4b/","content":"\n  972a4ea99218889cef049d656e4bf4b2b3f032f944a5ceeb3ea8aead21368f745f71bc99025aa2e705d9ccd09d86707ac6e343b6bce3cbb001b83a7cf7cfb1079c3dceccc68c9c8c4cf2e2ad3c3a69a8c892c0a95bfc866c10ae4092d65c4914688402a31e1b797be6ea0d67ef80d47a5552a85635be0dd01893a6ef43339426901a8c802280a33371f100ddf7f8ccedba9ee463f4b49d3bac6ae22dd6bb22274ecaab942d64a18d7ca45e2259763be82abb2d9f312a6a722f0cdd4cc1c9c5467d6f65f3375df6d9e88d972ef413a9ee9d0448446f852f37e60354ec4f6092774924fd0dfad472fdbf34e3c16627a6829db3ab5f0e6d5b6029dbc3f0def87dc052795e08bff2401ab407ae991ab1fc05b4ebe0231ba27fb294a5e4fad8cda77ab6bf46870fd0de75d6bac8e26fc72e854a8d6875148eb92446048079e9f14d182be00c10b69b14beb08ae5403e566adaf2bdc57e1495cbf0f543ea806198796212a29ed0d0a856ed3d450d18db26e813b8af2e74477cf20d757375780537286de39b5c8c9037e58680397d9801e423f2ce98546c6c8948460b434d52c1d47801e45c8598b2ce8098cae070906362eae48bf6aa1b3360bff34ea3a227db5c282ffa9204df03df591de6e0eec6357034da890ad6954ce4f2dacdc2a0a38a7d8aa86e2ceec1cc6af87e19108c38982d5e841a2d513e49a58d7645bc84decb40e66ddc5193e727aa2d6e3fc5e8a6898dca80231aaf3a667e0c9e3fe1698f9dfdab90ab52438e0df1967b58f42fc8e55c62f52d38bb926324d395efcae777ea24c07ec781754a31432850553bbc339465c00272a9f1c94e62f1c794ecbaa32aaee041b5303e7301a27cd8fd6fa343a6c761ce020c328aa769fb52d14b3dc85bde78862ea09abd90854cc4a5cc7b275f4df083f98642fbbd4c9f9eba0bd66cbec9ca28e17c4f3b88d084e078f8d9e4e93614158f8dbe8ff5be1f6d2a8654f0c860046a4d26638715be06c87e9fa69ba4e1ddc07e2b0ed8d84cd68b4cef489be6b875a97026f949e0a2eb4b8faa69a3d60babb7c8a1593373c5564d0a34988ae11b33543d6718b613734f69d3a4acec1f399dd0965702e3d40b52bb572f0a0fa892c3decb6540466ac069276b01183069e572ba89dd7370278fe1affc7ed94dea9b33de0e46f2bc8d6813c6b298efe261c95b785be9791258360004ccd83fb18d545b4403b25993ede6bbfef47cec267d6fb76e3aca5ee8f459f12a8cd28bded8722ce56def08543510eb3d18f38abd7da0b02bf757a0f400fa5cbf3973997553510e2105dd27ca04760323c0484d407d1e632256b6bc18d9f5c88169a78e15cebc63ba86664e0ccfbd688432ecf4e04e9f62d1beac5464865bea62695873205367691378218792bbe1b19dee5efcce799c6f38563e00c4337966db5a467af2d04c08533cedd4f33d0685a1fd3cfee2fe23e23099db1c988e6cbc88331ca47ac560c569b99c933b23e57f9f05c097b1508bb3adfab01148790d9a981a56f955a9bc6b9c83596c17e2f3f1be2c2ed025d63bbebad40b75ba0d1a2a320689235ab7f1a47f2889f509353e8d357e7b1f0384edfbf84c79b1334e2cd7bd51c707275f79bedd01908652206ff1808bf0b422cfccb0997358233f50ef88c50f349bf23351c104972e9a4a6da7d7ba135118a700dc32fa483f0d212d4295ac3ecbf80c625ccee079e75abe7b3059a30b43545daee782dd2df6f151ee23791c6d968384d141bb0183ab52c3f9346d3965746c4fbd2c67a83ea2665a1129cc7694369f87e1e5faea4fcc70fe7e21cca9319b469f221da2a650ea41d6d398657856d114b1faea0ed7612bf74d63b04356229e06dd34f4e2fe61b8fbe5c61fa685e0a1522b9d6ab56e3469feb14bcde24f32f8317dcd2c11a7c738cfbb87e3e50a98a61c6fb4fcc55e2364eec61707598248bdf9702d7407b9db9c1823e0d0155a3f0c9a48fec4c1051e8dbf5a9c9ccafe6c5b05113e4feea986f3a52d573b5447b4a63a557488303e73847fbce0d1676fbd4177e31027e1db3f28bc78c0b0d3423043e20aadf5853597a651bdcbc332ae7b7255f6dfcf267e4354d847c8da261d0a7e7e5a049f8b259d2b8aa3be6502d73d3342b7d57a1e9f3dabe924d01ea7aeff3c98f659bb7178e0f29fc25718914ef32cdff4f1c2d29ebcc36f1c6e238555f21c0c44b4af48a4bb0d28168b0503937e500acf881281e8008b82485dbe906ca401f8edee67cf7f177e959e1661f203579f2ef24996f0b04b373f5d1fca92553c8bc7332d6d976f9371e10482a054578f373967a2be9a6ad925bfbedc9c0193ed6e461b63f0afa2997b947a5bb9fa8b5a0f68c3ad537ae07619b525095a9aa4db1cb4b54213d986c93ae18e0b92b9e24c94a012ec5cdcf7c00ba1fb416bb11d31f847436b886c0d0148679d4d556d7af15b304ff32ed1dfcb5136f9174d04c2425abe11d10f03d62b4ce4ad45b90ff7b04c07199e3a486b52e2117cac6a27d8693268c2675867de5ec86e277ece03c47307456f9599d8955c74d9b4d1a54aefe428a11b927494199698bde1ffbf49f9bf05c4b27d1c79e238aac9d2fa53b61fe4b9c917f2ce9b1e7b493572cea70f9b2f017b33c90e6c9a282cc41ace227e6af5bff0e5e57bd25cd2a474d037e46edc4ee71b3359f7a63322769f0fe2dbea93a9556d46e7053149aab757d83e884ca7ebbca53c5ece0f17df7f001ab0654abb0049e0036818a5150b2b57b2271db12c1109d8dc1c3b5939bafd49ac64a12bbb1e76a46d491ee5490eaad267134d0d9aa573e7ed45a4fa839abe470d0b5abcc42d7668720f4bee69bc532151b60be3bf914887f49fb2f7df56984a002d0346e65a5d591784c0e74fda48c09e1cbed059558bee205b350bff566f65ff0dcce951d1189769914965cd429262fc70f94b8bdd89cd45f7104fcacbc1cad55ee75c7bccfd27c7782f4ea0eaece4d07ffc342db37af691a08d57d9ea933be96f4a4f724f562e3173fe51f2c68aa9372fa55e27bc4d8d01a909ff51a547d2accd9fab68e56889d165895ab2799ef13f9e805f7fe84d4af659ad7a71f2b8d7876a57e8f6574b2694a86fd17901cfe6cc9fd612791c3fc74d0dc1c57532dea80f6d8e75a0048227e487f26eb16a114110b7ffd8d1b94152605d70c3dd39d35f69974a2cc0b297e1d2cfa5d1f81224bfd7ec0b370c1aea738d415773af418f3dee8bf4974335fa3861cccb9d157d21c8b474fa87b640319a3311e9a960d4d133d535447032f8bdf85571b044d08c26c7546f97d3a5e6935a015edc46e3028214fd0f62f74310b622712a271393b5c5343ba793357a6df499309e77f85ed1e2e3ea10ff6a7ec2906e0a69fff6fa82f202aba6f8166dc74b83e9537b6fd437aa71d6a45a7522b09a28b6b7be131a01c77e70cd5ecfa04c42c17661ef2393e5760fbe53d3495d84f6121c02337c3805642bb9367b7b790db577f5b6679bf71e3913cbc8eade69c2564e24b5594d052477953fb6669c364c87c2ec9af21464bc03a2ea11caf85c32c7c1e5f74ebf64293f420eacf8ce639046e779ab20cb32596eea0be6361141baeae8734ce4779fa124afff905874be625e796eed41b3d418db41799ae1d2bd423f8c44b6d7c858b180269b68bac6d78f30735dfa0d9dbf6611f31e747bf7b5c79bc97d5547813c95e642409690ccf102407b992e1523873bb80013b108258226fef72639e3080dcfd0c811f0f4e140cab42095b66c8335e669cdae82e04f9b0b389498f03abaab12bac23cd9b0ab111e9df0aa6ba2f06391fce72709997f33dfb08342ebe88a6b9cf6970be73ab3d3919d74f492831cd81b4e8cc5d641d1d61f1d59a976f8b9de60009829e3fc9bd1c1a0ecba7b56d3ec416be2e704b9de0769d1c8a152a9bf487ec43a7840efbe2a0ba8888bc813027081d2ae6bc6ae349d5763b4758f20222817f6f26701dd4d9960f8f051ae6ec607de819b413de8e5b5358932de7771534a1d18696fe3040c52c5edd08254690c706ddd751f924a9323bb8a6b56bffe113e2b01a7619aa2e079d3d3c31d83e347e56f096bd0686ba1a3d44dec91cad26bb2f9a600e661433e9c77d588e5292b742d39d413e9a217c649d9c9cb1cdd46d491ebf2858af0b75b786240600a50044aeca515adc2862ff0418a139992a22c8856ee67312d66dac287f7104744c23ad3a130404853dc62f0e834acb025cbcce69430f5a8306910a04ec2295b8c74fa96e63e5c1a316c828702b35fa734e70392697ad3cf6b737b5d009d23bf8f871d83d1a5ce5e742b449411497863e3e793a96e2c21702c3b49d4225a78156b71a74188e5949cc896421bf10a5666f80cf5af95e6efcb7b451ffb2eeae6772b36f6bdcaa62e0ae1fd36ad008388c9d3cf604d4fe8f3cd0243c10e7c5cf176ea1378d8ea5f8c108a33c66b09e89d4bfce54554c80930d866f29762aff4725435e4f7819ad2db48f8c1ac0ed1506fa86169ac218f64132f2000a54c411ccfe187e6a4fe2a2fc29565f3effbc2cd6e3735ce611ec82c32d9a4c6ecabebaecf42eb262318085bd12d0684c9c849f8e5f1433a65d123ddb709431a4a93e41a309c16b56b7136d70cb51fd1d4ed18cef7a86cae2594dff6802e44a948fe4826cff3bc19ad50ef1ccb875b25f5c4e7a4b4dee1a8bbacf0dbc13e673d98debd8f8323032cbb8a35e504837c646ac4ef6ad8d7585d4d9db1c9490d1e032a5296a7a29d2c1fc25b76226dc7ab63798df57118340be5c2def7c28f64de4b4848ed8fedc740f42a2873032f2657622a87d48505c442faaa1f65a1430b12a606ad4cfe5f4bfaaa4c6b0816c11893b639bb187a04cfacc1495fb37bc81662adf2a060d932f0684ead4340432075198d0526a9b1cbd522dab4d6b6b8ef550cfc9a52deb188054e9c1f4f5c0d466839b1bf4521d469d9b11b20aad04d569f807bae706366538effe9723493c70964f5f2194c3f1708fc5cd9554ca303c196ffa4648c654559dfe1870baa521ce954931b7b45fc34d8a3a7894a30e9b4cbc1177de5d19f9172606537300041ba71526830524b54abccb1e1e59cf5e2c0de73db9e6d7b93a7ddf93c879177d56c3c37594f0578bd4098e74bf90e8cf0503702baa0f6725d3a19476902aa69161111d80284f7db1a43320094093dfa84437a2c3ffe1e9993195b552b3ebb48edd08d18d5c5b974205f8fcf3fa20d40bd5400f06b0dc014c915b6a79d5ae421fa551145dcc8a701edbac320b8768d45732b2556123a6f9a0346afa344050060c43b99faf320d69130d3b0406e41ee798774b6da0ecbb3947be21553c9ba7f3421d901065e534b91ffaf65ee1179de28e80b847cc24c522a2d34db674de7ba5752d267dfc9eb7155e2888ea51fef8353a15b46c38cf11290b196ecacf42dd8fa687ae5a6368d200534a5f93db51608d0fe7bfe94809c49856e8d0e007ef744ccfcba9ab62779814a595bee78262bfd84560a84e1e93b02d724fe3cad643215c46a1db617a98d0d582ae1343d043e92e7f3114179c1b40a10f2d45870b734de192122157531b0f4ffb44299246350e760d8aea124681c9e5a267e8c28f70f241e5555e0b355e1876191fd50a3023b545790348ea17f7bfc6a3ba9cc591276f237244e42ff0853fa54bdf3e51068e6477aae0202803acd9d8d319a1dfc1862a8bd09c872cb26fe60607677755092e6d24fc7bf03db768b4c43a3617df568980b622ac375e681c1e194304434396b0c50cc793d0d80d530c183a5d08122b904ecffb42ad1d5887efc7c0ece97e851dffaa7ca8d8055aec9190421656fdd2464e9fd6619414cccf93c892e0e8101061ce1a58c0a09426366e6005ffb7722b5f4f750cd16f0d72bb4f0d15102e4ade97ecfd9ce7788521d474f0a94e1a1b82f543e4e3d425450a1db9daa7404edbc7d8f2e4ced1439b1de37c23844dd28c1cf7c7145f5c82e6d98a15a037d724443a375351c1f3d47c73fd7d35950227f369a671c68e270eed820221b4955604b9bac760cd052499d5371928b44646aa8d72405c29b8f5d1afd2f118ee41cf2e4d78864d19f80298ee0deed0c5e2206a126a96d71d163ec7a89192c776822ffdc49ecff56cfdfedc160a99fe6aaaeb1716bd303928ddb9405cabfdce38010657a3958c9e66d12f6630dbb57c7250f0d2588a1b734f06a61c7543b8d46a3d89527948167785975f9e9b22f89571dd4526fab3f19bdfa3f5578594f649fb81de10d3963ceda0216abe865917ab9a13fa44410db2db1356e4ac27d318fb783140199f3cf2c820b4f053313b730d094fa141f93150cb70fa96d050397c6c278233d8139f89b00333752a90cce05eaa67f8f71302239a4a941da942e9435c562058ea30b4b657b756f141e085190ea7d540c9657e386cf1caed24fbe3b81555282da838bb31b19f76f5def5a97d9ef7f2b4cccede67ffd041a73683148501f6a781e1d7d8a72aaaf1f14450e1c6d22091f4ff01056c5badd9a14c8dec3051b44995ad499d1a23a169a2b1c81285749db6b8fce5a1f627882bbd10ffbe238e9751039d4f3cfea5a00feadef06608fca22bf19936118ef3505183b654d5e009b1f2ef77dbe315e4291b0ce0ac70cfc4de08c7198b80033afc5e2217cefa15a01c3e35e9e635e6b002a84dd585e00704f5f6d148e509d7797f736084c5273f673e3cb9d3c13287aeae3827b167352abc628e52f11bfc247fd3bc9e7120eb97cfa1183105c3c617eec3c348ae585917db3c72990a172ecc2b63908519e21f720ac0ca0d6c114c46821054d1e14d2df0c1f9fd270e768e74fd1b5fc838f78e04df83efacef092c926e287b0c511ac474ad086a4d2ae665ccf0db77646caf68783113de36e78443e77124ad7346a80ee4769eddcb7ca10833cec0c449cbadb0e3d1381b4754a61c1ed60e763a9d5ae10fa30aa2452644c4d9154217be52cbf6fba81b6c24a06316d53f2f3c3aa21403cd4f16d1bc5ea2b79c6710c68358b987b89609f78fedc86b60cbd68817ddc7d3010754bdc7ede9967750a653a64e989a4d4ed09ca10434cd24e6aaf8b3da961a3b32d25e65bb0615723cc25eb6ebbc2fd01ec373c021ae9d484b69f44ffdaf1c687edd3100a42e46accbc75bd1a46cc5b09a37fca081529fce5fb143f5e4d81610f978c978a81148f1c03ebd15d8165fbd321c16a48e069387e6bd05fe411fe1848e1eec19834a85e9e9870447e2b079840aa546b4a3590b5ad0e1c665afe2ca61407a351d4073ccbef35dd235f2104a9df9cfea5a5e23ed1ccb76bd9fddeae49327accb2775ce7d40a018b3256585bfea92777c66677325835db60a0e12687a34ccd111c2cf2664d5846a6aa41e25f2a54a133ab981396ab363a219d60b52e034f8e3524118a32d997eceaad78267637fa71efa208d1869a51941676aa476c286c2ccd578b813d634d5dc48bd9cda2e6ead3f9a4ee453aaf7f38e6946d69f05bdb25403ec08adc1188f28bb46511aad1bcdda92cf5a019ed76852dd8e5c891e30c98cb9a907412be076f9f90d4670cb9adab7df49c28650d2399fd12daf957a6f6d940aad967e485212330c4355f4572fb793b9df7a8f5f551976a6d3bd69e915730a7f626dec04cadbc055649033b06ee3675c8e100ee42669ee1c3161527f471e78f9ce59fc60b1ef59bf27a65b296730130404c1e6e150c9330f29a11d49546a65d1c147b7808cd238ae549e7fc0fe77b4f6101f4e5b60526bbefe02461631062dc41ff584d51bf5caf030429d8a81cf729e1ebc88658fb0ddf2fb36fe8773fd8fdcb116b86f2ddc91ee3bffed47bf2ce7529c6c8ea8206e9325973581cc6c4d7d16e758ee8193897679a7ca4aa0b944abe2ead0c271d365a396dc54c3c72a812d3eb32d6c7e2deac172e169a58b16de051f77feab32a3dccf57bce855255b997d7c65f5b65d60b5b9894e1ab5a16244f3a7c1bc909040f7b66b35567a43fc6c29f13bf8da47c3b0820d320593a88de5f277b08040f36b4e5afb8836e2d13dd452f6e7dc7dfcefb7e4b65cdf2bebfb704ef182439fa06439412e92720065744a585a469b19864854fb8cb6d42772f40267483e33c52def23bddce97bac945a3784b5bde6550ed8802836743b45f59b040f67dc023558d9b8029b7bd90c736f6e7df474933d5a0c11037a18511e99abc4ecb3300060b97ce46181c4a88532d15884fa4ee68a9aa61b4bb36bffd55f7617f2036d4210b1a037e89420d71114e66e06cb3f7f1364a888794f96f8bfcb5c70286b8629ceadf566b8ade9e34b5de6c12c23aaae428194ec10b3510d4dc7d0fb060a296b4d90c5dec9e136c2b42ce0e163ec81eb8ad8cf1890f9019d6b92cfde67c252eaa17a58eb46887c8b837f817ac269cfa13be20dcef9c08b72cd661a6cefbfed85e9ee468b75a5118068e4e266228034e83dee1207e221a779fb92b9c24f086770e589c1b882cbb9f536cf476301620f7ead8fd7dd7e83b6e4336341204bb46e10c8aec6182c0539828089e600253540e11861f6768914696b90c0815fe29b4b117522da4802d6c22df2632469e32409a4388afa6c03d534dcf79a80f1cff6543f7a4451be1b403e36693e8d393d03e6ca7ad9d8f5b7219bdaf1b7925367462ed65bcf8121515ca6ddc0f2cf79709b66ccb2973e5abd1d4417e3d587400ba5ab9670c8964d71529133f5f6a450e14169b1a96eb2844ad32cdc779b67bd29dd9874f21a8b7d1a1605153095effad8b17bdb025fafb70133b825810d88a9ea2cf685deac1af9fd0197656caa134fe6c3ecd83592a159f84f841404141cb8026d52d754f37ba72a9d8d21d98275c9a6872ad6618b2e080c2fe564d9f7055bbb9386118425cfd7abd4aab7bf31cbcb311ff2b6ea3ead72191a4338d9811a416f1bdcf4b7dd566ece9df7b6566a9a066b7ab30da17bd0700417f436b86fe61c1daee3f915dd0498cae5d71d2930ab029b0ed376b97e7b0876e057635894c1146e7884e03bcb4d552be44dc3ac4b9bdba77a17eaf39073b3f72e82aacb3429862cc4641ad1784b6e2f22615982cf804e9c496a56ab15ba61092ec123c7ce0345f6b0e2e1f24095a3a0479dffe8b5593b25b0b5a38fa73d7861b08dfa3547d0c4b8c6eb876d470b970c247c5339d8355f60afb220a7168834e748dae153d9decda88c1fbf9ec6b86f8beec65101fdad886594f2510c858ce39b784da9bd380a38525a7dd7f5d26025bc4af6c78425e10e9eaea486d40d53171cf5330f734d7ff55fda7d7b1b07b1b330e0280fc2db4690393d5e2cb940f493c763beb04365c5ad388f8eccbc4f5338e907d2f32a61ae39c4643b922f20d9884c7dcd82f668c4b1200e8c8060a6b27f8396f8777b825a25c893b1b6f59153214141eedd9a26736ef77d2e6f61a5ac1013b9409365d5079d0dd0f9caf1cde34d82863d9a4756edd2c9998517e945432f5b973ace6daec8af09fa23b34f54cd5bb75e4854291c2f61b571f17a088d6a392a520856a7d545ad815fcc8292299ea1fc3d2180c71abe7ae874dbd5f043b2bca2f8a0264987504be49a4c3d4820670facb8d688c5b7dded465c817b568b1d38d36b3bd8933b8c54f640ac0c20b462ecc880a1f5d793ed08ccd1e72949db1a390cbb3ef1e9703313756da8533848dc778462ab96c8325eb5236894c85a577f51998a7b8a7f080bd67818faaa59d39ee90d7b074eda53d3bcb87b8b2ca5a4c855015f75d82261629102f5e64c44700ff479e9f487d6715acd98951adcf36e9b732746814bdc7a36ddb2d3bb0a519bc1655016b649b3bece6b2753eb573ce11ecd9a1815eec6ceae403512d87f1dd7cff56cd31229986c889fd807a1a3f7784a0c526dc271efcf44316991712e6a8223436c159e65681127b1f646c33343ea2e564919e1a9d4262b19be775001190e332e1f84f3b6d5f3e18b918a7c1f91ec8ed97719edfcea053b7ebc02c0c17a15791c63eb5755bce45bf4493ad7261bf5b4ffc671d062be05fb4328507a371c78d504041085c0682f24e1b39550e8cfaa7304967d21413a12a94eeb9d98692a9b24838fbaf29c60b4db26f2952ca577b72564e59a57e1d6e6adf3c9feb977af19b8e39effaf87e74c3ee92a27ec7226bc99ee28bff046b24716a9e5846884f950b9839e170e6f216a4491365d69d6f9ab0aeb83fafea57cfaae0ac32fac63f0d6a8a492dcef2b81d7cb9f9ff8361cdedbbae4398185c432c158ecc4aaec1d938414c891d7db8814ebd4e83a970e1c48b4c438f02653534996cda830c0ee1a3eab8c81fcb5986bfddd56612752b42a61f1600d503a0897fb347431ad639a7481748b5feb795d24034dc5099ea2de65817cdb3960a8a927d82890ca4d4618b728f6ff37ccaebb92370c55c3e95c559663b1cbca9468f1d14ffbfe68c117188b477e4ede69a8c3507e2112fc7ac7fb069ebccffc8ccc0742b7f18402711397eb2be7aa2d27ed69113052ae51a6cbb06fcbcd21c0a74a741778d898b6a4a44901f74701b9ecd2d050b9846c83c89efa42479852da1413f34ac457c26543231fa9070f3288e18487287a72e809263823dc930f338fd8cd0e03573e9c9b86fa41c6980036c3c3e3af1a74d7993faaa2eac60015ec65a303dbfafa542d3d90302053a9a0429aede0b30b98fb1a0547a6c0517e737bb2d8794c7864bce1dbb9c1216690ed1415d394ad56ed5209eaad42981e5f14bc4effced30c1cd376b8be51fab2117e5ce789ecad8d77b5eb0c8fe9180afbf0f06b3bd172b0527f1ba5dfe5726d6678763085d71552047de6bf13edb3e20eb63166bb20d8492c6566b1783ea5869d36e4b602fb01174d1a4c4a34998f03e5b0383a9104a766bf2e1304cb4f47623eff043c20524d56f0c3408563f50031b3175acfb88dd4e75510f1814232d2e13db531185fb2543a91e60c8dac8f6f0c0f64a7f3698fabc6837a6445c23ebbf68c9745c612449f43caa4fe85a9482138815d0f037d1227e42551ba0f0c46a16a1a8e38fbc7c6ac38386878c4bf8e9294b9bf1659a2bb5a78da30dfdee9af2ae5c9d2cfa9cadc4da247f91b4de42c385b36c4a7aa62446f3c4f4da00b69acc70495463c56ef95c00bbbbe792eb325f36fe256fba2c0db5f02c90197f120ceb8c4ba3d73caa8e8e288aa6aee9e17f1a881df4555864dd525e91752014f42b75b9bf453b2d871c0090c434d060bdfee22452cff66f32b7809f1899b8dd5e9e4bafffaad4763408d5c577486aa791e77658ba3b077f3ab8ee947109442f4ab0d7703dba1e2b1c2bbf684771081fa6dbbc33e10b8fdda83dd074cb09dfc26a04dfb62c774156d5de01cbd9f26469cdfd867b582e671c018af909b2042543124df20490c3882d5721720c7f01ef45d9c9369f237dd79f6399708dc19a29f2a7ddb95de6e5af6c91666a8d6c816a74388a0dcf26b5e12a851ce6ef18439e76188eb99f0c22a20a921770491c9c21c6314517e84cac12f4bb8ba7a1a1dedb549c7983a347bdcb37a371afad7ab95202d80ef0a9d7a557e1f174d531b68c2ab1b27bc2e2e84d32a5fbed6a4e5634820833daba2fe57858ab78deefcc7246e28e1cdbafa4c31d18f2f40b2273de2606e21f20b56a0638033fc711ddbab87f889f244cfd7d72a6f1ea525041fca91d913d98e8f41615b94980a8c49c69081236c0585a984d0950b3eb5efb8f3187ce9963b9ab4b3c29dd5fad7e2cafc154d2e1be1193c0e6a8236ada852a10ab2167fd37d65706f8cc6ee7bbf86ffaf3e850446ff9cbff258d5d508a16e3f514bb35ab835373f2b623310965652e178c3acbacb85b71beaf11dadd96ce1eb24c9ec4f897077b73333fecdb18954556b43d5755abf690411fb15d9261b6303a74f9708d83bd68823736164ef8366085dc365fcd4daf121fc847af3cb62521fc2a043ae76c137f3c385b53c207e89bd9460dccc88b63bcc739479876672ee77c2a2ddc5f612ac53ddc139617adbeb5af1b7c5c611b012b5f81d990f34438806fa499617d051e6baff0ba5faba38625ddb49771db0959706d0d7ff40be5a9639209e73d992519e163157ce34a3936d077ac75cdf2b9f450f73f2bb2a3fa301ca5320a99e778b8e30c905fbfed786f2716a711487ddda169022d4b335e0e59de8e9ca62cb41769804aba5d45636823b00fe9c4d65ab855a548a50ea6910a281ab0ae0cd3de756e9b6d623c6c6b3aa34079a957ca65a28b7dcf02a443923a2e08161583d3099b286fa6fbe4ad665abf7f4d9b877cffae25b4b9e4452f8a2a0f958dea60eba93192cb0250ee9fd4da8c96d37a4acce82babd3ea1579aa848a39493ea739237bb422c6d039a568ca40d6022563a5ac6f7f152f540bfc7bc6c58e0fca6ca57e3ea78407ebad3157ea0c216fb63505b03443e32bcddbb5c03a3965972d5d30d35f7f1ab9cf5908ded0bef9bda9110ea39d2b6e9a9bf8e124c4aa2e11100466987cef0a198f776c0be72cf0bab5524e12ce254661e408bce760b87289886ff2e99f1b983905be80f5d19d8b91f89362461afc525f3528f5b6cc9bbdb78d390456efbdb0de8d9851301e96f3c64fd4d5098c92b4df54a5faf476047dd316d79b1daba30a41d8d300edac5c04ef1b098116f012b4df2976861b635b8836eb05e9d55b4dd63b9296f487880fcc95d2d4b0d8442674f7a812bd6e1221a074ddd5aefe7fb1142c0901a72c139ac52dd62e2a33df249bc284a18831f76a6aa04c3642857fdddfb55025d6910626f7e3e2ed20d71202e31b87ba1b7c213ba03216816c72fd79f2a14c985d4f57e0b1622eeca12c9834971d701a935a80deba7abf2d19b944f64b5012531443fd5975bcc633b62a8f61022022e66e02be58f3f7c381d544404da1e2986b442922f5e369aa29e6fe03a6eaaf02423c2887c4d282b085cb8045c0e30c67ecc02bc12950d05d3c9f225ca54a78ddbd2c098e6f738250153a3a70c19fbe2e14f1b3820a42a985c69c4da6d1d7aaf207e89caa498b4ba75187250ab2fea4d526fc10a069805362d77aab1204ed584b3b502f7f57be73d909e3e0fc86772440f258f12f7fa3f45ffb984b9abe4b0b11cca30fa2c358061e2672d77a62d16e63a8509617ac0b15e3243d9b199858d4b8c452fc7d2c8e56e620ef0998016a31ebc09b5e20d9ac284534f87384430cff156a68c062eab3fbe1a91fff750727d09c50ef24c3e0c7e3ac5c1ad33df98e254afc8045a5f9b350a28989b323f95cf507a6a6fd6cda36d6cb208622bff2faad09eeaeb037b5e9e3eeb530742a5577f42b0b4f2059d60fe9bad5cde69dc66cd6a369fc2c9bec6e423436badf5ace0003418ed0e36ec65bbf0d54a532aadedc240c4a17fd39639d66781702d76311a595c188b901732c53db54d1d010358415ee0184570ba37d7263500878b2da0884f174d22503aaeddfeb72008db81ed857c8d17867275034a598949e0f8518468c0a44163128d07fe060a362bb79c2d8acfd8514662b8f3920f6d3a0e29565b09a8d9baa14857c10039c4c2f819bb17c9fa85dfe01a2699d571607e2f1ef6d8af3adbbaf1deda72bf18cf7af898adb02932773b62cabf7aff61cfe58106dd390be401e13f7d7b7a44d28966c540ff6969ca1efad89078fa8870c0c9650f0d8120f1ccd8b1f8ebe4b06f1633c03f92126c3ad1622c49e8ec7681b78b228d2348fd40f67ff40dd2c35cae1e3f8be537882c4f16a8a56595a6361bedac644d006b2438c5ace48aeadf9ba7679c2e906d28ea6641a432ed777420001133a4fc362ae21461ab88c0f55c3bd3f00c1831a2d5bd2da93cba5d6cfcd3979664997cdddb0d475e5e6184e323824f5136782a198e9585c9f5820fb72518d5c17beed750aaa7f9af054124a28992d4ec8ca94b4ee6775b44a25126bbcafca1e95dcbf1ab619ddf5c197af4cc3dac1ce9e0425839159a6a5b45a392e71328486152eb88d102ce71328d7dcf7cc32c7a40d4d329f64407837056dfd789540c885a4dbe0bb963a9873f9dda3ab1b1e0c7a447ae4e7a46a0c9fb7d4642d1358b6d408b9c6f4ea5e5c54d58ed3c7e60db30564e5b56449fd7e28a38e4a8a185426ce959392748a6b21490d0c0918e4983c33c074fee7467a9df5f7533b86389eb4a152cc44b44d43cfca3cc7744c4e0d1e637cded561e04184761c5459d2b2dcfa186f3be7b15c3c4862ca8908be6ea66bba96ea7805b16fb190ac35d82b50ff59646b1d9fd9626bb424ba23bd29c5f7a441ea1de7407809bc511e31061807f834bf8428bbe55e059a596ad96b56fa3a3654310aad18c59c426a4940132feca270aba77a7f653e9e4a21b73fb7d7d0c15a15675808f1d2079422df4a808a944f3f467523db72536e60d8a97cacb6070db6e96fe9fcf53c9f5430bc56d0d82197ef91317c4c12affdb6ef788ba1412601c0ac51606021df964203722254e9c2d9d03869ffac2421b76605697b2107c3cd962b81fb164381acb8398d14e455a913863de290448127cb7ac52ac2300e41a8224e9974c03dc6c33f2adbed821b6d081976d2a5ac9e69a33be78e7d6b1ee917446f0b00e35f1562c6a0987436c46ff896ca1eb844ded473a5b1d88ffcdd49e4e5cfd60a04b6968bc472634f55bb13cfa75b0586490a0ec84314ca4aa32c44f84bcd413d2c661bb481620f055bbd8c9ec4fb33fa92dc8ee42d95db8e338ad0277c374d245a2ff87eae4bfa5e5b2e2f18770693df9aa4c04c009949148a9879ad24915bd3401224fe6103a2cedd86fe23c88d4e9371a0c9d31d384602fa6f02e12f02649598febb58c0484fcdc456f6fde287f3d186b82f60e9ec8b533f9783086a4b78478d2553a1fa72c32628933fdaaec0b2c4c3bcd49aa8b5f5c7546846969980e7d3b5d2c9e16c68326da3d93ff60f2d6ada49b00559b792f2d91d3c37d73a14042a16449bce480ddbba8d57fe8ee095e4940eb6ec5c83820d347b9a6e64cd2661b840030df188ec977e5ba3724cc75f194396baeac33ecf6d5ccce06aef27eaf6a92ec3f51cc67000d47880c6381afc984c4a3e79a5706e5951f32ffbdfe73f972a4f56ffae47dedac735702a2dad862e12d00f75e025fc9df68e1218d4992d7f959f6d26b8db3c7e89e86a1bfe74d64cf294ead9c72991eb0a3844b07f994e0e2ea1a7422b77005f26b0da05489198d7705daa69be6abd605048cc00cd39b7e7306559cd93edac0d7bdab928a6fc0727c8ec9357a1b2ff4039b06764005e2861889726c61929f20bc304f05009f9850162eba046ad9cab0f2cc9196f8cf20b4402fb2295fc9ac201a1c775d6c2a82292d3f72aa5f104d8190fec4af4ab8d27022c53a11e2f16fdd15ca287a187d60425678d7cfb0c227a875f6272289e0e5af8adb8aa4b135cf8ffdc5e723384817d9b802a1488e7f5a67a0dbfc3680a4b3359c370dcabc7a04ef2cf6ff61b8628949f09fb94e7c38ad90e076d51b7dd7d7bcec28f86932ed62c992c32e549634325c8e0b811b962e64e40ce4f0a15c82467ad61941655abc617bdbe9d725da319f4f4e10a2d0943e178b897fea9edc0af91803d049e81862d5e909a1c956d35d264009aa7108431fc9be977188537061024966a53514ba649ed6c139e0befcda314367f53378fb98343d342b0ab117c785ef89d4fead4a603fa94a00e901fe4cbefc6aad5fb01f9d0427566e61490d7b5e6f7c196c45a6babf5759c03b7cd325bbf0dec32d704f9bf6c3c67577e79583cad8593e31e34c161a78b38fae5a6c23477387e409a41b69ef9878af306ef1245b734097c38645b347041afe3aaa39dd5450a385b73288e0d69edaeda1e6cbd1499b909550f7c70f0637a1250f792f13a44a9c211b5ef773a2229620445c0617fa954c7b0fad8b7aa03e38449c45e4055bbb21370f32d075f55f107a31df932e891824e0f0a51d945eb53ad539e3dff01b44eac2d47bf24a2c979462de738e3c8206c9ddf9d37cb9f2a2c2b873fad9086e15cdb65bdd4ac6ec229323db1de2fa6388b96397727e50e87e7460497fa044fddbcefd0fcd90572fc5866c00dfd614efe70f3cca4eeaf91bb3fc913ae8c18266af38235044ccb368bdc2729603139159bd1df5e2e7c323f8d60c28f2a44ed36f5a7f7405638679d9e90313ba8713cfc12127f13818f9208de17ce200611549b1f05bccf94f22864d8fc0e464f9d83ad0c7f2435a501e47832b47b14d4834fc29b380e8870ffdc19aa78d25193973b361ef93b87de69d3e5a08198efeb0be067a298db5111afb2bf71b38b2b45d1b35e08fc18fcb238cfa0ad80d6f7830b439e4e379889a604db612faaa7a270d70b3dccb3a8ccbba3bcd9ba7c2c83a8a88b64518b9efa71d990ea933e8d69c1093df6191b9a94e4d1801b5d8e2c1f1669fbcde888be298fe514a6cf55ab6d2f405a499d233a897d37f3aeb7cd1eca274ea620cd037358355ae24a1eb18f689b0544a5b1339c088c758c7853b9519cd525942ba268beec36e1fda4573fd89955f8df9d94c5cd0ded5d51e08c0464343ce962dade6c9d90c08188e9ea51caa8655919b4ae074b397171c711af232abc6bfb818712460eb565b63a0a842c4d1065a7757f8290ce3f4b989dce2d453ea2885cf5362a77c8fe2d46f180658cadece06b63f84218657588598ded2a980dcbf134c933f0171f30e9a618e4b5873d334d4224b0988090ab86ff1dff06119c7314d905d20c8efaacf7c265ba08fb3e3b89afccbd4ea846f60ab838fbf76df7556da4cc87876c16945ea263a4b133804574ae7d67c77c2e6f27b4feb10730566d3cf707f017ec6adadc0cc29bdd735785390c8db7e4d6f79df49ebf2ab0e6b20695dfb000e7538dcdd6e2137c98e1373bd0b6f5c15d3ef9e2601a7a41687fd460879c2286bd473ff81fee41ffa6e05aa7727da81dd0b72744775983bdee14e462fce7b0a69f7622a6cf5338ddff46e68448fb6de554a405a1f5819204e9a033674f158110eaec0aa63ba3cf2422a04a499cdaa212b6cbc0ab52d58679864bd70ecd87983d2a703eb7ab9caf14cfed49114cf42ad4c6778b109db3dadd6f58cf5ab773516cdef7ef0cf4d5cdc2ecf3e42581f4ee0b3374eff375e5901d90a85d36a14d97ed9a9142d96f5aa2a0a7a456fa9087fb293a3c3ded004816094218d251089280fa9b73d44dc03d176acf11f9069f35146270d706f0ab17228fcb2915d1366571eb226f76c8e299dd1641a5100eec4d28c8bff857ceaee27bd15a7d9cc79184861e7ef5473254ce88bc8c971eb113e08a26f760018d24b23914196cb623db85fd2452e427032a6199f60b1ae31a2c0ade755a07e58e403cfd9af79d2e59651e2ab53eab6aa905eb0308e83c74ca1d83560033df90b83aacb35f8b431fc004c04e4d64719e06d250fd42099d1562ce89a7744335e1b410c66bfc547de277ff1cf77dab233ab0819d55ab83ea7b68f821cf664beb9d74f76e939bffdbceb5169347027a4eff38905f03293829ad96be303d78c5183ef62bed2269a4227dead10fa488211bcadef93285f692d3644ba119cc433e33043c6f006b01d38ff522a83d8e95911447c13c5fb42bb9b83c433b2a495a0732ec85176f28336a8c5b88393320e0d827cf460c7b49e9ffba8009e69af06d401fb2dd30114b9fee9cee2650f6d09e7835540ec9a89f773609cc8cd55158354d5c11ada386c4e2aff206c8d5dd4d4f932c7cda9a4cfbebd2646d0c427deed9810b32265cc0a8a40c1b007d53cf07a62208d8ed057a6a4e97f3973287a95c7efbed60b35ad41f8aa765ba9e5ed6547ad9fd88e5d8f12a49ea0f56ddcd7123d75fc9fd9bba7b01c48afaf1805f8087360dd28c641bb1b775574d41fee64fa1bedce8ee6694a1b905b4a91c7da29471112b6e1f1710ce0a76736871350669e1fed6601e84378b112dbab21f0816a735906bb06b4d753659af0353550376ba294bd1b7a2ce09f5c3f7a792b254ee1665106364372ce02ee01d13634c2f396fb4aa1a3c05b1af80accf6dc44ff71bb4f2b98a906f5b68ea333ab03d94e1f27e3bcc09d5163202b44b235dbf5140af94645a865b68e209b30863c09b4ec04561db0fb467df580c736c44c23fc5aa5d8f7f7327fff951f26ad25b78c220fb3f9dad2e846cc4c7734c95635334ea5035ece2e08a62bb9fab5102039dffec3551e76d01a601b1e8db9ccbbf42cdeebd4519cb6c203fa267e87496a3d1b0d6a03d038258059c4ae7746030075371fe76cd001af0eb296a9aa00097f65771542bc74208e00ead838c59d02907365bd7fedcefcab3108f0138abf78402b8021339731c9fb99494e812bd3d605b262a1e12911206fd04b15ff359ea33a97958409f100a0550a28f3029104403a90c4dc3d5a585259df54d7021f24fada83715132dfcf198e657d341d0bc345298b0cf904e3c97805258c1a49dca51f03dbf24deeb1405afcc6af18489ddeeea5a14540eb80a7b9cfe5d8c6f4202a6b724f686a364a19d706702fcf4b3a29b5ddc68090cabab900f2e2160c39cfe4c16ea1f92000a2ffcf66705d75b90cdd44f0553bf72c2f472fd75aa3ce58382a5c6a930fadad23ee95bdc70d5bce262728ade2ffa93853139eebffa0d68b3dc55e416acb6acf4decaabdd5870438e771107c15a5adc520ec10a34f46928f5bc0eaffe568b06224bfa8a9314c6ac250a0fb6e7615e1f38725313e724a7ce415fb81eeaefaced8e33ccc2076faf6b0a69028d9fe48cbdc25461f33030105858cf7b86c9612f9355f1218f14d0b09f65e2b44e920310ce20ccf1595bc761a8dbbeb411d653dd44fae3f9a7f3c0a25afcd940e9514763f471039a269b99a111754c400fb3ebace5c6a9baa8d4d755c6b391b437cd64cae6ab52f3166ee3acd57874343a1babc893bbcd2209088e12db40d28ce34189d6d6f75f3a44bb1c2ef13451a1688f2d4d074c7a28932455fc52036637adbf4ea48f4db7b60404ee3b4b15cc5c7da731162f0c05b28c0e7160e511075e194ea18aece9b1ca11e95fec9a09be3e8d8daa273f60f22dd69f5f1cbabe41a7ac198a79b14598a85f438d472ad6dd715c357e62c0900f103256cc0b0ce380810a0c10144f7f1483bf56c652c05d3f3f82116e8866bcc2c5772697a1bba09c5812d0ef3658365dff82bf6e01214d141f7a4f58790edc68fe90a8fce579ad59fc71c807db06b7a0bc4ae1f3511302c743b9a6e083360109641c46839400fda377b91c7b0d617fb80471ae6db697304aaa29419d5a3f94a9ffccddf702847c17f05e3bb67c35b237ad8cc994202c3f354c1d059dc65d5729f1a0a49181e2f5108a3824b004fa67a0b8d1681e727cf88a939328f747175c78a1687ba8bc4a5806a06c9379b3568be8958bef70adef59fa5820ab8a4ed0c56732677a60e77cb376c0112590eca9ff595e1f6c3e2c9252a9ab7f2f0d2b28ca56db1aea4f831d41a1f1329fab7f539f141d3adde745d4414ecd3472bf447cdfa488335a639b0f2aefdd0b3e54af7ed0b75d671fcfeac18ac0e8feb541cb92d3bfcfa1321caa82c91b7ac453243106877403801bf8f451d777a2499a36a400773128d0ae881acf1e457965232d80c9190eb19b20a43eeec5834b2e808e3bbedb56861fb851c06e3b0c3b013654a5619ff53a062880be558c3da9c2f50b9ed405a1b981f55c920e8b0223fd5e381c4760496181a6b03fcadfc66ed0d033b1fcf26f973e780c91c5813001ac4b7c147a91bb4cb8cc045a2f4736a08154a92c75fab83c65f4711b7ad2205a67190d760e75f86f61a33919ef7080de7a83df1f8d5f365f93f6e99a675ea00d73d4132232be730b4facf203672f1c5cb9fd3dd28987a9748eac6fe9878b9d03773086d72f74efd6e375413a2d06030dc9a0e8c2a7752ff99442393a264ee859cc2b5398e51512df2ea64382bc80b127e09f62cba4fa61e54f31e20ce967761ad257daf91489a0ad2440f8760e869e3e2fdad9839e53a35456daa008213d8406b4b78d82f060b695c06caacefb4c15eec33e30447aa054e970d839596b3ce599c264f79d6b5babb7d9cffed501e26441bd46e6403f1825a5fba4a8828e19247400311ed65bd3d9b89be0288ed8ce51d65098f1852fd837df324054ead6cd77e1c5b66cdf59c958ec7a798004d060e67b99350da508e85b83370f38809b73bb4acb08e7f837c5f4b51ac35b2bb53eb62df1b02aee48e7bdf3612873744afbe56d00beb553812b4378e200c03896bcc1d09688d7d0b96534f47bba6181507d0c38e441189e8aaffecb958d0475feca8ab7e62598e7ba09d42a9eef807dd9817b5f2140154e21f6248593cc7d927d18e67a4bd990689bd67e463cddfe6f1b8b8601f5f69b20ba9d066535d6f69a6993a6ca6a5c93c4fd5b6edb7c00a3175781be47138bab78e082db6cfb7a1e93f4555622b834a35cfd0456a32b08e22ac7c0cc10405445a0e4b4917adae27606bc43083e7956829bc41a4f00355bab73f63da79c1820ed98b3cd6bfc59c46b2b9c81fb55d39ada09aa681286c46af4133b1990cd8dff04ad8873f63be7b665dc4b05c3269ad67e3578ce6dc17886125d30fd687a9c7f0ec0fd0130229cbeedc52f7f6ea370a136cd0acb953a08571ffffbfd7d9ae17228a87361a59366087eecafe73e55525ab850ae0ea1ad4529f8ee6cdab0e69e4cfadba44c0a5cc84fd04590266a47500e5ffbf25ff526d1cb391a253eebce1e5fc7393462f549627881dccea9d20cba0485fefe1cd63d310ad86495fabdb8127cfa16948903d3481cdf3d64efd98634ee1d47afe6e95b5869e4fe212499f0da2447b978714b3fbf1ee613a816bc28961d3d5e295689f0f27726b875c39a192c52448872092a0b2691fc68c90aed83115403a18005c11465ef35691a7e32d9d1eb44529bc4bd3ac82ac10e71c6bc24a5118b248584a267f818bd4c3c70c65ac632607d59d4de672ef59cdded8bafb6a5591b1ef640d2f11d49262a46f13628058d0cdf099b39f50821ad786ad750b348e3b55f4fb253a446e40e8c49076634b225e09bf7e24c2364294162f273765783bf6e9bbb27fcc0b6f015345d0644d8226b69d939d3bea4418c0945be5febdd1a3814719c60b7b3b77e2cfcc2dd060ccfb259b889ab32e2c4835df1f394bd7ec90340c0e462a22292b5cb46b8bbd5ee76bc0ca0e4ab027bbe45ee8ed04ee242697c1fa150ed820381fe17096d407fde9b94f59d9b67a75d529592047a4210b56afe78221cecae803877094eb062678aad1edbde6c45e74ddf6b783cd2e0fdef3280725e6a97c5a72265ecb9fa8783073c3ee546c134788348ea0b124f6daed864befb4f908304466d0a674fa063bf4e9cd8b0aabf6cc85ac67dcefd204cc623189befcb19aca26a6cb751f76a24146b56f7f14e5d95563dfeca391628d6af817782b84b9ec0e0f248bdf1d21620c16cb03d05c3a0d5c50e8411aea08e1a261645cec03112a49d82d7c03a550bc6df5008be98bd68cf7b46693d2e416240154cb1567913346a0e028c50ed1a77d32731a840bf63c29a52eccc89ab09c03484d664b1adf5f766575454d52773a3b76cb46fa39db683a7d73747e489d217062e4c3dc703c5c76c9e9c72bb5190b57facfdddfeba51cd5c2801ddb62ae09042c3bd04c6e890e695c4755f96474c9b2a491fb00419d5e0f9bfe278c35f6e4be4527aaf189d76bdceaf3820b485c30269af6fd22fd840a3d7f9ff1b25a2a217523f30914c7db95787b96f15731677b091569859022827a4202418964344e50cf0536f92a0b034de556c656c2c3bd1278f45a0bd504f610897a1130c49ce3c295181766f15eda7915688a066e82cf054fe61173ae67dc788cc535ab9d52ce299cf70eac1b8d70c69814df293f562880cab74098400f0a73f3496e0d225522fd58252b2725a2a59eadefe3d1d572f213f4afde81b188e50e64bbf1b4179cd85ad3ba403196242ee440f2c3da1bc3abf8a8e0f04de8913af0abfcb5fa91486404d6979ad60289680f3756995f973dac5b2e0c05078b0ea41c4e5265e804ede81a517bd6b7863eac687ddb1f1dc208b6a57921983d01dccbbdd1843c8b3dcb2c37c35e6547ec37e1d6492e90fe1cceebfb1690e08fc204607edc918ec09308a39a3f3878181e4427daca3d093afe64da569a975d0540d5e69bc4f46b75b59bdad1e5b438f117d6412f9281882ba2463bf6dcc23ce387e6aba1aeb8c2b5384c95e858f8751dd90bb0c1ddff167f525f25f1bcc52b885a5e1647ec67e7ee0dbcca0b0375a0d40c9b98826607053206d2102511ed766c21c0263316a3d576bf312fc5039f8f28c426de4f1b3c05a5932b326dd1343b64d13a49857b8c600d7f89c667c54f4be19c26ba06a2704f37d5ab25b8c07fa274ccc855b87d052f600e20491910832861e0b71c9349ca6355ba23b292fdda7b40a12ffd5369cede61987deeb6272b2ee4073740ba86f69afac9e88543014b424b8a85fba240a93d8c95b26d79a46143ffab5a83c13eaf0d6acc4259a9ceed4c2d463b8dd0ec4ea47cc794679d8fd0e3e5a746316c2ec97d06a03a22bfff46407a9d854618b6a4415cfbc7186e5a5d667fd3ce7bd6d2a16cca51374665e370f55a56da7ad6f3b5ccc20957dbf5a21667eca3cc6e63cf7426b62aa9334eb69871996a11a1bf21340887d808767f17c6a523ace2deb91074f53e2eaed821ec54a21b8bdabb5a1d00e53aa8f95db9d5296fd302a833d9981f8e1c5580b6aee79a7e95e9fc3c0bcc6dc9143699a974ceff47dbe1c79febb58167fa124d2cf12e4b15c1e745b0e5f814455f142d1cc558f0c91dfb56445756fd09c0b9e5508f787129c9f48188f1991c10efebafe62abf530d1f46b45ab4f774e951bc5289bdba8b5e24d75238ab02f412e35e4b89e8b2c27ac4de3fbd85470a32c5d0e19e8a79fd6dfeee567aab1a7028677eee7f0b9a40bb4b2a05c9b3d75d3a667b8c68163254dba4ed69c74412701b3464b159443bb18e236e27d8d5c896a80577f0dac78df5c00d84a3784fbae7004ba194da5e9e9ea8b0305a8ed515da4b1f83214a65bf6f0da2d2cb0f8af6382470812e2f7242824c6035c5c3dd800d0c561f909f67d0af8338012cbd73e4ca404891bb6eb14d8c3cd2bd8a47f81f6a1d142c2dc5e2354df2114eb9a90de0372f02a4d6d90f2ab6786d2ba83027ad657fb7471300b290e4cfcddd60d182b789938a17eed2e3bb674605054388560d8f5e0549ea848e4c7ba69cf4e034ed88520b69f010767208453ed2f0966fa09e409f95d385f37919d367bd4ebe8a6674cb7331583e0a26e7020854cbcff46cb2a45c368ee8662582c67fb2fbacb09a95016be9b2730a24cb026812846976f1084fcd77458d8ee6e0f93877578ecfebaf0c20f4e12b2d4ee6dd57d3380c493d162ae4cd2a6a5816fb2f45bca2bf68455ee3a1a961fc3354bb36e619078164d06cc30eac909f40545f93001a30f2f32bdc7d356783529a86b83553e50843ecc9681e9f3d4138064dfe3ca902a22c6bc03b2a67125c7b5d5c55db2ea3a4e9766a617c91061821822fa90034b75f4c4d9081c58fd4d577fdf1a07542cd6867edbffff7065f2dbbb94ec853c58f292f93db8556cea965c794e80eeeda4d53b3d0ed9132e817c551d0f205d5eba15d5ac9b169bcc2d1e4037eb411d46266af6c652d25abbea5b390c320472bacfeb28c6048db8cea15f9d1cfd3ae6951a3b4e451065eb62b2732d36abce8318c70275cf22cc04faae3c4921b593ed9ab124a3db1daae29d419e30b4d8042eedecb02b991ed57d90f8e5554d65e082fad69b77940a63ed92a76ae0bca82ba6617ccdcc5ab90041852bc509373ff58c680a90b4b216f068f84182cbfd3aa5021ab9d6292b333d535ed3feebe31ffa2ac5c344c8327c5c40cf9e0f5c2269bc88d74b36e47d33639d0374a363a6dda781291f7ac780666043aae0e9102faa930deaf7afc2ff98fa035cc08d94da500c82c66bf59e2c3928661d346efc67abbd85b7b3f3239143b17c6b65f320f71423bd130642997958ca5558a984cc66d4a8688ab8493dd31aef5531d376cd30182250adcb5a73d70fdd7e5d87cbc111b300a4fc92e0dd0b7be23594b40f99d6f48c5c5bb63b55cb086160e5b26c04f71e73b1b9480e0f757f1a21dfe8c2d8426232d1fdea8eb6f700a3326c5288ab80f60af080c60ba3878892d8b122046b5740fc10801d255481b461b92e2427179a54266906c6e5dd64d9d65eed0059723aeaf370807330f62c640d18767cc46fac76035c6d7fa622b591071b2c3c720911b064951f507b4b74b1b070dbe6e54cbbf73778e72c3687b84ba17c37967043d8e4fc722aacbff20dc0cda7b58932a57fe8ea095e210f5072fc6ca91840de6a2d033230f16f4867d346e3a4c1e4016473ef8fd07a32792d18bade9f8eb2983790a35a270cf1117b9c603ff6b02db78955a4872ff9edd4f0017ee633c758f1cc5c476ea0df5f3d9c94aa19f180199a1c78cf9c06d50f76fd1060841d4ca8572caf21bd8425fd7a4e02fba7fe2577d7e9b96cf6de7c3d4e3991e092393066cbc7ba1c220042ccc535a65ed42b116383359d610f9c230a28f155b083017682b7afc9730da887e2231f1790e9d3525785989613423da6baee916045562d56d11eaed9deec96bcc2aae33aeb1bf67c6b786cf2e13bd1a8fef73d5f27a67bf404259b805d31ab1290ba7c8edef7f6b4bc26515d38205d918a24816a70db1192ed0bc94972dba97b222c5cf863ff25d4018dbd79a3797c6f6790b6fca9b09577aff3674e94fa9361f93886ba0e24d7eb6e6155c0a97f95fbefba08efbc83e7e72edf7fb28fe7472fb0d6021ca92560ce7e7b7f764fb6f982e17a383f99c7e4b86dcb939636aa62c060c45db037a045f517286b5b91a080f587ceb7571924fa6109f3eca5bcbef14427884e05c33e521e138e92089883382f6a32516e5592792744f75de7ecdce48cc7e57aa930a28b7a1051ff2f869a634e39c93f1d9e08c8536ca97b4abf06b02d4cb66476d6ec87cc3f15a141c6c4ab3c60080777f9065dd1c07eec6d9c3fd61b406299acf80087451ecc6ffe4b31a923ffd31985c44649394ac609c2f6a7d1b664220c95ca83d00e0eba71de90a5456600fd90166dd7f8a2255661843bea580f351724b7a6458d9a2a2deba9797f2de4e36938f2f78193808a8bed3b833126b1c10048a62eb6940a38b519e8b04f9c8a4135bd0d5952eb0d3f19c2f9117f2335d872adebf6f8173aa1001878f0414b4b9008879823f924aa6eb98aca084d6647c25b70bc9db6f3f6302bf92f62dcc7be0ef36ec756d50b8e9abe268920807d8146688a32ec23f6e551f88d69aa160b93f9817f4c9800659bbbc4d768db321f16833c403be5bb370407283afc554b0ca4dfa4992b19b7e314c05c63b19086219711a1811c4644f9453ba1baaac2ebab4b8be356dbc6bb033c6d10fa04c498895043aaaedf90d80a2f978694e75ba2776c6ec3509fab5c704e50ae1c4ba69da5d3bf9c563bd123ced8fe368c91da5cd891ec55d21728a6094fc81e6d00edb153f6fa51a5e344ebc239e0de359cdbfb2f79f2339956364940e7b88dc530709c7f465bc09d97fb418d872757df5030a335423a80026fdeb54af082b6f72f497408797e409f02570d381a044fc87b450cb65c1176fa95ca7c34b0d2b67ce8ad6dab5a16f3acf7fb11893d3c4b7587a18c1d26df1ef371923203e2e7d395d4c7468d7a78e119f24662828cd7608ff25e7fee5ff548ae59335c2ce2ca95e3d883d586d65a7f0544d7323ed758a45ec0ff27bf74d9cde97b4e460172c9a291fc831ede012ddbd8dde717506cbca23abd884986d968d48447d9a1c4814e3f803d3bddc31735b4cd464e64ee0c6f9684208447e858c2e87bccd912c9f5b9eb2d3bc2043b39c32338b428c070b9f6540b02524366b68422486d2ce04d75f2d58037e04db159c38f59446809d5be7bc7ac8a901522b3bbca5a237fbfaa90826b4a5c150f0f2c9833ca81f49fe36383b1e9fda3a4b33e692479210a504f1b8fcdda12deccd473f99669b0c71aab9083e2aceafe400e9a5a648e78a70b777879617aa4bdffefd10742cbfb62aadde4712f90a54edf69700ae5d2c29a8044407783771a0800422ba5f94adf688c9e7d87311e93f16284eb560bb6192243ba2447155f39aebaa3c38ec3f28b12ada427b8eeab7c28ab5bfa7e0c239cd27d0a05ed8d961c83b8f98e9f2771d6a7a888bbdc5ea12a888f1f2268f36210ab5412717cf383c454c2b83bb46b3c0cdf299d3c591e5eee10612047da485ca558b8076b4811ceca2b962237ba756b7715ebcfc5e2f765a043abe11b4fa6fb1ef11a1ea879079fecd92368d3b5bd120761d9f61c5fbfc4528f41fab21789a7fad607dc2b107f10d54cc05b2f46be7400214e444496c7876913ce10ccf6debda46a3e02ffd7d73fc7a03278b96c100bef3c794c8c9438f5319ce615d287398b9b6ffa6322d3425b3291bfa5334168f8559c275ee61fe5947ba20027edb9195cfeb5524ff830b5e8bcf7233bf603d7fa946833a57bd9069ee407d9a109cd6673c39ab8e1ec33d37e48cc1d8d2f5b7126b54f1c30609af4e00645b763ecf063b28a8e4de7d551b259b46ebbf5dabd9d4728be747a5cb82a7df558ff588a74f46091521879228a87d72466c6b21d00d5463767e7ca9a5f0919cddd5af6bf47628b5311ec332ae52dff62a06d585ba151cd74dfd7a6e8a63fc4b4886b0e8fba22a2513a6494a2741439a2f3f83bab933a97dbb00cf9f3fa2ab860894862691f2fa6f04e9fb342e3f7846ef523d727b85c056c9d79805923bb04f21d07b5927163f7d43c1f363c149a5ba9ee0c467d4559d76e67459c5671ca30d35b3f7752a58af9b468f80f6f64dcfc43ddce5d0489461f909357a43dd6525101aceab57522ad8ab908d5914d9087d96d4da55b53fe1144b047cec243dff2922bf41e12be16d42bd91aab7bfbd57e746a89797db5abd4e4a6d911007dd096893714ea52b61878e6620ece37fbcb33e4c80e4cceb760dbc4ddc560f60df2ce34efe1ff92fb272c58446c56a2dbc257100d24964ade5283262fc5823524944f9e801ee694ed62d5c071e097b95a7403c6614879cb284eb2ad68933062bf12415ea7191d77dfd02fc6b45fb7b4be7714b05c1c2161520c0e1c205d7f3b62b846c15c1be8f9173c716dbbb4b6d2f55b7b489569cee338a809ac48dc0f54fcd1ecd73a06ec41b0b637b5dcea1f18b5b1d02a083a8057f282e93be73677749cf2dc68cb9ec31830c7373dfa10d3350640b1520e6b053045eb08fd2710871ccf243ca586b21a784fcdb87ed8e8e7caf4680b345c9745a69b3a46523b68f2cc4b9e13c35a7bdf5f89132f24e4eb23bb951f33529534dbb9e7a1a0940dc806ef82b2d5a382cb3cb791c4528bef2e531d1bc411290df9960eef08d00cb51be1ad953ce2c08c47801b26dcf0ab9ec77b5c2078cbe0aa000bdeefff92e12b25e040642a6a7861cbb278b1c05c6e32a7e53e0b34a03f44dd19377b4e9ac479586284bb533d2e35c6eec747c904c44b7f0ee69affb8b90f15f4d83db4d77aedc7b3f49715953ed790501b588a2286a2dc24417f160196a1c668631859b51f7cfc0d37764bab693c86d02fe52c79d8a7686f19a98dcaed4f0c5b49df5075c4b2ce791792997841ffe25eb421b071827a22fd3d7aa5bf125b71993fbfff218a6f1f011b1abeb5505757604c29966c6969240526703d61cf932cbf6859c2553009c5e7cc84ed371a218567063b5b43b62fbf331ea6b4cd68bdb1e488c785fefb9fb21387117f7ba3cab3f9908d602c3c9d1e65167387f455b3d6c7534f0d5ce8ca687d9c76ee42f5ac200e4b79cc31a4072600f366a0d8cd909674d6ce072330ae7649a2130b73d8e814131999227df206b8d5d0ccc5a8583a8bb8393303ce90113322206b1b5792d07ad53009feb610f097a9a51d9350131cb6aa21a01aeac88b56a6bff4434deffd922df86d786c4f267faa60cdd2c4be2d7cef2a1f17099f563a44804052cebd7a68ea9982d51cb91da55de14365f0dd2d65e9c747d3cd4f014c033ec313bf9ffa35476a8cf18a4f5ecab788d005311b3e0a414abb3bcd4bec7c30f91d0c7016560d9dda200a433c57124b8fc19c14b8eea936acc46d957a1ec819075d5c1958940988f65b2259f9b3eef1480338dec04e874287513532521de3aaaeb764da8e228abba6993f2c697ca864f254c5d20f355b749c81d840340b10a9e687ad569876ed520f1ac997db568bebb77edacc7418972b942df8d7e76adde73b907fd23e735aa77f9d652fd6ba69133b07b398525c5afacedda8dcbe14191bda7a37f1fecf075ba96c2b29b56cf48244241fb2734bff5adb221365666fe5c6ddee7052fafc7f2eadf5f1b833001f38aadc2a9822b0a4319be72114d4f1928499e4f5edac5f848fb85694ba13930e32d2bc4e0679c8b4861036c8c427b6b101462af0e45a104623b09280f8bf8e431f22bf4e35207ba103069218e638a99195b546e398adfc11507ae58071a67e8c85da4217579a46a8d89998f1d57a62e2bf7af2fc6f4849058abb7ef5664016a9d514e1c3e656af66b29f0be3acf83a3d72cfcff8bb74c7b61a5594b415f4f31bf3b602a8bf0e1d88a3b9e694e0787259b60cb17cca0ab0410e1da3b4a545dd11f90d22ebc80e2d8e8043d1738373f826cdd86c167cac9d33946efaca9f415fc6b57fe2bff88270a75fd63de1c7ac369f77b08f94343d99514c8949ae6c9e38bd53222ae462727552ba3945e10d08475438afd88eb17a6f60014468be1b1b1c682fb1f034ddd1952cdba93092ce13a30862fab1ca047141019d3a054c22e316f934a7e45eb63ea62c8b138c5c5cdb46883f269a183ad18706d1d456eb5093706093e3f59cb5eaf17fbcb80b8b9262cbc71f8fba9a0dc273639c7cfc320bf58321012f985604d08f1a559defd0e9941152678005cd61f5f6a23a9864ef2156dd0c936b4ba122f8c45b92134ea0bc0d2c7ca139d0291f225c3c01fee291d123890fc05bc9c3564a07f3281ec9e6cc3e7b26839bb59feda5d88e99cfc966884667b33a32fff24f5b56a2ec7d5075796624a6c633f20c9c1ad303f9a12ba1a99b76992757724511915e7a1108ec35c0448bca21eae1386a09a48372bea2f52bc1b24dc967e3b678e57083fc3146c9e287c405dda72969d444d403149cb566a69d296f9be2e19c6fce28fba00fe3f8270a941596b54f569cecc3bc6bc1c621964fc213d978977f4342e7c1d2b85e7a5e901a6aa94bf18b4ea2727a5cb35f24c440f456fd16ff34918b562553f1e7915184bafc8ff336d717d6b18b8cbccadbb330e81395c11655ec71095b90b0b88f5c670600603e431102d1da805482a0679580acef65f5288a4afdbbc92efa9e4b356bd26da54e9114aa59f7deede46d3d346146096e2acdad442bc853c0ef54ee973130f662b6452331c0a52624990f2278b2e50bcd53c8d319d5bcf9d60bffd5120925fc28d325eff5f1925df25787f4bc3411caf8ea90fad525aa9b93ecf1057132aa4586ea5082cdc252d2ce1365bbb4e174e221601f8d695fd7201fb2c093e429f4c4d7aee8b632ae8fb0abf8f5480360d24ab7a9969fef3b1089334c73574815966a3350777fab8d445d2b1a65317043735dcc9b507f2ca991daaeeff90036e42be877924a13f748356c6e91904059269467366bdfc3c50699e7282558b80c827bb18fb33183fdb981010aabfec784483f17980191be2c53ecb44740d7397f996752f0501e9e742f4b08eed3e485cb74d89270ea81b0bac60640a10818f244d958512355c4f6e0c17460158dc0630ab6e9fe297994ba74c1197f35f25ca88f0042ce7bed3b5425b0c86e5d5afa06e59b5e1c06af549402f222c8345de2087b01b4d94b006db5fe067c639c0aa21d9cddf39ee0b74fe65a7e8ccbc70a66378b734d179390b8dd7fc45d49df6c4b3ef51068266af691cebd363d0c1f2353c48aafa48052ba4e79f71bb6ba7cd4c3e4692de696c43c88949504a5062110757fd399aa05fe9b5e76d418f531d8dbc844b64ae081637c90bfc0aec1aacdc1a8326e0ef260e997b83c4ba147117b0ca5fbf5bdcdc015c972e451b4f4ec211f1bbb8e2f41aff23dfb535608a22bf97dea2970b8835c3ac8dff7aecad63e0be9dbbeae1d36c8e4d0f0de74072bd5606fbdd00527457876b2202b45d6c779a9ccccc10c12a218dced6d85923d1aa66b259738923a04b22dd1eaf794cdca64674d5075ea6bdde5c70b1ce30573ed0542780c00cb50fc6c590863c519741e4b2e61109def077639248379c02bbc5f2407eccac1d185a9832f1e850884a19fad612e7e546ca310b02c3efd2b82a869f4f8b091b6b86443db57b227387da135527013c4feece192922d7e4e80b1cf2abba7b984500282c276d9a405ecdbe37e680ebd779095aecfde4f031c8383354d99bbbc21342660ebc06cf3e6f95903306d4825fba46326ac0d673d25d14b0d3802e1e12a8519d68e5c9685143badb5064721c8125a6d8dbdffb5250029fecb7fa3edc15efa4347062c5bf695488f206207b3a16f7b3c444d73de35113f4c7edf939b8b069a9ece328ee99eab937443abb9432f34e4450c6e94a12faef73f4167ba1e9083cdbfd3e89f8aa5de76262f6787df9fcecf23115f621ee13b85003c71d90093ae231ab30bafe72fb614262d7b6fcc2a4397dff2769c0d08638f79ee4f30c0dd163fa7ac33bc1d9cc85660cb56e3ac01046b2bf4a534a3a576628a17e033e601f890e4ca8636bd62b01c8d88985580a923be460b5a9986e4f32ca7ff5ff020dcc7f021cb6c748a3617ddfbf7a4cdfe06d0d8b6832a356194ad32a9d2d0fcc075fdcc6a95cb140b578bd1eedcd794be83940b0f9a0906a481ae53e61d68ed201acdcc3effd3f46d637ffd815ae105a8c8f88735d0ade3dc2a50b1221e98f1eaea6d30e8b4c9423754563b6debc7a93b0dc9a70bd532013b60d4a27a1fa8b46c417b5a7902ddf1f454b79c8164a437035d54f528065959f7cce44dc0461d4577559c2d731cd56459db662b1d26be4b4643fed02acaa3aa593b5523c124c74854759c0c2afeaafea83611b9e0fb77780411d17f5359ce48b447a8f9d4e2e2036560f627ae573ecb134e07cd155dbe02081e1be16f836c28c884b74053f310ba9d50eda6ab0ba464c5c7664805bdf829e694b91c774553ee52f0b0fe858873f538b2af06af00eabd2fbee46498f758e0cf0d396d9410a150a399fe3b01cf656c81d12110c7ce2b9592e72445a6b9ba543c5b37ec684bdfc9916f14538ea27e6924142c395b8a3531fd0881107a2a1907408e2e7b7d5278e50b8879e0f2b79f2f22f870c6d4eb4d06a52529eac904fd6f6f4e257d1ef6c5bfe1ec6b36d6c20797d70fc2082bdd7d4cd21bcd36704b3ec483e3d074a47eb8e10e2c2435272c61c13e417e12e460a3ee0307fedb67afb46284fce12a332be5c68f6f7e6488ba0c9dcd14e25ceaf76e4c8bc26b2b65390b90602c804d028a0e39e1e063fdfb6da81c8b3730226226bce2a544c2909ee1f2f6cf1b37e7f8ac3770af6b2c7564dbf4d38a030dd5a4cf80ee7bc3aa5270a13d38d4c6193b570aa733a1abf0a228a56c008412097ff3d41d7cdc214e6783ef3a77c3e7e7de5d15ce104a03fbd88cbe1b26dd1823e755c3d28bb9382f18869084b5595f76d1049457913794f43d6554f57108ec5193cddaf8cc74322f7662f588c33f985b546d8a9161cac0b635f36927b0a6e51e6b0b122be772c3251a1b0b2c4f69c4e810de7c1fc3d4ce1a06a31e47520e6748e121cffda56d7db281a4b77b8ee8ca4755f6ed16c29ec3101a70240648ed00a59f28f94b2046639d58c6c15139df67819082a3cbc6b26a95a9f6af1039679023969f3f3a028a637f8fa549febe433e4929d7650fe4844a5d784b08d0d8efa70b64b84f2050c404486558bb7c64d2b4db8f96406f6643003bf63bbc622d1cb41643408d918a9f6831ee521e0b9d2c44db3706e68ca0ca93534a69e193f5e36ba0362d142d124389aa0ae6d24bbe69d84196fbc7e63a7fcdf4d6162aaad57c10f3b969d3757c88d98a24cf37ff5e5bbbcaced2c57a3a64c55b7147d450b3b53ef9f111e5377970bb0fedd883e497e6cb993bf5fef8b89eb0f4b0e95bffd144b7ba3ce374c61240b65fe5e1579b02840259054aeb7aae94d3eac622cf00b7616d3f0c9aaf0f1778397e0ef47d920fdc49cd472b23b75cf95f26fbbcaaebccbe2a80bef2e9ea704ef3e40828e9ead992dcc8a1ba98dab9a7d3ef3b260153e129a329f63207feaae6b16078c7bc1755b57ee63cf81c3dc2770e0dc6b72d20bc78bb6b833d093f6e5f1e3745d80572d1aa590f506d28b06bee16ca2d60ade3e25f76bb35989828060177a6af094b592d2b34f49398b316a2b8f7388fe742f5b481bb29d5f85ec4c28ce3c75cb82a21a449499403a3cd6dc6fbf37e502e6640e16745ae01fa55b3d49b0d4db8e95bf698c840604ddb6846da639f8a516a7120df59c187e25f8f022385750f2ff7887596045b98627bf5831cfceedbd38865e57081c3acf6b3de9aedac34afd9ad7450363e91b24162ab8a9502917744f7359228a2a2a8edfadd48551c297ec55833a32e68bbce2e42cef941b50b0db96bf7c4bf66bcd64e42041813ce0958075bb4773763e546dd4d0d5e2b253190ca3f4862ecb5a74bfbf4e5734d999dbb386dbc3631c405d43e89cfe33ca7f7dc880501788d795b941fbe266bdd20ddce1e5471948cc8a3d3a144e3495e6c9ce67e2b8d68607c20a41aa231d3867885295fe32645b9c73fc963fba5a8b1a6ac5be5d5efc3d1928f5e1ff83341b814b336abcf0567ee16c32b2c7c23255d790ebaed0f631860dc51ec116683c9e7c02a1c468b10af1e742fd92e28afb6cc440960114a769dcf16bca418dfff0a9fda2cada50eb420de51a1477dfc76083118b0394e8090a7ba28163856b743feb56ac588f9b04283b5bd0cdea36788830ab7a5604d7241b0813de8f23f0269dca8e6eaae24c485bb6918ba07d97511a6227e435ed5ee59ba7e0741fc8d3bbd5a2996b0eb773d0f26522bea1d49839d94b87231b060f6ffd5f7c63579fac42c492cd95d5f35e16d7c7adfdedbeb48253ab04cdb623518af22911b78d3abbc78aa2953e4ccaabcb5b847cb4dba553af0eb6526dff1fe14c356d453a4e6e01cebd14ce0420929fb9c46f8981c547a6fa49cfd8b35b9a3a29a4144c41fc012a753ce818d5debe9af5201f0b44f07f14570af020cdd828a9c62809356545b52c5cf9afb9a2e2ab78fb18e96020d06ce99fec7f98e6376ca261093aa7b3c3d316db02e12fc4f9962177e9cf3ac3245b8700fd8564381de4a61ca7e21641a92e05bd8b0291ce1a8669d444807da22d5f1567fa52e7d75df44677b05ddfe16f13747c5158b61764309cfdbd4d5e946aee1746f8166cd2b88d52f0da945db8748eeecd9efc843803b64efd8c09499fcab4ef32b2599b1d929afad6ceb6d4e728095ca42616c370d06e1cd7a809d6920d86ab6f748061c3c142e1b850629c59a7644d642c6d5cedd10a2466fff793ce945e4d4581304c36303b1f53877be90477435112c547551e7e98edc14cbee52a63e6ec657c1197a3b28b263df6dd9620cca82f8c00d71ff3ad348ff1c7f248b1eb5e4890cdfe69e26f5b3e1039be400beb6fb1ab88b4ec5ac07d40d0771de6de787f78a0a98e8f4d162192e5524162649fe4475cddf702a9cebc5036b40f1c1686f4ce7999a082fc42a7901bf9eeddccbc08b3354a69a49978224cde599352c328d6bb4f8040a152499b8baf7119f376fe29b04a8994ecce4910a2c2f98dd82897fc7f2911cdeb34165b79486714d2d512b1d98da0ba803f8d541ee1e757f40f2a0002037e0b35bc291e2b9da100903f1518596ee8e895d1948e89f4a40bfe546a36f6f2aa1da2e8d9d0d6400c0699c38a4693c53906faa608998035109fe1bdc218ad9b944323c5711ba4b1b88096545d7d4d8e29b51cafe82c65a4e0a929cb0c6ef58266934964b702f549aa29f6f380629ee2185cd10cad261f90bf4296dedf28c1410e303f5b697f5934ad308ba9dec2d776a44015c945bf57e2a3199a3c97c5381487a89cffb377dddfd9d1114924ae46685fe6e2f6a35d28e1fe58baf680cd816dcbab4229c4819077bfb06944a74de3646cbc1d81d37237868ede790c2006d7d7696e6f2cfd3d979724d3af7d2c9c04bed35b1fa7a716846eb7ce37a7daba2dd67c1280f6b9100804c2e1c2a90b809657333eaad9d1aa8163f07ef26f768f938b4b742f0f5c12a6db602729035a0f0b84e012bc86c0b5b5cacf1175fff6ffcf285c6238c56c728686edd9afe30bfc409b18a5c6e5a279eb8bf2d7a5e172bbbf9bac7b2be31386cb1310f2045d5bce82e7dee6140e63fdce5190c9c65dc6f8a6bb2a5eca63d0b3cf0684e98468c1529f1c6a4bf031be9b22dc7cc14a483e447cdcd0ab9cecf0070ba117533a1aefea7ebd2c58a2c2fc5882b78bdfdbb3520f44ad69e7483f4316a86f12c7bd10d2b46e56ef4d7dbb78a5be0c7cdf1c590d3ab729354f448068231654a034772ca368d437d93cad2136506b841f0d758bb5d33bf65bd11c4cb209b40692147d2977b1dda40d4bcb8efa162fa16984b33a55f0f03da3476a44de5680ff8a6e89ad283ada18976b15c4b3c0165671c701b9859cdf4092bd40adadc216ae41df82f912e64e9ad9022a8cb5a29ea2b7ac79dbc93661228a28d8e167c9a8cb934ca66d80353b38e687bb63a1f6174f4c77af2ba0e7afc63891e591799fb17f3f5fa73ba79ae8cd954362d65f9405c1c413d910f82e37a5c78cbaae8bcc8562d082231f4a8545c196bdbc3d9d01ce8ddaa354a78e6bd497ef9a00503f1269040946dbdc7b4d57bc341c5a7af380feafca611bddd815d92602607d8d693e53743c5f42e5ab219ec57fb59949c54faf2ae8577ea6332a46434ff67f125cc87b1283b6c40936537320ff8a9ec9c0aeeb456499e70c46759d5bc0579c977cd416eb924c6c427e0c93c0de270f425e814d6cd39e4457aeffb123a70c58bed78b8e68a62af51e33f7b626302e8bd34011636ef145e9a499d8e17c4d9ba130ed3a46ae5f2fc4813296fd60ee0ad71e9b184bf85391ebf3a8de6aa8ded19b8b966bd707be73c61db3dc72aa2d7c8b145556c6d47630f20ffd74a07e1300b122e90f410640206689169b0464246ce9a045786d644e2e888c70a0202593c52db33d525ec8e47bbb749ae5900922df6b9365592e5dd3c7fe45ddc5818759e0c8706aeeff34100494201820c8797db068127423eb5bb61a731071033629e0a333f87a46b400bf5310261a09b92d7d01bb8b9cf6fa6981f4ee08fb6a5afa7143c58750e0741397e3b320ff495a0392a8f7b4e2ffb05947858756e7cc775fdedb3f5cf55fc0f2dc1552ca02f919d5c7a96100db0fd0976d4815ec24b87c346fae422b8419710010267d82a584be94642c6eeb915bdef25377ad81f09fa7ce30fb617dc127a30f2e0fbb174a39d1aec77fc8b840def243b637fb8432371708a3ad39769a3f89e9f30e7327c84a16b2ac838a6ef8f782c7768055281793ba0ad5708030d21f6a1622927397ef81e6b6a2fcd4693db73bd85bc2699a1be42b22f803dfb18c87a2b8c735d5fdfe6b00c4e8f62456456a33bc9bdeabf4ced2adeed5617596d22b1b3170e932e8b2f029432fc5b722139c017816100b277d61a702f1f1fe8220e011dda7a1afb18fc4af05b2c56fa6ece7c95b8f3532ba304f41f83d686be4177f14faada58def3d1949414c878e37cddbd359be129a9b143bfbfed7c5a76c62e4adcc869d3384d8f71a3054cd8624507ac908c7d96a1a9b21a6294b89a4533e9c3853671b9e666fea05057e7cb130417692c20a3a335d727c2f2315fb90c966f38cd5db31ac6c2f945010e8baebc1046ffb970285bad92043d1c65fcb06dd2bdc07b5e3cc37446752fd1ae9da42826ac63244679f7e9bd2fc8abde55f2d4a238b6b1d2caf8a44cc76b8d3178955876b8139770b07c3fdcb629838075baab981f9565785081503a0a40bbb8513edf57e66133f5437ba9004a1cb77776d32b0cf37581dc994d1aabce9fe791691e4b0ea63db387a7236cf28229c00808986faab521f8222724fc28fd3fb2f163092d30fb1f67dc87127ef6fc0eb138637d1c1b01946a37b5dbd6fb1c4e32511c71bc6a545634bf11bdbc7e9db6a2f9231f46140c395f4390c3efce210f6686eae058eef6223299112d666a2d79bb8610a5f304b9dd01d122e91881863831a6de0c159029c45e35db5e74fae93aaf7581614b93409ea04bd4176cd025cc275bcb55b41ab512c44fdf2eef0c6d6db5f461bac47b69c270088c1f4dbd01e813bc001a34625e54104444c327783f4c994f8f83011e32d9c6108fc87590095843af586021e6f6ae86750a7ac1ffcd7381b2fb22ddd9cfa8f0e73ba6ce8559e1ad0149a375cf30b7abffaac39320ae667b2b36b6719c7eeaf51810151ccd85e8362d94bc461ff98390fbaec6b25fdf9c44084128cd6fae1a78388b645b99c9a384d1160f7c099c825d06cb9aed9dcb639bd38972532ba707bbb38244d3402b4de17ca8c57008e92f2e51e66c0c95e5dc70cb8bf45b2cf3024d4ba07612da516a46ba76257f3b63b19d6bd4e4bce7a13444d1739cc2bff4bfd5a13218a93f95bbdc67965d36cd0c72523eeda154876319ab6d592b95987af80e96f4e9374894a84c393c7809ed8bebe3bd43613170e901ce03d2f1529bfdcc6f4ca54906e8ba995d3b3d3c5e96b157807dc8a7313e4f2223c0869f055ca3a550b8e8ce41496619144e081a5b70f75bf0cdb2f5efb8f86dd084f7cca35f059b93c17ac58f0808e90f4460cca42c2bd3778bbd38a1c155cf594ec95a9f8640009d8040791b76d85d42d9567d4d2f0f0d4306bd9b5074f8eb6ab91402fb73419527be7783c908ce5dc31fdeb08901ccb238d3bd684732d1a051d5b5c5d73b369fa3e37058136e3cf252ac7d457447149686051aec0caf2273e4fb17d2acc72b2a5572a7629935ab0a90b05f0803ee6cd15c18692a846d498862b37f713a7c754b55c8edcf143b93878dabe06474defc1a877268d1ff56be75e7990f4bbb347a4f239d0a8be2fa1a953cff525df45dbb104015e2752f349990b608461d3b4ecdd6686908bc0468c685a0a0b79a9f56cb3e3a8ef6463bae7476c4e9f88112640f52a951af215aa4a8c9b8750fcd6d4cc42ed5b7f69e288b7d4dd25b7e9e9bd270a1e46a71056f5896cc9840fc310e76d02ae3dcb668bb8cdaeb3ed61396bb6b4727bc7775feb687569ad2bee65eea4f42f49c3b713f880d5e0c29740599d1937c19f164faf286faceb48ca55b8b217507c23d444517d88e14b146e14229839cc691db9b057d37a679716bc6ad836c1c791bd2471715a89ae06065804345bba8e50415a652630b9b5179c094dc12baee0d7b0a800db9478ffcb15da9e333030c9988ac46c2e3f05e66e8619933ac966389e5fba7a31c76edd3f6607c56564888c5432ff0dc7843fb75fe3d90a7a2961a148917c01842095781a7cfa99938753931651df928354ff7b0548dc129f7fc0f9bb4f2840d0593a6010ecab4cfc5c38ff213b46f08acdf7387b68094f3787225ccfa0f8b7d2677a366e7b1f3e9c772f2891f78e194d3a5713ce8d4320d960f36e485b14486a1c2ea4d6743d6928a172bfec6a44c0783987cbc037027bd2cd3a3252d6ca99a3048190ca32772bae3292f03264e12302559ab3fb720e64eb9457a55cf50f0432e40cbbc25949f489a17beec01bb4347d052609ca5d337626ed53eeb960c15648f823f6d672b9ede953f6c9d31d2b531eed78843b346acb113c0577dcd21a09543b47e61024761e51f4fc4a81b50db34f82d928f30764dc990c567b79ad215b4223b29e079b08bfe528c096b4343c24b67f0cdc6dd7526ded2a9567f4d877f87b9aba6aee872001cfc9922a59c835b3be58b380b4f1d4b13db7e2d6848233d39917ff46592b82a031594f1d739ff1eb8de7e86d9721194111aee0c65dce1b0f179ef354cd778408fb240ee49611cfe44a6e6c9f5a697be3a990241edf92cb54d19bd38def70dc9d1dbc7a2331227366725d8322773d2f496b7602024ce06f5f84daacfca75c21cdcd8bf2010605f41d9c4279eb4ba88c803e0db78288b1aa490a807342a8400ab5de4444534126b6b93b7\n  \n    \n      \n      \n        Hey, password is required here.\n      \n    \n  \n\n","categories":["后端项目","准备工作"],"tags":["Jenkins","Kubernetes"]},{"title":"【代码模板】二维码的生成","url":"/posts/5ee0f6a5/","content":"\n\n前言\nZXing 是一个开源的，用 Java 编写的多格式的 1D / 2D 条码图像处理库，使用 ZXing 可以生成、识别 QR Code（二维码）。常用的二维码处理库还有 zbar，近几年已经不再更新代码，下边介绍 ZXing 生成二维码的方法。\n\n\n更新\n\n\n24-06-28 初始记录\n\nZXing\n\n\n引入依赖\n\n\n&lt;!-- 二维码生成&amp;识别组件--&gt;  &lt;dependency&gt;      &lt;groupId&gt;com.google.zxing&lt;/groupId&gt;      &lt;artifactId&gt;core&lt;/artifactId&gt;      &lt;version&gt;3.3.3&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;      &lt;groupId&gt;com.google.zxing&lt;/groupId&gt;      &lt;artifactId&gt;javase&lt;/artifactId&gt;      &lt;version&gt;3.3.3&lt;/version&gt;  &lt;/dependency&gt;\n\n\n生成二维码方法\n\n\npublic class QRCodeUtil &#123;      /**       * 生成二维码       *       * @param content 二维码对应的URL       * @param width   二维码图片宽度       * @param height  二维码图片高度       * @return 二维码二进制流       */      public String createQRCode(String content, int width, int height) throws IOException &#123;          String resultImage = &quot;&quot;;          // 除了尺寸，传入内容不能为空          if (!StringUtils.isEmpty(content)) &#123;              ServletOutputStream stream = null;              ByteArrayOutputStream os = new ByteArrayOutputStream();              // 二维码参数              @SuppressWarnings(&quot;rawtypes&quot;)              HashMap&lt;EncodeHintType, Comparable&gt; hints = new HashMap&lt;&gt;();              // 指定字符编码为“utf-8”              hints.put(EncodeHintType.CHARACTER_SET, &quot;utf-8&quot;);              // L M Q H四个纠错等级从低到高，指定二维码的纠错等级为M              // 纠错级别越高，可以修正的错误就越多，需要的纠错码的数量也变多，相应的二维吗可储存的数据就会减少              hints.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.M);              // 设置图片的边距              hints.put(EncodeHintType.MARGIN, 1);                try &#123;                  // zxing生成二维码核心类                  QRCodeWriter writer = new QRCodeWriter();                  // 把输入文本按照指定规则转成二维吗                  BitMatrix bitMatrix = writer.encode(content, BarcodeFormat.QR_CODE, width, height, hints);                  // 生成二维码图片流                  BufferedImage bufferedImage = MatrixToImageWriter.toBufferedImage(bitMatrix);                  // 输出流                  ImageIO.write(bufferedImage, &quot;png&quot;, os);                  /**                   * 原生转码前面没有 data:image/png;base64 这些字段，返回给前端是无法被解析，所以加上前缀                   */                  resultImage = new String(&quot;data:image/png;base64,&quot; + EncryptUtil.encodeBase64(os.toByteArray()));                  return resultImage;              &#125; catch (Exception e) &#123;                  e.printStackTrace();                  throw new BusinessException(CommonErrorCode.E_200007);              &#125; finally &#123;                  if (stream != null) &#123;                      stream.flush();                      stream.close();                  &#125;              &#125;          &#125;          return null;      &#125;  &#125;\n","categories":["后端项目","准备工作"]},{"title":"【代码模板】延时任务","url":"/posts/f6ca592/","content":"\n\n前言\n\n\n\n业务场景：\n1、生成订单 30 分钟未支付，则自动取消（延时任务）\n2、生成订单 60 秒后，给用户发短信（延时任务）\n…\n\n\n更新\n\n24-08-18 初始记录（从原先的笔记进行搬运）\n\n定时任务与延时任务的区别\n\n\n定时任务有明确的触发时间，延时任务没有\n\n\n定时任务有执行周期，而延时任务在某事件触发后一段时间内执行，没有执行周期\n\n\n定时任务一般执行的是批处理操作是多个任务，而延时任务一般是单个任务\n\n\n解决思路\n数据库定时轮询（定时任务）\n\n通常在小型项目中使用，即通过一个线程定时的去扫描数据库，通过订单时间来判断是否有超时的订单，然后进行 update 或 delete 等操作。\n\n实现\n通过 springBoot 中的@Schedule 进行实现\n步骤\n\n\n在启动类上添加注解@EnableScheduling\n\n\n@SpringBootApplication  @EnableScheduling  public class ScheduleAppcation &#123;      public static void main(String[] args) &#123;          SpringApplication.run(ScheduleAppcation.class, args);      &#125;  &#125;\n\n\n在目标类上添加注解\n\n\n// 目标任务执行完后，延迟10s执行。@Scheduled(fixedDelay = 10 * 1000)  public void testJob01() &#123;\t...&#125;\n// cron表达式@Scheduled(cron = &quot;0 0 6 * * ?&quot;)  public void testJob01() &#123;\t...&#125;\n优缺点\n\n\n存在延时，定时任务默认是单线程执行，前一个任务阻塞会影响后一个任务的执行\n\n\n数据库数据量大的情况下，扫描损耗巨大\n\n\nJDK 的延迟队列\n\n该方案是利用 JDK 自带的 DelayQueue 来实现，这是一个无界阻塞队列，该队列只有在延迟期满的时候才能从中获取元素，放入 DelayQueue 中的对象，是必须实现 Delayed 接口的。\n\nDelayQueue 属于排序队列，它的特殊之处在于队列的元素必须实现 Delayed 接口，该接口需要实现 compareTo 和 getDelay 方法\ngetDelay 方法：获取元素在队列中的剩余时间，只有当剩余时间为 0 时元素才可以出队列。\ncompareTo 方法：用于排序，确定元素出队列的顺序。\n实现\n利用 JDK 自带的 DelayQueue 来实现\n步骤\n\n\n在测试包 jdk 下创建延迟任务元素对象 DelayedTask，实现 compareTo 和 getDelay 方法\n\n\npublic class DelayedTask  implements Delayed&#123;        // 任务的执行时间    private int executeTime = 0;        public DelayedTask(int delay)&#123;        Calendar calendar = Calendar.getInstance();        calendar.add(Calendar.SECOND,delay);        this.executeTime = (int)(calendar.getTimeInMillis() /1000 );    &#125;    /**     * 元素在队列中的剩余时间     * @param unit     * @return     */    @Override    public long getDelay(TimeUnit unit) &#123;        Calendar calendar = Calendar.getInstance();        return executeTime - (calendar.getTimeInMillis()/1000);    &#125;    /**     * 元素排序     * @param o     * @return     */    @Override    public int compareTo(Delayed o) &#123;        long val = this.getDelay(TimeUnit.NANOSECONDS) - o.getDelay(TimeUnit.NANOSECONDS);        return val == 0 ? 0 : ( val &lt; 0 ? -1: 1 );    &#125;&#125;\n\n\n在 main 方法中创建 DelayQueue 并向延迟队列中添加三个延迟任务\n\n\n循环的从延迟队列中拉取任务\n\n\npublic static void main(String[] args) &#123;\tDelayQueue&lt;DelayedTask&gt; queue = new DelayQueue&lt;DelayedTask&gt;();\t\tqueue.add(new DelayedTask(5));\tqueue.add(new DelayedTask(10));\tqueue.add(new DelayedTask(15));\tSystem.out.println(System.currentTimeMillis()/1000+&quot; start consume &quot;);\twhile(queue.size() != 0)&#123;\t\tDelayedTask delayedTask = queue.poll();\t\tif(delayedTask !=null )&#123;\t\t\tSystem.out.println(System.currentTimeMillis()/1000+&quot; cosume task&quot;);\t\t&#125;\t\t//每隔一秒消费一次\t\ttry &#123;\t\t\tThread.sleep(1000);\t\t&#125; catch (InterruptedException e) &#123;\t\t\te.printStackTrace();\t\t&#125;\t&#125;     &#125;\n优缺点\n\n\n数据存储在内存中，容易出现 OOM（Out Of Memory）异常\n\n\n服务器宕机后，内存中的数据容易丢失\n\n\nRedis 缓存\n实现\n利用 Redis 中 Key 的过期时间\n步骤\n\n\n给 Redis 中 Key 设置过期时间\n\n\n监听 Redis 中 Key 过期事件\n\n\n获取过期 Key 对应的值进行消费\n\n过期 Key 拿不到值\n\n可以把信息存储到 Key 上（监听事件可以获取到即将过期的 key，可以将文章 id 存储到 redis 中）\n存储一份不过期的对应 Key，在 Key 过期时获取这个不过期 Key 取值再删除\n\n\n\n\n\n优缺点\n\n\n若 Redis 监听过期 Key 的微服务是多个集群时，只能有一个微服务处理，需要引入分布式锁，性能会下降。\n\n\npackage com.heima.common.redislock;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.StringRedisTemplate;import java.util.UUID;import java.util.concurrent.TimeUnit;public class RedisLockImpl implements RedisLock &#123;\t@Autowired\tprivate StringRedisTemplate stringRedisTemplate;\tprivate ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;String&gt;();\tprivate ThreadLocal&lt;Integer&gt; threadLocalInteger = new ThreadLocal&lt;Integer&gt;();\t\t@Override\tpublic boolean tryLock(String key, long timeout, TimeUnit unit) &#123;\t\tBoolean isLocked = false;\t\tif (threadLocal.get() == null) &#123;\t\t\tString uuid = UUID.randomUUID().toString();\t\t\tthreadLocal.set(uuid);\t\t\tisLocked = stringRedisTemplate.opsForValue().setIfAbsent(key, uuid, timeout, unit);\t\t&#125; else &#123;\t\t\tisLocked = true;\t\t&#125;\t\t// 重入次数加1\t\tif (isLocked) &#123;\t\t\tInteger count = threadLocalInteger.get() == null ? 0 : threadLocalInteger.get();\t\t\tthreadLocalInteger.set(count++);\t\t&#125;\t\t\treturn isLocked;\t&#125;\t@Override\tpublic void releaseLock(String key) &#123;\t\t// 判断当前线程所对应的uuid是否与Redis对应的uuid相同，再执行删除锁操作\t\tif (threadLocal.get().equals(stringRedisTemplate.opsForValue().get(key))) &#123;\t\t\tInteger count = threadLocalInteger.get();\t\t\t// 计数器减为0时才能释放锁\t\t\tif (count == null || --count &lt;= 0) &#123;\t\t\t\tstringRedisTemplate.delete(key);\t\t\t&#125;\t\t&#125;\t&#125;&#125;\n使用 MQ 实现延时任务\n实现\n\n内链：[[消息队列的选型与优缺点]]\n外链：消息队列的选型与优缺点\n\n优缺点\n\n\n高效，可以利用 MQ 的分布式特性轻易的进行横向扩展，消息支持持久化增加了可靠性。\n\n\n","categories":["后端项目","准备工作"]},{"title":"【代码模板】阿里云接口实现短信发送","url":"/posts/9b7300f0/","content":"\n\n前言阿里云接口实现短信发送。\n\n\n更新\n\n\n24.05.24 初始记录\n\n依赖\n&lt;!--sms验证服务--&gt;  &lt;dependency&gt;      &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;      &lt;artifactId&gt;spring-cloud-alicloud-sms&lt;/artifactId&gt;      &lt;version&gt;2.2.0.RELEASE&lt;/version&gt;  &lt;/dependency&gt;\n代码\n\n\nService 中要添加的代码\n\n\n@Override  public Boolean sendCode(String phone) &#123;      //非空校验      if (Strings.isNullOrEmpty(phone)) &#123;          throw new LogicException(&quot;手机号为空&quot;);      &#125;        StringBuilder sbCode = new StringBuilder();      // 6位随机密码    Stream.generate(() -&gt; new Random().nextInt(10))              .limit(6)              .forEach(sbCode::append);      //将验证码放入redis, 5分钟过期      redisTemplate.opsForValue().set(phone, sbCode.toString(), Duration.ofMinutes(5));      log.info(&quot;短信验证码：&quot; + sbCode.toString());      return smsSender.sendMsg(phone, sbCode.toString());  &#125;   \n\n\nSmsConfig.java\n\n\n@Configuration  @RefreshScope  public class SmsConfig &#123;      @Value(&quot;$&#123;sms.operator.signName&#125;&quot;)      private String signName;      @Value(&quot;$&#123;sms.operator.templateCode&#125;&quot;)      private String templateCode;        public String getSignName() &#123;          return signName;      &#125;        public String getTemplateCode() &#123;          return templateCode;      &#125;  &#125;\n\n\n配置文件中添加\n\n\nsms:  operator:    signName: 你的signName    templateCode: 你的templateCode  \n\n\nSmsSender.java\n\n\n@Component  @Slf4j  public class SmsSender &#123;      @Autowired      private SmsConfig smsConfig;      @Autowired      private ISmsService smsService;        /**       * 发送验证码短信       *       * @param telephone 手机号       * @param code     手机验证码       */      public boolean sendMsg(String telephone, String code) &#123;          SendSmsRequest request = new SendSmsRequest();            request.setPhoneNumbers(telephone);          request.setSignName(smsConfig.getSignName());          request.setTemplateCode(smsConfig.getTemplateCode());          ObjectMapper mapper = new ObjectMapper();          JsonNode rootNode = mapper.createObjectNode();          // 存入验证码          ((ObjectNode) rootNode).put(&quot;code&quot;, code);            try &#123;              request.setTemplateParam(mapper.writeValueAsString(rootNode));              val sendSmsResponse = smsService.sendSmsRequest(request);              log.info(&quot;短信发送接收：&quot; + JSONUtil.toJsonPrettyStr(sendSmsResponse));              if (sendSmsResponse.getCode() != null &amp;&amp; &quot;OK&quot;.equals(sendSmsResponse.getCode())) &#123;                  return true;              &#125; else &#123;                  throw new LogicException(&quot;验证码发送失败：&quot; + sendSmsResponse.getMessage());              &#125;          &#125; catch (Exception e) &#123;              log.error(&quot;send sms error.&quot; + e.getMessage());              val operLog = OperLog.builder().title(&quot;发送验证码&quot;)                      .businessType(BusinessType.OTHER.ordinal())                      .operParam(JSONUtil.toJsonPrettyStr(request))                      .status(BusinessStatus.FAIL.ordinal())                      .errorMsg(e.getMessage())                      .build();              AsyncManager.me().execute(AsyncFactory.recordOper(operLog));              throw new LogicException(&quot;验证码发送失败&quot;);          &#125;      &#125;  &#125;\n","categories":["后端项目","准备工作"],"tags":["Java","代码模板"]},{"title":"消息平台-项目介绍","url":"/posts/2b76eac7/","content":"\n\n前言新项目学习笔记。\n项目 git 地址：https://gitee.com/zhongfucheng/austin.git\n前端项目 git 地址：https://gitee.com/zhongfucheng/austin-admin\n\n\n更新\n\n\n24-09-10 初始记录\n\n项目概述\naustin 项目是消息推送平台的实现，它的核心功能：统一的接口发送各种类型消息，对消息生命周期全链路追踪\n系统项目架构\n\n\n\n工程模块\n作用\n\n\n\n\naustin-common\n项目公共包：存储着项目公共常量/枚举/Bean\n\n\naustin-support\n项目工具包：对接 中间件/组件\n\n\naustin-cron\n定时任务模块：对 xxl-job 封装和项目定时任务逻辑\n\n\naustin-web\n后台管理模块：提供接口给前端调用\n\n\naustin-service-api\n消息接入层接口定义模块：只有接口和必要的入参依赖\n\n\naustin-service-api-impl\n消息接入层具体实现模 块： 真实处理请求\n\n\naustin-handler\n消息处理逻辑层：消费 MQ 下发消息\n\n\naustin-stream\n实时处理模块：利用 flink 实时处理下发链路数据\n\n\naustin-data-house\n数据仓库模块：消费 MQ 数据写入 hive\n\n\n\n\n","categories":["后端项目","消息平台"]},{"title":"消息平台-核心代码","url":"/posts/4f08dd5e/","content":"\n  665b6e36e8990f013070faca4228a0bfccd399cf756e12c68920c56ce8b4287efa95190af6d6209f579011876b8fa876e0bc2b631d0e227bd44e7792f33fee40dad7ec9375821980e8a38f95ea5d6068fdf072be6dfe9835ac738acc08e2b8652b180e2dd198205612d8298c4f272fd39d8b30f53e63690c16fcccbf7eb6681a06e2642eec08adebbadb213c7dc237ff929bcabc17115cc10f4c5b4fc9aebc200fcf18916cd0aa57c6fb3203481a404b20c9e749b4522858fd75b824a8d59085a8ff9aa5ac41736ec8bc70d688f60a680638bf018dfefb1aed5fcc8183305a1949ab59168a4f805b4f859b8d4abb0aa19d5350b9470b7e4294183d018170e370a50f3952ceb065205db3fc33e14948daed0c356cc17650a6c7a9419d7ee11733285d9eb5cad2707de7edd63077c83910eb31de24e59915023fbdd333f7e3e35274c9950f8040a4d6571439555b3a21d2788d20a3fdca53de945cd871b0259a628d9615216526851b256afba7af06012e061e0831b0b2518690ae131328d27ca09dcf341a435579cb6e4e24a6b9c75c7f4274bcac486648b2b1d63adc9e7aecaa650321e1e38f934db2cd86468a3d3bf7468a5b755aaf749570d84da015a1d83ccc336920871daf7d7dcff045fa0c4afc809b7950819dd93f1c57d4e61552acd3a7178057c69b7679a1728e909efb96cb5543a8fe9cf0cecf62c0a5c39b00bbcfbb8f5c074db648c3799d6fdd2d73b224a4a50efbf5fff9e0af0e71da9dba7630beab7d1626eea2c5dbe30ad253bff8ea06006d99368c8b76b2ba8178173c288d40abe7d384549db225e9aa4d2b7eb103e0e791afcee8a55ce3dcbd9d1b3fa5f64e6e4fc22b633663d9a1f9654e1b9c4112631034edda784c698b4de90f6e09e19c7809d54c2ca4a78ad10488d152c8053e91491902eda5af2f936a73497673141428f19a4f732c8f714dd425a595ded08c5fdee561b7aad0f595359535247690e159b2af36d831a5704e7e7dbcbf22bd325be89e6544a9c6d23ad0ac1be78744df3fe61ad12e48f3f7cb940c87b5549dc8ac7f8e76b819663b3688f04dd09becce536b8e86374e93186024c2f1eedb6f84f3a3bb39fbaddd9766f456925075bb1156ad99221682ecb275d0c335495a796389250cdd8fff406bb0f4fba8975d104b57322b05ae57bc0c5587a56f4054c3b611971411ac2e4467344c46ddd858be2b3cce107bad61a8679f5df2b2be2233f1e430644771869ec07756688473217662ad5186f7ac23b896395a9b7ef4a3a9e47b3befd5b50ac9c36875eaf82247674ca676a309f2047a97f041416bd13d3c8b5ab78c56e839e274889ddbb99387dd327c77235435cda782667decd07361bdc1fbd87718dca038082483c9ef603f60c7c62c8df248df5bd4ba2060c9846555e77ee39d7fb29793da5e01b3a6c6cddc043ce71529107ad2dad9ee30dc5f601f234594f6e046a00d84fb0d4f5e343247afba7adf4c30a6f4cf281ccf6cf4710217b4c075d3ce956a4e6b633ba3af167ea3d8554962ac73b726016accf287bd3c4a54fcf65e00274a363bd64dcba23ae96befc2e2b2808a9696bf34d3cd2781754ce0bfba2e1b2668a4f82e718e4cbeb54a1db7212f522916b65ea0f5ae1b40f115dca4c42641123213d8b870689cbd7e216c2e1b209dd24e239b76449a88bda48fabe4cfed3bcaf9ae64270e8530774eb7d13c07ade02a25e7c113c657d78a59c01c33a30b4dc2626d9295a5a9445f1cc5b86bcdc4c58fd1ff29b2644a4fe6af281e9781a5cc3a99dddd1064ecf45419abe61f1aec206f01b74b76728a4a2e4425844e92052816d33c90bc0428ecb2ac183f3d6626fb65b48ad90b00740a368a846093ce8b667b529a337da2cac8cba8c9816649b25fb9bc2b23a90aa3852ab1b5e8de8fc926a1921a42b471ce2bfc41584a47881c7b85c72ac83fd5373a155c6285fd0e08df65fb90e239f83d1c3c1795d018515513122169e4b89690dd2e128bbb3622d232edb14ededea5f9405dd43ad0f69d2ed176150ab3caee7c4c4b9fab331a9f06916123c28107c580440bb367d50f48b21222aa6051177fe90cbef3801e8a65977e5acd80a1b7d55c30c3765d34c636ee94a5c455aaa12720ea4af635aa77875219cf85a4e1136dece1c4d733da25d4c4a3bc38c55bfabe2eb51e5a01a7807f3f8ad25ffb97383f9eab3ee47c1bf3d39fe6922e7370b4e57420ea942ba9912516f2306be1f9426f2b5712279870b0855c7e6422bdc51ac98957598e90120fdf44cd7edf363bb6cd7111cab2c8633deeb55b304dca9b1197726b231aee9c57c8de7a6f2a849504c0a8e578d50e370e38a5fc57161f568cddcd43a9532a013a6e2577ed17eaa5f7b8f7977dfeca84cf72c1c1680aa05ff002f4acbac273fba9fc9e8f2c05587b42eb2a029ff617a209e001352bf2c63c2f3d904ff2a1269513d805f92d1f95b2eb682690c666f3d7c0fc6475e8d5eb878e3da4f9ebbe5755952fed078a1dbe0e30ae5eeeeb996dd5ab6483e82f3829dfbef027e2d0749a16d183ba480513178a892e3812a00a63d45756726925d55cf047e0aad0a718b67994705c8c87562a5e507cdb84bafa3de033558679f02760af75eed436887a92ec27265335cf816aec6f4e28fab17a664ef55cc27973455740e58fbc930ff07621999d8e51651ee5a42dc901062490da04f05a1ed1b277ab9f9a83022e1868917c7101d7b01beb58fd4c11c40281c88fa9bd4b574d6e7e350afef2fb0f7b9a3cf6db8c3c67286551e2b20fa8448e5a0fb57122dcc5e1bf376800f350243f6800e37b815e5b6bfcfcb31a00ae9b9755f42c52b13ba852018461fd58dac3e915f41155f4514e694a722d8bb2bb2f58caa18edad27a96a6b430a57bd90f5d778c13559c18a9e44e7f8956292136832828b2758df4b27fd1a9d5a87e7fed54bc49fae2698aa7b8b36d8c8a9142b4f1591e7d85ff0609546a44de7f072d3e9cb2e340553ac920fbafa541f26527ce2c5af531d9e4db41342f375b6ad3f20169d165af1899972b75ed4626a7c9b6fcca190fdd69f59a43b7aed8740289f389976f30435e88f17ec1e7c6dc15c6529d3afad84fc9076dff42247c1c9b552279c6d8fafb3866442b75c6db5d5eb3b8c66f417803323ac2e7b490a96c1b8d43d36fef5caef7f76edfba680decb2dd01ade6859ee0e62a966feea367a80bc1663d0739c2caafd8f566a458891fec8575768ea6670de80b1191ff24ed55122338e0bcf6f76709e4917a098acf93958c4456184d80e790a038b2a4f6abae701480295771d71761416e8b094268ff1d2503b935ea4c524aeb47bf3ba1d197262b5306a6d15b02fb5f01a1532044311963b3f3cf07c0deee4c2ab9d03e72a849be4aca4e2a45f412a3ae351b7dd3e3bb93331bb9940d\n  \n    \n      \n      \n        Hey, password is required here.\n      \n    \n  \n\n","categories":["后端项目","消息平台"],"tags":["Java"]},{"title":"消息平台-核心文档","url":"/posts/d978b51b/","content":"\n  75e86ac553190f42ebdd56fafb303e85dc6a1a1a46f0acebaf1f04073eb758dc03ced5e004cf01aca104fdc62a8d68e601b59b3212abdab62d5f768d15cfa18c332989279c5f056126be2ebf5e2b3ce3c9aeeebb8e1e27a7209ae5ef44a58468afee8f711fe819700b0f6de40aa5cd11a0f68cf099f9875ce5d3c113175d0e316d43438e034cc9f1ae0301edf1d9428fd136db5d3f27ac447de92039f0eb1ca246fbafc11d70b0c340bb41c758ceb2b2c39454755e85eba1b7bd59de454695259f7d9cfa8db6039421353a6be2676b54e64ece29430084b53f318e40f38b763adb319c0c599ee0187bcc11f4303fa978fb485dbfc8f947cfcd5b4679740c807c195d192b34cec54663145ce587bf43eacb6f4c2a87dd87e14c74093c12ec9c490087f040a9a452a6cd709be06c4ebda59ceb8ee75c348ea1d5ffb61d74307a6ad7b241a89b28bdf168b043f5ddb6999731df162df074c979d4e08508de1dbbcd8497df48cd5235bea17ec990572904bcb0ac6a2a7100bc448597d1b51c3e775a57ec36820f6f8f174362f72abd2d9623d6db315ccb3f6f12803d2a691851555246bb24ad11647136254cd31c13f89b6df8a5043809af0b3b6d1e01c73c8f860a8c37582a7985c94d445546bf72f75adf1340d6599310a20c2c20582295583d1ca64fd5ebf097ebb91dde9d3180bcbb6a7b9139d1893c09d12db952b61184de93ca34c36fecebd5932c81ae55f95a6f4ca74e8fb0f3441b3c7480bd2e1405d68e67135a237a92aa157c9423ca0e7d115419723b1e870152f7a326670e59b871daad2d38af4149191937327ff9ccaad5e66c389efe894b71ff963dfad9ca98822a05c67573d72c4bd0275993c4235fb26aed1c13c0668b6031db1b4ff27b540a6f30b9bccd769c7b410eec83a90a0e11eec29b775fa43b66e57432b3b4fdc6ee2807691b868548d39060e67e6a991a292cb85d47e08ffb903d1b94e7c68f47d604a58d99649bba8d78e3e9807f52dd4a4489274de5ed20026d180d84fc7ff30e6d72e69da150631eb17d36b66f1f104e3504a25e94cee20fa0d0bf3b887d1906127622f586fac1958c0e67c074a8c4c5b179ac480c275a5a1ddf7a292467758e71f6cf16c6849f2f2e5815bfba33a4820e5c95424e66dc45d317a95f66b2f39f2084dcea51b1e99345d3e6e864902533229a56e2aeb17125dbd038116ebd1cf64fc66cd8f562cc73bff28e0206d304c63e700b8bfb8f157fcc552c367568b42f5edc8aa4af901f2f1f2199331178c844722cd4fe001d5266308b743d389dab012ee19a414f97915718613e7be7ac22746d30c95a06b17f2a1c444934b8480dd07041cd643d0444f9ba9d6e66cd6b0bba25c5855bee4a413d48eb012b4c05d7f6619508f6b3fc6602965582767be5f44070c525a50a2fff69a2d9816d736d3605f6d5728784d7b83e7bc6ba6e6f3bc77ac289934a3bfb99b5106e306f5878396738551e4abe7ecd9e1168a32ba97fd13d4ccd73eb98b0b8cc4cbca9ef2912107dd891766bf43fce6014457dc7872ca397834ca735e0a25abe701b74feb02543546adec2413d5ae389fb9de21f7a6859f0564df8877c18ff12b14b6ddbbb2db7a2b10f9aede01750337badfdebb6ae178bb29b8e95a09d627a5572c738510f18c5f05257bc67edc5f6c5880a146d7496a18e2b04962045c09511f3b5e75ca0a50adb2091b18fdbc8a7366ba15df55f85ffd0491b1013dabacc9098fc073be2de988cff20587cb921f1a2df22600e1167d8a346d989b3a8c2f883de2568798d295fdf10f0bead231ea1aeb018b7a3ebf9906e9aba3e3aa9844c29bad5aa2a3b2a7761\n  \n    \n      \n      \n        Hey, password is required here.\n      \n    \n  \n\n","categories":["后端项目","消息平台"],"tags":["Java"]},{"title":"面试-总览","url":"/posts/b567f09b/","content":"\n\n前言\n这个部分作为一个背题打卡 List。展示面试前必须掌握的东西。\n// todo 第三季 视频 71-92 没有看\n\n\n更新\n\n\n24.06.02 初始记录\n\nArrayList\n\n\n什么是双向链表\n\n\n底层原理\n\n\n和 LinkedList 的区别\n\n\n线程不安全如何解决\n\n\nHashMap\n\n\nput 的过程\n\n\n头插法和尾插法的区别\n\n\n1.7 和 1.8 的扩容机制\n\n\n链表和红黑树的转化过程\n\n\n线程不安全的问题 (解决方案)\n\n\nConcurrentHashMap 的 1.7 和 1.8 原理和区别\n\n\n多线程\n\n\n实现方式，每种实现方式的区别\n\n\nVolatile 关键字\n\n\nCAS 自旋锁\n\n\nLock 锁是公平锁还是非公平锁\n\n\n你了解 AQS 机制它的核心原理是什么\n\n\n公平锁，非公平锁，偏向锁，轻量锁\n\n\n线程的 6 种状态\n\n\n线程池的 7 大核心参数\n\n\n4 个拒绝策略\n\n\n线程池多线程的执行流程\n\n\n线程池的常用实现方法\n\n\nThreadLocal 的原理\n\n\nJVM\n\n\n说一下 JVM 的主要组成部分及其作用\n\n\n说一下 JVM 运行时数据区\n\n\n堆里面的分区：Eden，survival （from+ to），老年代，各自的特点是什么\n\n\n说一下 JVM 调优的工具\n\n\n常用的 JVM 调优的参数都有哪些\n\n\n简述 Java 垃圾回收机制\n\n\n什么是 Full GC\n\n\n什么情况下会触发\n\n\n说一下 JVM 有哪些垃圾回收算法\n\n\n数据库\n\n\n索引的机制和底层原理\n\n\n什么是组合索引\n\n\n最左匹配原则\n\n\n数据库的事务\n\n\n引擎的原理\n\n\n数据库悲观锁和乐观锁的实现\n\n\nb+ 树的好处\n\n\n数据库的优化\n\n\n多个数据源如何操作\n\n\n框架\n\n\nSpring 的事务传播机制\n\n\nbean 的生命周期\n\n\nSpringMVC 的执行流程\n\n\nioc\n\n\ndi\n\n\naop\n\n\nSpringBoot 异常处理机制\n\n\n简化操作的原理\n\n\n自定义注解\n\n\nSpringcloud 的组件\n\n\nRedis\n\n\nRedis 的数据类型\n\n\n常用命令\n\n\n持久化方法\n\n\n雪崩、击穿、穿透\n\n\n过期策略\n\n\n淘汰策略\n\n\n与数据库的一致性\n\n\n哨兵模式\n\n\n集群\n\n\n分布式锁\n\n\n异步队列\n\n\n延时队列\n\n\n线程模型\n\n\n分区\n\n\nMQ\n\n\n为什么要用 MQ\n\n\nMQ 的优势\n\n\n消息补偿机制\n\n\n一致性\n\n\n预防消息丢失\n\n\n可靠性\n\n\n不重复消费\n\n\n集群镜像模式\n\n\nMQ 的工作模式\n\n\n项目应用场景\n\n\n场景\n\n\n请求量大如何拦截\n\n\n如何去两个库查数据\n\n\n","categories":["面试","八股文"],"tags":["面试","八股文"]},{"title":"面试-基础","url":"/posts/3a228d8a/","content":"\n\n前言\n❗表示必掌握，❔表示基本不会问\n\n\n更新\n\n\n24.06.03 初始记录\n\n❗Java 的基本数据类型\nbyte，short，int，long，float，double，char，boolean\n面向对象的三大特性\n继承、多态、封装\nJDK 和 JRE 的区别\nJRE：Java 运⾏时环境。它是运⾏已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，Java 命令和其他的⼀些基础构件。但是，它不能⽤于创建新程序。\nJDK(Java Development Kit)：它是功能⻬全的 Java SDK。它拥有 JRE 所拥有的⼀切，还有编译器（javac）和⼯具（如 javadoc 和 jdb）。它能够创建和编译程序。\n简单来说，JDK 包含 JRE，JRE 包含 JVM。\nJava 支持多继承和多实现吗\n不支持多继承，支持多实现。\n构造函数和一般函数有什么区别\n\n\n定义格式不同\n\n\n构造函数是在对象创建时，就被调用，用于初始化，而且初始化动作只执行一次。 一般函数，是对象创建后，需要调用才执行，可以被调用多次。\n\n\nJava 怎么创建对象\n\n\n使用 new 关键字\n\n\n使用 newInstance 方法\n\n\n\nJava 反射中有一个 newInstance() 方法，可以创建对象，步骤如下：获取要创建的类的 Class 对象。如果只需要调用这个类的访问权限为 public 无参构造器，直接使用 Class 类的实例方法 newInstance()。获取 Class 对象的构造器对象，通过调用 Class 类的实例方法 getDeclaredConstractors() 来获取构造器对象的数组。(获取所有构造器，无视访问权限的限制，数组顺序按照代码中的顺序决定) 如果调用的构造器是 private 的，需要调用 Constractor 类的父类 AccessibleObject 类的实例方法 setAccessible(true) 来打破访问限制。使用 Constractor 类的实例方法 newInstance()。获取 Class 对象的方法有 3 个，此处不多赘述。获取 Constractor 对象的方法有 4 个，此处不多赘述。\n\n\n\n使用 clone() 方法\n\n\n\nObject 类是所有类的直接或间接父类，Object 类中提供了 实例方法 native()，在给定对象的基础上，创建一个完全相同的对象。步骤如下：想要使用 clone() 方法创建对象的类，实现 Cloneable 接口。在类的内部，重写 Object 类的 clone() 方法。备注：没有实现 Cloneable 接口，会抛出 CloneNotSupportedException 异常。Object 类提供的 clone() 方法，访问权限是 protected，所以如果不重写 clone() 方法，是没有权限调用的。Object 类的 clone() 方法，是 native 方法。\n\n\n\n❔使用反序列化的 readObject() 方法\n\n\n\n这个方法一共分两步：将对象序列化，存储到一个文件中。从文件中反序列化，得到类对象。\n序列化：想要序列化对象的类，实现 Serializable 接口。使用文件输出流 FileOutputStream 创建存储序列化之后对象的文件。使用对象输出流 ObjectOutputStream 的实例方法 writeObject(obj)。判断类中是否存在，名为 writeReplace()，返回类型为 Object 的方法。若有，写入这个方法的返回值；否则，写入 obj 对象。\n反序列化：使用文件输入流 FileInputStream 找到存储序列化对象的文件。使用对象输入流 ObjectInputStream 的实例方法 readObject()。判断类中是否存在，名为 readResolve()，返回类型为 Object 的方法，若有读取这个对象；否则，反序列化文件中的对象流。\n备注：在类中，writeReplace() 和 readResoleve() 是两个非常特殊的方法，其特征签名需要严格限制：方法名限定，参数个数限定为 0，返回类型必须是 Object，不能为 Object 的子类，但是可以抛出不同的异常。访问修饰符没有限制，但一般推荐为 private，防止误操作。其特殊的地方还在于将其设为 private 方法，没有其他方法调用的情况下，编译器不会发出警告。\n\nJava 中的异常\nThrowable -&gt;Exception -&gt; ClassNotFoundException\t\t\t\t\t  -&gt; IOException\t\t\t\t\t  -&gt; RuntimeException      -&gt; NullPointerException\t\t\t\t\t\t\t\t\t\t\t  -&gt; NumberFormatException\t\t\t\t\t\t\t\t\t\t\t  -&gt; IndexOutOfBoundsException\t\t\t\t\t  ......          -&gt;Error\n❗抽象类和接口的区别\n\n\n定义：接口定义：interface；抽象类：abstrat class;\n\n\n抽象类可以定义构造方法供子类调用，接口不可以；\n\n\n接口的所有方法都是抽象方法，所有属性都是常量：static final 类型；而抽象类中可以有不是抽象的方法和不是常量的属性；\n\n\n抽象类只能单继承，而接口之间可以多继承，接口之间的继承用 extexds，类实现接口用 implements.\n\n\n== 和 equals()\n\n\n==：\n\n\n\n\n如果比较的对象是基本数据类型，则比较的是其存储的值是否相等；\n\n\n如果比较的是引用数据类型，则比较的是所指向对象的地址值是否相等（是否是同一个对象）。\n\n\n\n\nequals：\n\n\n\n\n如果没有对 equals 方法进行重写，则相当于 ==，比较的是引用类型的变量所指向的对象的地址值。\n\n\n一般情况下，类会重写 equals 方法用来比较两个对象的内容是否相等。比如 String 类中的 equals() 是被重写了，比较的是对象的值。\n\n\n为什么重写 equals 方法，还必须要重写 hashcode 方法\n\n\n保证是同一个对象，如果重写了 equals 方法，而没有重写 hashcode 方法，会出现 equals 相等的对象，但是 hashcode 不相等的情况，重写 hashcode 方法就是为了避免这种情况的出现。\n\n\n使用 hashcode 方法提前校验，可以避免每一次比对都调用 equals 方法，提高效率\n\n\n重写后：\n\n\nequals() 相等的两个对象，hashcode() 一定相等；\n\n\nhashcode() 不等，一定能推出 equals() 也不等；\n\n\nhashcode() 相等，equals() 可能相等，也可能不等。\n\n\n所以先进行 hashcode() 判断，不等就不用 equals() 方法了。\n\n\n但 equels 是是根据对象的特征进行重写的，有时候特征相同，但 hash 值不同，也不是一个对象。 所以两个都重写才能保障是同一个对象。\n\n\n深拷贝和浅拷贝\n浅拷贝（shallowCopy）只是增加了一个指针指向已存在的内存地址。\n深拷贝（deepCopy）是增加了一个指针并且申请了一个新的内存，使这个增加的指针指向这个新的内存，使用深拷贝的情况下，释放内存的时候不会因为出现浅拷贝时释放同一个内存的错误。\n浅复制：仅仅是指向被复制的内存地址，如果原地址发生改变，那么浅复制出来的对象也会相应的改变。\n深复制：在计算机中开辟一块新的内存地址用于存放复制的对象。\nJava 中都有哪些引用类型？\n强引用：发生 gc 的时候不会被回收。\n软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。\n弱引用：有用但不是必须的对象，在下一次 GC 时会被回收。\n虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。\nSPI 介绍\n​SPI 全称 Service Provider Interface，是 Java 提供的一套用来被第三方实现或者扩展的 API，它可以用来启用框架扩展和替换组件。\nJava 的 SPI 机制就是将一些==类信息写在约定的文件中==，然后由特定的类加载器 ServiceLoader 加载解析文件获取资源。\nJava SPI 基于 “接口编程＋策略模式＋配置文件(约定)”组合实现的动态加载机制。它提供了一种服务发现机制，允许在程序外部动态指定具体实现。\n一般情况下是调用方调用实现好的接口，但是当接口存在于调用方这边时，就是 SPI ，由接口调用方确定接口规则，然后由不同的厂商去根据这个规则对这个接口进行实现，从而提供服务。\n​以下是 SPI 的一些运用场景：\n\n\n\n场景\n说明\n\n\n\n\n数据库驱动\n数据库驱动加载接口实现类的加载 JDBC 加载不同类型数据库的驱动\n\n\n日志门面 SLF4J 接口实现类加载\nSLF4J 加载不同提供商的日志实现类\n\n\nSpring\nSpring 中大量使用了 SPI，比如：对 servlet3.0 规范对 ServletContainerInitializer 的实现、自动类型转换 Type Conversion SPI(Converter SPI、Formatter SPI) 等\n\n\nDubbo\nDubbo 中也大量使用 SPI 的方式实现框架的扩展，不过它对 Java 提供的原生 SPI 做了封装，允许用户扩展实现 Filter 接口\n\n\nSpringBoot\nSpringBoot 基于 SPI 思想实现自动装配\n\n\n插件扩展\n开源框架，想使用别人的插件，扩展某个功能。\n\n\n\nServiceLoader：点击链接跳转链接到 JavaGuide。\n面试大白话\nJava 中的 SPI 就是你提供一个接口，然后让别人提供实现类。然后将这个实现放在 resources/META-INF/services/ 中。这样 Java 启动的时候就会去扫描这个下面的 jar 包，并把他加载进来。一般来说用在开源框架中的插件扩展，然后比较常见的思想提现就是 Java 的 JDBC 实现，可以根据自己使用的数据库，将对应的 jar 包引用进来。\n（Dubbo 中可能问到的问题）Dubbo 中也使用了这个思想: 比如说有一行代码是：\nProtocol protocol = ExtensionLoader.getExtensionLoader(Protocol.class).getAdaptiveExtension();\n然后在使用 Protocol 接口时，dubbo 他会去找一个你配置的 Protocol，他就会将你配置的 Protocol 实现类，加载到 jvm 中来，然后实例化对象，就用你的那个 Protocol 实现类就可以了。这个 Protocol 就是用来配置他的网络协议的，然后在源码中可以看到，默认使用的是 dubbo 协议，就是 DubboProtocol。dubbo 里面提供了大量的类似上面的扩展点，就是说，你如果要扩展一个东西，只要自己写个 jar，让你的 consumer 或者是 provider 工程，依赖你的那个 jar，在你的 jar 里指定目录下配置好接口名称对应的文件，里面通过 key=实现类（这些都可以在官网的文档里找到）。\n","categories":["面试","八股文"],"tags":["面试","八股文"]},{"title":"面试-集合","url":"/posts/c99ff7c6/","content":"\n\n前言\n集合常见问题，其中 HashMap 很重要❗表示必掌握，❔表示基本不会问\n\n\n更新\n\n\n24.06.01 初始记录24.08.09 修改部分文字错误\n\nJava 集合\n集合分为单列集合 （collection） 和双列集合 （map）。单列集合又包括 List（可重复） 和 Set（不可重复），List 分为 ArrayList 和 LinkedList\n单列集合是实现 Iterable 接口产成的对象，支持迭代器和增强 for。\n迭代器 nkedList，Set 分为 HashSet 和 TreeSet。双列集合 Map 分为 TreeMap 和 HashMap\n基础\n所有的单列集合都可以使用迭代器，因为他们都继承了 Iterable 接口，这个接口里的 Iterator 方法可以返回一个 Iterator 对象，这个 Iterator 对象就是迭代器对象，底层针对不同类型的集合都写了不同的实现类，所以集合可以直接使用迭代器进行遍历查询。这种只需要提供一种方法（iterator 方法）访问一个容器对象中各个元素，而又不暴露该对象的内部细节的方式就是迭代器设计模式。\n迭代器倒序\nList 集合可以使用迭代器倒着遍历，ListIterator 有 previous() 方法和 hasprevious() 方法，可以自动指向并取出上一个元素。Set 集合不能用迭代器倒着遍历，但可以根据它的大小顺序倒着取出。\n使用 foreach、iterator、for 有什么区别？效率上哪个更高？\n区别上：\n普通 for 循环一般用来处理比较简单的有序的，可预知大小的集合或数组.\nforeach 可用于遍历任何集合或数组，而且操作简单易懂，唯一的不好就是需要了解集合内部类型，它的底层有函数式编程注解 @FunctionalInterface，也就是说它可以进行 Lamda 形式简写。\niterator 是最强大的，他可以随时修改或者删除集合内部的元素，并且是在不需要知道元素和集合的类型的情况下进行的，当你需要对不同的容器实现同样的遍历方式时，迭代器是最好的选择！\n至于增强 for 和 iterator 其实是一样的，增强 for 编译后的.class 文件中，就是 iterator，所以二者除了写法是用第三方参数来表示，效率上没有任何区别。\n效率上：\n这个需要多方考虑，比如普通 for 循环用在数组是遍历最快的，它是直接获取数据，但普通 for 不能用在不知道长度的集合中，这就需要用 iterator 或者 foreach，相对来说，iterator 效率会高于 foreach，因为 foreach 在访问过程中产生一个额外的 Enumerator 对象，这个对象会进行版本检查处理，所以它是线安全的。\n对于 ArrayList 来说，它是通过一个数组实现的，可以随机存取；但是 LinkedList 是通过链表实现的，当要遍历依个取出时，for 循环时要取的每个元素都必须从头开始遍历，而 iterator 遍历则从头开始，边遍历边取，取完只需要一次遍历，所以 for 循环需要的时间远远超过 foreach 循环。 对于数组来说，for 和 foreach 循环效率差不多，但是对于链表来说，for 循环效率明显比 foreach 低。\nArrayList 和 LinkedList 的底层原理\n首先，List 集合是有序集合，即存取有序，List 集合的特点是存取顺序一致，存储元素可重复，都有索引。\nArrayList 的底层是数组，一个索引对应一个元素，所以查询速度快；但是在增删时，需要调整整组数据的移动，所以增删较慢。\n而 LinkedList 的底层是双向链表，每次查询时都要从两头开始查询（离头近就从头查，离尾近就从尾查），所以查询较慢；但是增删时，只需要将链表头结点和尾结点指向新插入的结点即可，所以增删速度较快。\n但如果是新增的数据量较大的情况下，ArrayList 的新增效率反面比 LinkedList 的效率更高。因为 ArrayListr 底层数组的扩容是 1.5 倍，数据量越大，扩容的速度就越快，而链表仍需一个个断开链接和重续新链接。\n最后，jdk8 版还对 ArrayList 做了懒加载优化，在之前是构造 ArrayList 时就默认开辟 10 个空间，jdk8 之后变成了只有放入第 1 个元素时，才会开辟 10 个空间。\n❗❗数组的起始长度是 0，在向数组中添加第一个元素时，数组容量扩为 10。 后续扩容因子为 1.5 倍。每次扩容都是复制到新的数组。\n分别讲一下 Set 集合和 Tree 这种数据结构\nSet 集合的特点是必须排序，没有索引，不可重复。Set 集合分为 HashSet 和 TreeSet，HashSet 底层使用的是哈希表，它的排序规则是按照底 Hash 函数决定的，无法人为设置；而 TreeSet 的底层则是使用红黑树，可以使用自然排序（自定义类中实现 Comparable 接口，重写 CompareTo 方法）或比较器排序（在创建 TreeSet 对象创建一个 Comparator 的匿名内部类，并重写 Compare 方法），扩容时通过结点链接。\nTreeSet 使用 Iterator 遍历的过程是怎么样的？\n因为 TreeSet 是按大小排序的，所以会根据从左往右，从下往上的顺序打印。\nList 集合是线程不安全的，你是怎么使用 List 集合的呢？\n使用 Collections 集合工具类，对集合进行同步处理：\n  List&lt;String&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;()); \n但是在多线程开发中，对其进行遍历，需要添加 synchronized 关键字，因为 List 的 add、index 等方法中都是带有 synchronized 关键字，但是在 iterator 中没有 synchronized 关键字。\nHashMap\n❗HashMap 底层的数据结构\n数组 + 最简单 Hash 的原理。\n对存入的 key 进行 hash 计算，根据计算出的 hash 值，对数组长度进行取模，获取到要存入的位置。\nJDK8 以前，Hash 表的底层是【数组】+【链表】\nJDK8 及之后，变成了【数组】+【链表】+【红黑树】\n❗JDK 1.8 中对 hash 算法和寻址算法是如何优化的？\nhash 算法：hash 值与 hash 值右移 16 位进行异或计算。得到结果位高 16 位 + 高 16 位与低 16 位的异或值。（这一步主要为了低 16 位在下一步寻址的时候，使低 16 位保留高 16 位的特征，减少哈希冲突）\n寻址：(n - 1)&amp;hash 算出数组内的一个位置。\n为什么使用&amp;运算不使用取模运算？\n\n取模运算性能比较差，而且 (n - 1)&amp;hash 的效果和 hash 对 n 取模，效果是一样的。\n为什么效果是一样的？因为数组的长度一直是 2 的 n 次方，只要他保持数组长度是 2 的 n 次方，那么效果就是一样的。\n\n❗HashMap 如何解决 hash 碰撞？\nhash 冲突，链表 + 红黑树，O(n) 和 O(logn)\n❗HashMap 如何进行扩容？\n2 倍扩容。\n扩容之后要进行 rehash。即 hash 值与新数组长度 (n - 1) 进行与操作。如果值与原来不一样，新的 index 就是 旧index + oldCap，通过这个方式，避免了 rehash 的时候，进行取模（效率不高）。\nHash 表中数组的初始化分手动初始化和自动初始化，自动初始化会在第一次插入元素时开辟空间，默认长度为 16，扩容因子为 0.75，每次扩容量为自身的 2 倍长度，扩容之后存入数组的新索引位置就会改变。手动初始化的话，可以在创建对象时自定义初始数组长度，但 HashMap 不一定会按自主设置的数值初始化数组，而按 2 的 n 次方创建。\nHashMap1.7 版本的的扩容时是先判断是否达到阈值，达到先扩容，再添加元素，并且采用的是头插法，也就是旧元素挂在新元素下。而 HashMap1.8 的扩容时是先添加元素，然后判断是否达到阈值，达到阈值直接扩容，且使用的是尾插法，即新元素挂在旧元素下面。\n初始化后，当存入新的键值对时，会先判断数组长度是否大于 64，再判断链表元素是否大于等于 8 ，如果两者都成立，链表会自动转换成红黑树，如果数组小于 64，会从第 9 个开始先扩容，直到数组长度大于等于 64 时，链表长度再增加，就会转为红黑树。\n❔为什么要转为红黑树呢？\n链表取一个数需要遍历链表，而红黑树相对效率要高。\n❔为什么不直接使用红黑树呢？\nHashMap 源码中有相关描述： “因为树节点的大小是链表节点大小的两倍，所以只有在容器中包含足够的节点保证使用时才用它”，显然尽管转为树使得查找的速度更快，但是在节点数比较小的时候，此时对于红黑树来说内存上的劣势会超过查找等操作的优势，自然使用链表更加好，但是在节点数比较多的时候，综合考虑，红黑树比链表要好。\n❔为什么转为红黑树的条件是 8 而不是第 9 第 10 个呢？\n源码中有对这个进行计算，正常的随机哈希码下，哈希冲突多到超过 8 个的概率不到千万分之一，几乎可以忽略不计了，再往后调整并没有很大意义。\n如果哈希冲突有那么多，说明极大可能是人为设置，故意制造哈希冲突导致，这时候就转为化红黑树，来保证查询效率。\n❔那什么时候退出红黑树呢？\n当哈希冲突个数从第 8 个变到第 6 个时，红黑树转化为链表。\n❔6 与 8 之间的第 7 个冲突时，会是什么状态？\n分情况看。8 退 6，是红黑树转链表，6 进 8，是链表转红黑树，中间的 7 是防止频繁变动做的一个预留位，如果是 8 退 6，中间的 7 就是红黑树；如果是 6 进 8，中间的 7 就是链表。\n为什么 1.7 是头插法，1.8 是尾插法？\n1.7 版本使用头插法是因为头插法是操作速度最快的，找到数组位置就直接找到插入位置了，但这样插入方法在并发场景下会因为多个线程同时扩容出现循环列表，也就是 Hashmap 的死锁问题。（详细解释：[https://segmentfault.com/a/1190000024510131][https://segmentfault.com/a/1190000024510131]）\n1.8 版本加入了红黑树来优化哈希桶中的遍历效率，相比头插法而言，尾插法在操作额外的遍历消耗（指遍历哈希桶）已经小很多，也可以避免之前的循环列表问题，同时如果已经变成红黑树了，也不能再用头插法了，而是按红黑树自己的规则排列了。\n❗多线程下的 HashMap 线程安全吗？为什么？\nHashMap 本身就是线程不安全的，多线程下，在添加元素时容易出现数据覆盖情况，而丢失数据，也可能在扩容时迁移数据出现数据覆盖情况，而丢失数据。\n❗ConcurrentHashMap 实现线程安全的底层原理\nJDK1.8 以前，多个数组，分段加锁，一个数组一个锁。他将一个大的 ConcurrentHashMap 分成 16 个小的 Segment。也就是说可以同时承受 16 个线程的并发。\nJDK1.8 以后，数组里每个元素进行 put 操作，都是有一个不同的锁，对当个位置进行 put 操作时，采取的是 CAS 的策略。如果 CAS 操作失败，就使用 synchronized 对这个位置的对象进行锁定，然后基于链表或红黑树，对数组元素进行写入。\n","categories":["面试","八股文"],"tags":["Java","面试","八股文","HashMap","Java基础"]},{"title":"面试-计算机基础","url":"/posts/cb03b778/","content":"\n\n前言\n❗表示必掌握，❔表示基本不会问\n\n\n更新\n\n\n24-06-18 初始记录24-06-21 网络安全\n\n网络\n❗TCP IP 四层网络模型、OSI 七层网络模型\n\n大白话描述。\n\n\n\n物理层：网线，电缆，在物理层面连接网络。（可以发送 0，1 信号）\n\n\n数据链路层：定义一套协议，对 01 数据进行分组。把一堆 0/1 电路信号，封装成数据包，包含头和数据，头包含了目标的 mac 地址（从一台电脑的网卡发送到另一台网卡）。\n以太网规定了每个网卡包含一个 mac 地址（唯一）。\n在一个局域网/子网内，电脑是广播给所有的电脑（通过网络交换机），通过头的 mac 地址，实现通信。\n\n\n网络层：IP 协议。如果计算机不在子网内，需要路由器进行子网的连接（子网内的请求把路由器的 mac 地址和请求的 mac 地址都写上，路由器把请求转发出去：这里可能是多个网关不断转发）\n判断两个 ip 是不是在同一个子网内，要用子网掩码做与运算。再比较前 3 位是否一致（代表网络）。\nARP 协议：局域网内，每个 ip 地址对应一个 mac 地址，局域网内的设备是互相知道的。\n网关：其实就是路由器的一种。可以把路由器上的 ip 地址认为是网关。\n\n\n传输层：tcp 协议、udp 协议。端口对端口。（端口号是 0~65536，0~1023 被占用，别的要用 1024 以上的端口）\n传输层的 tcp 协议，仅仅是规定了一套基于端口的点对点通信协议，包括如何建立连接，发送和读取消息，实际上要基于 tcp 协议开发，一般使用 socket。\n\n\n应用层：http 协议，stp 协议（邮件）。读取数据，处理数据，发送响应……。\n\n\n4 层模型：数据链路层 -&gt; 网络层 -&gt; 传输层 -&gt; 应用层\n7 层模型：物理层 -&gt; 4 层模型（其中：会话层（SQL）、表示层（加密、ASCII）、应用层（HTTP） -&gt; 应用层）\nDNS 地址：把域名地址发送给 DNS 服务器，DNS 服务器（8.8.8.8）告诉你域名地址对应的 ip 和端口号。\nHTTP 协议的特点有哪些？\n\n\n默认端口为 80；\n\n\n一次请求对应一次响应；\n\n\n无状态：多次请求和响应间的数据是不共享的，可以通过会话技术解决该问题。\n\n\n❗浏览器请求一个链接的全过程\n\n\n把域名地址发送给 DNS 服务器，DNS 解析域名到服务器地址\n\n\n先会判断 ip 地址是不是在一个子网内，不是就走网关。直接把浏览器发送的数据按应用层协议，比如 http 协议打包成一个应用层数据包（包含 http 请求报文）。\n\n\n按 tcp 协议的规定，生成 tcp 数据包，请求头包含，发送的端口和请求的端口；tcp 数据包包含 http 数据包。\n\n\n按 ip 协议的规定，生成 ip 数据包，请求头包含，发送的 ip 地址和请求的 ip 地址；ip 数据包包含 tcp 数据包。\n\n\n按以太网的协议，生成以太网数据包，请求头包含，发送的网卡 mac 地址和请求的网卡 mac 地址（网关的 mac 地址）；以太网数据包，包含 ip 数据包。以太网数据包限制大小 1500 字节，所以会进行切割。\n\n\n打包完毕，把以太网数据包通过网络交换机发送给（路由器）网关，经过网关的多次转发，发送给请求域名的服务器。服务器按包的序号重新拼接、层层解包，获取 http 请求报文。程序获取请求，做出响应，一层层封装再响应。\n\n\n❗画一下 TCP 三次握手、四次挥手流程图。为什么是三次？\n三次握手：客户端 -&gt;服务端 -&gt;客户端\n四次挥手：客户端 -&gt;服务端 -&gt;服务端 -&gt;客户端\n为什么是三次：如果只有二次握手，可能会出现比如：发送一次请求，卡在半路；发送二次请求，握手成功。这时一次请求发送成功，服务端建立连接，但是客户端无响应，资源浪费。如果是三次握手，第三次握手可以复位连接，释放资源。\n❗http 的工作流程？http1.0、http1.1、http2.0 具体有哪些区别？\n工作流程就是浏览器请求一个链接的全过程。\nhttp1.0：tcp 短连接。三次握手、四次挥手，断开连接。\nhttp1.1：默认支持长连接，第一次打开网页，就会打开一个 tcp 连接，接着一段时间内都不关闭。所有网页资源的获取走同一个 tcp 连接，直到获取完毕，关闭连接。但是每个通道都需要一个线程守护，大大影响服务器的并发能力（目前是主流版本 BIO）。\nhttp2.0：支持多路复用，一个 tcp 连接可以并行发送多个请求以及接收响应数据。二进制分帧，将传输数据拆分成更小的包。（底层基于 NIO 的选择器技术实现，未普及）\nBIO、NIO、AIO 有什么区别？\nBIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单、使用方便，并发处理能力低。\n\n\n每个客户端与服务端通信都会建一个配对的 socket 线程。缺点：连接客户端过多，服务器会宕机。优化：建一个线程池。\n\n\nNIO（比较常用）：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。\n\n\n服务端有一个 selector 线程（一般 +Cached 线程池），每个客户端连接，注册创建一个 channel。如果客户端发送请求，对 channel 创建一个线程（从线程池），处理完请求线程被销毁。\n\n\nAIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。\n\n\nNIO 比 BIO 多了一个 buffer（缓冲区）的概念，线程从 channel 读取数据会从缓冲区读取（这个读取是直接交给操作系统来干的，是异步的，操作系统读完数据，再告诉线程去处理），写入缓冲区（这个也是异步的）。\n\n\n小结：\n\n\nBIO 是一个连接一个线程。（只要连接，就分配一个线程）\n\n\nNIO 是一个请求一个线程。（只有 IO 请求，才分配一个线程）\n\n\nAIO 是一个有效请求一个线程。（AIO 是异步的 NIO）\n\n\n同步阻塞、同步非阻塞、异步非阻塞\nBIO 同步阻塞。不是完全网络通信模型，是针对磁盘文件的 IO 读写。\nNIO 是同步非阻塞。发起请求后可以去干别的事，但是还是需要主动轮询操作系统。\nAIO 是异步非阻塞。操作系统异步通知。\n// todo 看 demo 代码\n❗聊聊 HTTPS 的工作原理？为什么用 HTTPS 就可以加密通信？\n\n\n浏览器把支持的加密规则发送给网站。网站选择一套加密算法和 hash 算法。\n\n\n网站发自己的证书（网站地址、加密公钥、颁发机构）\n\n\n浏览器去验证证书是否合法（合法链接会有一把锁）。浏览器接着生成一串随机数密码，然后用证书里的公钥进行加密，这块走的非对称加密；发送消息的 hash 值（这个是用随机密码加密过的）\n\n\n网站从消息里提出公钥加密后的随机数密码（用私钥解密），用随机数密码再对消息进行解密，然后用 hash 算法对消息计算 hash 值并与浏览器发送的 hash 值进行比对。网站同样上面的步骤发送，浏览器同样解密。\n\n\n之后浏览器和网站进行的通信，都是走随机密码加密，此时随机密码已经存在浏览器和网站的本地。后续不用再针对这个进行加密解密。（因为这个加密解密只在第一次链接发送，并且要证书才能加密解密，所以安全性较高）\n\n\nhttp 的长连接的工作原理是什么？\n\ndubbo 协议走的长连接，可能会带到这个。\n\nhttp1.0 底层 tcp 是短连接，http1.1 即以后都是长连接（建立了连接之后，无论有多少次请求都是走一个 tcp 连接）。\nGET 请求和 POST 请求方式有什么区别吗？\n\n\n请求参数的携带方式同：get 请求放在请求行中，post 放在请求体中。\n\n\nget 请求，请求参数是在请求行中，数据的大小受到浏览器限制；post 请求则是放在请求体中，数据无大小限制。\n\n\nget 请求的安全性低，post 请求相对安全性高（不会作为 url 的一部分，不会被缓存、保存在服务器日志、以及浏览器浏览记录中），且 post 可以进行加密操作。\n\n\nget 的效率比 post 更高，因为 post 请求在真正接受数据之前会先将请求头发送给服务器进行确认，然后才真正发送数据，所以 get 一定是先于 post 执行的。\n\n\n但是： 本质上来说，GET 请求和 POST 请求没什么区别，只是在浏览器端对它们的使用不同而已，它们底层都是基于 TCP（三次握手、四次挥手）的 Socket 进行数据传输的。\nSocket 工作原理\n\nsocket 是属于传输层的编程规范。按照视频讲述的内容：就是浏览器发送一个请求链接的部分\n\n\n\n按 tcp 协议的规定，生成 tcp 数据包，请求头包含，发送的端口和请求的端口；tcp 数据包包含 http 数据包。\n\n\n按 ip 协议的规定，生成 ip 数据包，请求头包含，发送的 ip 地址和请求的 ip 地址；ip 数据包包含 tcp 数据包。\n\n\n按以太网的协议，生成以太网数据包，请求头包含，发送的网卡 mac 地址和请求的网卡 mac 地址（网关的 mac 地址）；以太网数据包，包含 ip 数据包。以太网数据包限制大小 1500 字节，所以会进行切割。\n\n\n打包完毕，把以太网数据包通过网络交换机发送给（路由器）网关，经过网关的多次转发，发送给请求域名的服务器。服务器按包的序号重新拼接、层层解包，获取 http 请求报文。程序获取请求，做出响应，一层层封装再响应。\n\n\n❔进程间是如何通信的\n进程间的通信：管道（半双工）、命名管道（半双工）、消息队列、共享内存\n❔线程间又如何切换\n上下文切换、时间片算法。\n场景题\n线上服务器的 cpu 使用到达 100%，如何排查、定位、解决问题？\n\n就是找哪段代码出了问题。\n场景：catch 时写了死循环。在 catch 中调用了自己的方法\n\n\n\n定位耗费 cpu 的进程\n\n\n# 显示进程列表top -c# 然后输入 P，按照 cpu 使用率排序# 输入 M，按照内存排序\n\n\n定位耗费 cpu 的线程\n\n\n# 这里的 pid 就是上一步查出来的 pidtop -Hp pid# 这样可以获取线程的 pid# 然后输入 P，按照 cpu 使用率排序\n\n\n定位哪段代码导致的 cpu 过高\n\n\n# 这里的 pid 是上一步获取到的 线程 pid 为了获取它的16进制表示printf &quot;%x\\n&quot; pid# jstack 进行分析jstack 进程pid | grep &#x27;线程pid&#x27; -C -color\n线上进程 kill 不掉怎么办？\n\n场景：发布系统搞了一个子进程，子进程是系统进程。杀不掉。\n\nkill 一个进程 kill 不掉，这个进程就是变成了一个僵尸进程（zombie）状态。因为这个进程释放了资源，但是父进程没有确认。\n# 显示所有进程和其状态，可以加 grep 过滤ps aux # 查看 STAT 那一栏，如果是 Z，就是僵尸进程ps -ef|grep 僵尸进程id，可以找到父进程id# 然后先 kill 父进程，再 kill 子进程\n服务器存储空间快满了，在不影响服务正常运行的情况下怎么解决？\n\n\n一般来说，可能是日志写满了。可以去 spring boot 下的日志去看看。还可以写个 shell 脚本，crontab 定时，定期删除 7 天以前的日志。\n\n\n# 查看磁盘使用情况df -h\n\n\n要是不行\n\n\n# 找大于100M的文件find / -size +100M |xargs ls -lh# 看各个目录占用的磁盘大小。这个命令可以把占用大小导出du -h &gt;fs_du.log\n安全\n❗黑客常用的 XSS 网络攻击原理\nXSS 攻击和 SQL 注入是大部分的黑客进行网络攻击的手段，除此之外还有 CSRF、Session 劫持之类的。\nXSS 攻击：\n\n\n反射型攻击（在 URL 链接里嵌入自己的恶意脚本）。这个 URL 地址指向黑客的服务器，他的服务器会返回一段 html+javascript 恶意脚本（跨站点脚本），在网页内运行（跳转、下载、病毒、流氓软件）。\n\n这个脚本，可以通过浏览器获取大量的信息，比如说一些 cookie/密码。可以利用 cookie 伪造用户登录的 session 状态，以用户的名义干一些事情。\n处理方法：HttpOnly 方式，在浏览器存放 cookie 时，设置一个 HttpOnly 属性。\n\n\n\n持久型攻击。把恶意脚本放到评论内容里面，这个内容会存到数据库，用户访问浏览器就会访问这个恶意脚本。\n\n处理方法：对评论内容进行消毒，就是进行一些转义，比如把 &gt; 转义为 &amp;gt 之类的。这样就可以把恶意脚本里的 html、js 脚本之类的失效。\n\n\n\n❗SQL 注入攻击背后的原理\n\n执行 SQL 注入必须要知道你的数据库表结构。\n\n开源软件，会被知道表结构\n错误回显。堆栈信息被暴露到前端。\n根据参数的名称，大致推测（一般不现实）\n\n\n参数使用预编译可以预防。例：mybatis 使用 # 不使用 $\n❗CSRF 攻击及背后原理\n(Cross Site Request Forgery) 跨站点请求伪造。通过恶意脚本获取用户 cookie，通过伪造 cookie，伪造请求获取信息。\n处理方法\n\n\n防止 cookie 被窃取。给网站的 cookie 设置 HttpOnly 属性。\n\n\n随机 token。请求携带随机 token，存放在 redis 里。\n\n\n验证码。\n\n\n验证请求中的 referer。\n\n\n❗如果系统允许用户上传文件，有可能会遭到什么攻击\n\n文件可能是可执行的脚本、病毒。\n\n处理方法\n\n\n白名单校验。限制上传文件的类型（根据开头字节的 magic number 来判断文件的类型。例：FFD8FF:JEPG、89504E47:PNG）。限制文件大小。对文件重命名。对文件进行一定的压缩。\n\n\n❗DDos 攻击是什么\ndistributed denial of service，分布式拒绝服务攻击。\nDos。假设你的系统每秒能接受的请求为 1000，黑客以每秒 1000 的请求访问，机器就会宕机。Dos 攻击是一对一的。但是，现在系统都设计了集群。攻击一台服务器，其他服务器还是可以接受请求。\nDDos。控制大量的机器（肉鸡），比如一些共公司的服务器（被木马植入给控制了），一起攻击目标。\n\n\nSYN Flood 模式的 DDos 攻击三次握手。服务器返回 SYN+ACK 后，如果没有接收到返回，会进入等待列表（会为等待的客户端预留网络资源）。这个模式是一个漏洞。黑客利用肉鸡，发送大量的 SYN 请求，服务器会为它们预留网络资源（网络资源耗尽）。正常用户访问就会拒绝连接。\n\n\n基于 DNS Query Flood 的 DDos 攻击控制肉鸡伪造大量不存在的域名，把 DNS 服务器瘫痪。这时用户访问域名地址就会失败。\n\n\n基于 Http Flood 的 DDos 攻击（cc 攻击）控制大量 HTTP 代理服务器，去给目标服务器发送大量的 HTTP 请求。\n\n\n处理方法\n采购云厂商的安全服务。DDos 高防 IP，可以把攻击流量都导入到云厂商的高防 IP 服务器上。\n","categories":["面试","八股文"],"tags":["面试","八股文"]},{"title":"代码随想录算法训练营第一天-704二分查找、27移除元素","url":"/posts/1d4e4fc4/","content":"\n\n前言状态：可以通过\n\n\n更新\n\n\n24.04.17 初始记录\n\n初步题解\n704 二分查找\n题目链接：https://leetcode.cn/problems/binary-search/\npublic class LE704 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          int[] nums = Arrays.stream(scanner.nextLine().split(&quot;,&quot;))                  .mapToInt(Integer::parseInt)                  .toArray();          int target = Integer.parseInt(scanner.nextLine());          System.out.println(search(nums, target));      &#125;        public static int search(int[] nums, int target) &#123;          for (int i = 0, j = nums.length - 1; i &lt;= j; ) &#123;              int k = (i + j) / 2;              if (nums[k] == target) &#123;                  return k;              &#125;              if (nums[k] &gt; target) &#123;                  j = k - 1;              &#125; else &#123;                  i = k + 1;              &#125;          &#125;            return -1;      &#125;  &#125;\n27 移除元素\n题目链接：https://leetcode.cn/problems/remove-element/\npublic class LE27 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          int[] nums = Arrays.stream(scanner.nextLine().split(&quot;,&quot;))                  .mapToInt(Integer::parseInt)                  .toArray();          int val = Integer.parseInt(scanner.nextLine());          System.out.println(removeElement(nums, val));      &#125;        public static int removeElement(int[] nums, int val) &#123;          int i, j;          for (i = 0, j = nums.length - 1; i &lt;= j ; ) &#123;              // 第一次修改 -&gt; if改为while              // 第三次修改 -&gt; 加上j的边界值限制, 不然会数组越界              while (j &gt;= 0 &amp;&amp; nums[j] == val) &#123;                  j--;              &#125;              while (i &lt;= nums.length - 1 &amp;&amp; nums[i] != val) &#123;                  i++;              &#125;              // 第二次修改 -&gt; 加上i &lt; j的判断, 否则最后一次交换会把数组换乱              if (i &lt; j) &#123;                  int temp = nums[j];                  nums[j] = nums[i];                  nums[i] = temp;              &#125;          &#125;          return i;      &#125;  &#125;\n看讲解\n704 二分查找\n文章讲解：https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html\n视频讲解：https://www.bilibili.com/video/BV1fA4y1o715\npublic static int search(int[] nums, int target) &#123;      for (int i = 0, j = nums.length - 1; i &lt;= j; ) &#123; \t    // 这里需要写成这种方式防止整数溢出\t    // 或者也可以写成 int k = i + ((j - i) &gt;&gt; 1);\t    int k = i + (j - i) / 2;        // int k = (i + j) / 2;          if (nums[k] == target) &#123;              return k;          &#125;          if (nums[k] &gt; target) &#123;              j = k - 1;          &#125; else &#123;              i = k + 1;          &#125;      &#125;      return -1;  &#125;\n27 移除元素\n文章讲解：https://programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html\n视频讲解：https://www.bilibili.com/video/BV12A4y1Z7LP\n其实。。一开始看题目我没有反应过来暴力解法是什么。第一时间当然是想到 iterator().remove()，但是不行。老实说，那个题目里的 O(1) 额外空间我也不知道怎么算的。\n暴力解法是双层循环，删除之后的所有都前移。\n双指针和我想的也完全不一样，我也不知道我写的这个叫什么。。\npublic static int removeElement(int[] nums, int val) &#123;      int i = 0;      for (int j = 0; j &lt; nums.length; j++) &#123;\t    // 当 val == nums[j]时，只有j++\t    // 下一次不相等时，前一个指针的后一位直接指向当前的j，相当于中间的元素都被删除了。        if (val != nums[j]) &#123;              nums[i++]= nums[j];          &#125;      &#125;      return i;  &#125;\n总结\n其实都属于已经知道题解方式再去看题，加上是简单算法，所以感觉难度不是很大。（也可能我只是为了找工作，对我来说解出来就 OK）\n二分查找\n前提：\n1、有序数组\n2、数组中无重复元素\n注意：\n整数数值越界的问题\n","categories":["面试","代码随想录"],"tags":["二分查找","双指针","数组"]},{"title":"代码随想录算法训练营第二天-977有序数组的平方、209长度最小的子数组、59螺旋矩阵II","url":"/posts/d3cf0d1c/","content":"\n\n前言状态：977、209 通过。59 没有思路\n\n\n更新\n\n\n24.04.18 初始记录24.04.21 补充螺旋矩阵的题解\n\n初步题解\n977 有序数组的平方\n题目链接：https://leetcode.cn/problems/squares-of-a-sorted-array/\npublic class LE977 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          String s = scanner.nextLine();          int[] nums = Arrays.stream(s.substring(1, s.length() - 1).split(&quot;,&quot;))                  .mapToInt(Integer::parseInt)                  .toArray();          System.out.println(Arrays.toString(sortedSquares(nums)));      &#125;  \t// 关键在于非递增顺序，获取平方数，组成新的非递增序列\t// 新数组的最大数一定来自于旧数组的两端。平方的大小一定从两边向中间递减\t// 用双指针，依次将最大值添加到新数组，并向内移动    public static int[] sortedSquares(int[] nums) &#123;          int i = 0;          int j = nums.length - 1;          int k = nums.length - 1;          int[] ints = new int[nums.length];            while (i &lt;= j) &#123;              int i2 = nums[i] * nums[i];              int j2 = nums[j] * nums[j];              ints[k] = Math.max(i2, j2);              k--;              if (i2 &gt;= j2) &#123;                  i++;              &#125; else &#123;                  j--;              &#125;          &#125;        return ints;      &#125;  &#125;\n209 长度最小的子数组\n题目链接：https://leetcode.cn/problems/minimum-size-subarray-sum/\npublic class LE209 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          int target = Integer.parseInt(scanner.nextLine());          String s = scanner.nextLine();          int[] nums = Arrays.stream(s.substring(1, s.length() - 1).split(&quot;,&quot;))                  .mapToInt(Integer::parseInt)                  .toArray();          System.out.println(minSubArrayLen(target, nums));      &#125;  \t// 看题就知道是滑动窗口，前几天刚好做过    public static int minSubArrayLen(int target, int[] nums) &#123;          int min = 0;          for (int i = 0, j = 0; i &lt; nums.length &amp;&amp; j &lt; nums.length; ) &#123;              int subArraySum = getSum(nums, i, j);              if (target == subArraySum) &#123;                  min = Math.min(min, j - i + 1);                  i++;                  j = i;                  if (min == 1) &#123;                      break;                  &#125;              &#125; else if (target &lt; subArraySum) &#123;                  i++;                  j = i;              &#125; else &#123;                  j++;              &#125;          &#125;          return min;      &#125;        private static int getSum(int[] nums, int i, int j) &#123;          int sum = 0;          for (int k = i; k &lt;= j; k++) &#123;              sum += nums[k];          &#125;          return sum;      &#125;  &#125;\n59 螺旋矩阵 II\n题目链接：https://leetcode.cn/problems/spiral-matrix-ii/\n// 看了题目没有什么算法上的思路，打算直接看题解\n看讲解\n977 有序数组的平方\n文章讲解：https://programmercarl.com/0977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.html\n视频讲解： https://www.bilibili.com/video/BV1QB4y1D7ep\n// 这里的题解和我的想法差不多，就不多写了\n209 长度最小的子数组\n文章讲解：https://programmercarl.com/0209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.html\n视频讲解：https://www.bilibili.com/video/BV1tZ4y1q7XE\n还有一个进阶的解法，打算明天再看看，不能再熬夜了。\n// 这里的题解和我的想法差不多，就不多写了// 进阶部分等之后有时间了补充\n59 螺旋矩阵 II\n文章讲解：https://programmercarl.com/0059.%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II.html\n视频讲解：https://www.bilibili.com/video/BV1SL4y1N7mV/\n// 大致看了文章讲解，就是把四条边按规律读出。// 没有看答案，按讲解写了一个版本，但是很奇怪，输出的xy和我想象中的不一样// 打了断点才发现，二维数组的表现和坐标不一样。public class LE59 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          int n = Integer.parseInt(scanner.nextLine());          System.out.println(Arrays.deepToString(generateMatrix(n)));      &#125;        public static int[][] generateMatrix(int n) &#123;          int[][] ints = new int[n][n];          int startX = 0;          int startY = 0;          int k = 1;          int loop = 1;          int i, j;          // 这边需要加上边界条件        while (k &lt;= n * n &amp;&amp; loop &lt;= n / 2) &#123;              for (i = startX; i &lt; n - loop; i++) &#123;                  ints[i][startY] = k++;              &#125;              for (j = startY; j &lt; n - loop; j++) &#123;                  ints[i][j] = k++;              &#125;              for (; i &gt; startX; i--) &#123;                  ints[i][j] = k++;              &#125;              for (; j &gt; startY ; j--) &#123;                  ints[i][j] = k++;              &#125;              startX++;              startY++;              loop++;          &#125;          // 奇数矩阵需要特殊处理        if (n % 2 == 1) &#123;              ints[startX][startY] = k;          &#125;          return ints;      &#125;  &#125;// 重新按二维数组的写法写了一遍。这个需要加到总结中// 二位数组中：j才是横坐标，i是纵坐标public static int[][] generateMatrix(int n) &#123;      int[][] ints = new int[n][n];      int startX = 0;      int startY = 0;      int k = 1;      int loop = 1;      int i, j;        while (k &lt;= n * n &amp;&amp; loop &lt;= n / 2) &#123;          for (j = startY; j &lt; n - loop; j++) &#123;              ints[startX][j] = k++;          &#125;          for (i = startX; i &lt; n - loop; i++) &#123;              ints[i][j] = k++;          &#125;          for (; j &gt; startY ; j--) &#123;              ints[i][j] = k++;          &#125;          for (; i &gt; startX; i--) &#123;              ints[i][j] = k++;          &#125;          startX++;          startY++;          loop++;      &#125;      if (n % 2 == 1) &#123;          ints[startX][startY] = k;      &#125;      return ints;  &#125;\n","categories":["面试","代码随想录"],"tags":["双指针","数组","滑动窗口","螺旋数组"]},{"title":"代码随想录算法训练营第三天-203移除链表元素、707设计链表、206反转链表","url":"/posts/a242ea05/","content":"\n\n前言状态：链表定义有点不会，基本上是都是看了一半图解后写出来的，而且耗时比较长，可能二刷会好一点吧。\n\n\n更新\n\n\n24.04.24 初始记录24.05.15 完成题目\n\n初步题解\n203 移除链表元素\n题目链接：https://leetcode.cn/problems/remove-linked-list-elements/description/\n刚开始看到有点懵，习惯了写输入输出，这里不知道怎么输入了。链表这块需要先初始化链表。没有写出来后面是查看了解析。\n在具体方法那里，一直尝试只用一个链表做操作，但是运行总是得不到想要的结果。\npublic class LE203 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          String s = scanner.nextLine();          if (&quot;&quot;.equals(s.trim())) &#123;              System.out.println(new LinkedList());              return;          &#125;          List&lt;Integer&gt; head = Arrays.stream(s.split(&quot;,&quot;)).map(Integer::parseInt).collect(Collectors.toList());          int val = Integer.parseInt(scanner.nextLine());            // 初始化链表          LinkedList linkedList = new LinkedList();          for (Integer integer : head) &#123;              linkedList.add(integer);          &#125;              ListNode listNode = removeElements(linkedList.head, val);          System.out.println(listNode);      &#125;  \t// 一开始只能写成这个样子    public static ListNode removeElements(ListNode head, int val) &#123;  \t\twhile (head != null &amp;&amp; head.val == val) &#123;  \t\t    head = head.next;  \t\t&#125;  \t\t  \t\tif (head == null) &#123;  \t\t    return head;  \t\t&#125;    &#125;        /**       * 链表的定义       */      public static class ListNode &#123;          int val;          ListNode next;            ListNode() &#123;          &#125;            ListNode(int val) &#123;              this.val = val;          &#125;            ListNode(int val, ListNode next) &#123;              this.val = val;              this.next = next;          &#125;      &#125;        public static class LinkedList &#123;          private ListNode head;            public ListNode getHead() &#123;              return head;          &#125;            public void setHead(ListNode head) &#123;              this.head = head;          &#125;            public ListNode getCurrent() &#123;              return current;          &#125;            public void setCurrent(ListNode current) &#123;              this.current = current;          &#125;            private ListNode current;            public void add(int val) &#123;              if (head == null) &#123;                  head = new ListNode(val);                  current = head;              &#125; else &#123;                  current.next = new ListNode(val);                  current = current.next;              &#125;          &#125;      &#125;  &#125;\n707 设计链表\n题目链接：https://leetcode.cn/problems/design-linked-list/description/\n修修改改了很久才通过，要考虑头节点，尾节点。\npublic class LE707 &#123;      public static void main(String[] args) &#123;          MyLinkedList myLinkedList = new MyLinkedList();          myLinkedList.addAtHead(1);          myLinkedList.addAtTail(3);          // 链表变为 1-&gt;2-&gt;3        myLinkedList.addAtIndex(1, 2);          // 返回 2        myLinkedList.get(1);          // 现在，链表变为 1-&gt;3        myLinkedList.deleteAtIndex(1);          // 返回 3        myLinkedList.get(1);      &#125;        public static class ListNode &#123;          private int val;          private ListNode next;            public ListNode() &#123;          &#125;            public ListNode(int val) &#123;              this.val = val;          &#125;      &#125;        public static class MyLinkedList &#123;          private int size;          private ListNode head;            public MyLinkedList() &#123;              size = 0;              head = new ListNode(0);          &#125;            public int get(int index) &#123;              if (index &lt;= -1 || index &gt;= size) &#123;                  return -1;              &#125;                ListNode indexNode = head;              for (int i = 0; i &lt; index; i++) &#123;                  indexNode = indexNode.next;              &#125;                return indexNode.val;          &#125;            public void addAtHead(int val) &#123;              if (size == 0) &#123;                  size++;                  head = new ListNode(val);                  return;              &#125;              addAtIndex(0, val);          &#125;            public void addAtTail(int val) &#123;              addAtIndex(size, val);          &#125;            public void addAtIndex(int index, int val) &#123;              if (index &gt; size) &#123;                  return;              &#125;                if (index &lt; 0) &#123;                  index = 0;              &#125;                ListNode pre = head;              // 找到前一个节点的位置              for (int i = 0; i &lt; index - 1; i++) &#123;                  pre = pre.next;              &#125;                ListNode listNode = new ListNode(val);              // 如果插入节点为头节点              if (index == 0) &#123;                  listNode.next = pre;                  head = listNode;                  // 长度++                  size++;                  return;              &#125;              // 如果插入位置正好是尾节点 直接前节点指向这个节点 然后return              if (index == size) &#123;                  pre.next = listNode;                  // 长度++                  size++;                  return;              &#125;                // 否则              // 先把当前节点的后指针指向前节点的next              listNode.next = pre.next;              // 再把前节点的后指针指向当前节点              pre.next = listNode;              // 长度++              size++;          &#125;            public void deleteAtIndex(int index) &#123;              if (index &gt;= size || index &lt; 0) &#123;                  return;              &#125;                ListNode pre = head;              for (int i = 0; i &lt; index - 1; i++) &#123;                  pre = pre.next;              &#125;              // 如果删除节点为头节点              if (index == 0) &#123;                  head = head.next;                  size--;                  return;              &#125;              // 如果删除位置正好是尾节点 直接前节点指向null 然后return              if (index + 1 == size) &#123;                  pre.next = null;                  // 长度++                  size--;                  return;              &#125;              // 改变当前节点的前节点的后指针，指向下一个节点              pre.next = pre.next.next;              // 长度--              size--;          &#125;      &#125;  &#125;\n206 反转链表\n题目链接：https://leetcode.cn/problems/reverse-linked-list/description/\n偷偷看了下视频图解，按这个思路写的代码：还是比较简单的\n\npublic static LE707.ListNode reverseList(LE707.ListNode head) &#123;      LE707.ListNode pre = null;      LE707.ListNode cur = head;      while (cur != null) &#123;          LE707.ListNode temp = cur.next;          cur.next = pre;          pre = cur;          cur = temp;      &#125;        return pre;  &#125;\n看讲解\n203 移除链表元素\n题目链接/文章讲解/视频讲解：：https://programmercarl.com/0203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html\n// 一开始没有搞懂，前面一个循环是用来干什么的。// 但是去除前面一步，执行[7,7,7,7] 7 这个用例会多出一个7public static ListNode removeElements(ListNode head, int val) &#123;      while (head != null &amp;&amp; head.val == val) &#123;          head = head.next;      &#125;        if (head == null) &#123;          return head;      &#125;        ListNode pre = head;      ListNode cur = head.next;      while (cur != null) &#123;          if (cur.val == val) &#123;              pre.next = cur.next;          &#125; else &#123;              pre = cur;          &#125;          cur = cur.next;      &#125;      return head;  &#125;\n这个题共有三种题解法：\n\n\n第一种：添加虚节点。在原先的链表前，添加一个虚拟节点，用于处理可能被删除的头节点。因为删除可能涉及到头节点，所以在方法二中，第一个循环把头节点可能需要删除的情况直接处理掉。\n\n\n第二种：不添加虚节点。用一个循环处理可能会被删除的头节点。\n\n\n第三种：不加虚节点，同时不添加 pre 节点。加上判断删除节点是否是尾节点。\n\n\n707 设计链表\n题目链接/文章讲解/视频讲解：https://programmercarl.com/0707.%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8.html\n//单链表class ListNode &#123;    int val;    ListNode next;    ListNode()&#123;&#125;    ListNode(int val) &#123;        this.val=val;    &#125;&#125;class MyLinkedList &#123;    //size存储链表元素的个数    int size;    //虚拟头结点    ListNode head;    //初始化链表    public MyLinkedList() &#123;        size = 0;        head = new ListNode(0);    &#125;    //获取第index个节点的数值，注意index是从0开始的，第0个节点就是头结点    public int get(int index) &#123;        //如果index非法，返回-1        if (index &lt; 0 || index &gt;= size) &#123;            return -1;        &#125;        ListNode currentNode = head;        //包含一个虚拟头节点，所以查找第 index+1 个节点        for (int i = 0; i &lt;= index; i++) &#123;            currentNode = currentNode.next;        &#125;        return currentNode.val;    &#125;    //在链表最前面插入一个节点，等价于在第0个元素前添加    public void addAtHead(int val) &#123;        addAtIndex(0, val);    &#125;    //在链表的最后插入一个节点，等价于在(末尾+1)个元素前添加    public void addAtTail(int val) &#123;        addAtIndex(size, val);    &#125;    // 在第 index 个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。    // 如果 index 等于链表的长度，则说明是新插入的节点为链表的尾结点    // 如果 index 大于链表的长度，则返回空    public void addAtIndex(int index, int val) &#123;        if (index &gt; size) &#123;            return;        &#125;        if (index &lt; 0) &#123;            index = 0;        &#125;        size++;        //找到要插入节点的前驱        ListNode pred = head;        for (int i = 0; i &lt; index; i++) &#123;            pred = pred.next;        &#125;        ListNode toAdd = new ListNode(val);        toAdd.next = pred.next;        pred.next = toAdd;    &#125;    //删除第index个节点    public void deleteAtIndex(int index) &#123;        if (index &lt; 0 || index &gt;= size) &#123;            return;        &#125;        size--;        if (index == 0) &#123;            head = head.next;\t    return;        &#125;        ListNode pred = head;        for (int i = 0; i &lt; index ; i++) &#123;            pred = pred.next;        &#125;        pred.next = pred.next.next;    &#125;&#125;\n参考中是直接设置了虚拟头节点解决的，代码会更加简洁。还有一种双向链表的方法，没有仔细研究。\n206 反转链表\n题目链接/文章讲解/视频讲解：https://programmercarl.com/0206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.html\n// 递归 class Solution &#123;    public ListNode reverseList(ListNode head) &#123;        return reverse(null, head);    &#125;    private ListNode reverse(ListNode prev, ListNode cur) &#123;        if (cur == null) &#123;            return prev;        &#125;        ListNode temp = null;        temp = cur.next;// 先保存下一个节点        cur.next = prev;// 反转        // 更新prev、cur位置        // prev = cur;        // cur = temp;        // 此时cur为前一个节点，temp为后一个节点。两个节点位置交换，做递归。        return reverse(cur, temp);    &#125;&#125;\n按照讲解，一开始写的是双指针方法。\nLeetCode 进阶处写了还可以使用递归解决。解法在解析中给出。\n","categories":["面试","代码随想录"],"tags":["双指针","链表","虚拟头节点"]},{"title":"代码随想录算法训练营第四天-24两两交换链表中的节点、19删除链表的倒数第N个节点、面试题02.07.链表相交、142环形链表II","url":"/posts/b46047ed/","content":"\n\n前言状态：24 需要看部分题解才能 AC，19 直接看的题解解题，面试题 02.07 可以 AC（但是还有一种解法，完全想不到），142 不会（第一次做真的有人能有思路吗🥲）\n\n\n更新\n\n\n24.05.16 初始记录24.05.22 后两题的完成\n\n初步题解\n24 两两交换链表中的节点\n题目链接：(https://leetcode.cn/problems/swap-nodes-in-pairs/description/)\n// 第一遍完全没有看题解的写法，不能通过public static LE707.ListNode swapPairs(LE707.ListNode head) &#123;      while (head.next != null) &#123;          LE707.ListNode temp = head.next.next;          head.next.next = head;          head.next = temp;          head = head.next.next;      &#125;      return head;  &#125;// 第二遍看了部分文字题解// 发现少了头节点，即前一个节点的后节点的指向那一步public static LE707.ListNode swapPairs(LE707.ListNode head) &#123;      LE707.ListNode dumyHead = new LE707.ListNode(-1);      dumyHead.next = head;        // 记录当前节点的位置，便于循环      LE707.ListNode cur = dumyHead;      while (cur.next != null &amp;&amp; cur.next.next != null) &#123;          // 记录原来，后一个节点需要指向的节点          LE707.ListNode temp = cur.next.next.next;          LE707.ListNode node2 = cur.next.next;          LE707.ListNode node1 = cur.next;          cur.next = node2;          cur.next.next = node1;          cur.next.next.next = temp;          cur = node1;      &#125;      return dumyHead.next;  &#125;\n19 删除链表的倒数第 N 个节点\n题目链接：https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/\n这道题直接看的解析。\n面试题 02.07 链表相交\n题目链接：https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/description/\n提交是可以的，但是本地跑不行，看了一下可能是本地测试的 add 方法，每次都是新建一个对象，两个链表中的对象地址是不一致的，导致 tempA == tempB 这一步始终判断失败。\n/**   * 思路：最后都会合成到一个链   * 可以把两个链按末尾对其，即较长链的指针起始与短链对齐   * @param headA headA   * @param headB headB   * @return 相交部分   */  public static LE707.ListNode getIntersectionNode(LE707.ListNode headA, LE707.ListNode headB) &#123;      int intersectVal = 0;      int skipA = 0;      int skipB = 0;        LE707.ListNode tempA = headA;      LE707.ListNode tempB = headB;        int sizeA = 0;      while (tempA != null) &#123;          sizeA++;          tempA = tempA.next;      &#125;        int sizeB = 0;      while (tempB != null) &#123;          sizeB++;          tempB = tempB.next;      &#125;        if (sizeA == 0 || sizeB == 0) &#123;          return null;      &#125;        tempA = headA;      tempB = headB;      // 尾端对其      if (sizeA &gt;= sizeB) &#123;          for (int i = 0; i &lt; (sizeA - sizeB); i++) &#123;              tempA = tempA.next;              skipA++;          &#125;      &#125; else &#123;          for (int i = 0; i &lt; (sizeB - sizeA); i++) &#123;              tempB = tempB.next;              skipB++;          &#125;      &#125;        // 不相同，指针后移      while (tempA != null) &#123;          if (tempA == tempB) &#123;              intersectVal = tempA.val;              return tempA;          &#125;          tempA = tempA.next;          tempB = tempB.next;          skipA++;          skipB++;      &#125;        return null;  &#125;\n142 环形链表 II\n题目链接：https://leetcode.cn/problems/linked-list-cycle-ii/description/\n不会，直接看的解析。\n看讲解\n24 两两交换链表中的节点\n题目链接/文章讲解/视频讲解：：https://programmercarl.com/0203.%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0.html\n这题看题解图会比较容易：\n\n看完根据这个图，总算是写出来了。\n也还有别的方法（递归）：\npublic ListNode swapPairs(ListNode head) &#123;        // base case 退出提交        if(head == null || head.next == null) return head;        // 获取当前节点的下一个节点        ListNode next = head.next;        // 进行递归        ListNode newNode = swapPairs(next.next);        // 这里进行交换        next.next = head;        head.next = newNode;        return next;    &#125;\n注：将步骤二三互换，可以不定义 temp 节点。\n19 删除链表的倒数第 N 个节点\n题目链接/文章讲解/视频讲解：https://programmercarl.com/0019.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.html\n/**   * 第一想法是获取长度，然后长度-n得到节点位置。因为节点这个初始化操作之前是写了size的   * 但是题目中是没有这个初始化操作的。   * 直接看的解析，说是用快慢双指针的方式。   */  public static LE707.ListNode removeNthFromEnd(LE707.ListNode head, int n) &#123;      // 添加一个虚拟头节点      LE707.ListNode dumyHead = new LE707.ListNode(-1);      dumyHead.next = head;        LE707.ListNode fast = dumyHead;      for (int i = 0; i &lt; n; i++) &#123;          fast = fast.next;      &#125;      LE707.ListNode slow = dumyHead;      while (fast != null &amp;&amp; fast.next != null) &#123;          fast = fast.next;          slow = slow.next;      &#125;        // 此时慢指针指向的为要删除节点的前一个节点      slow.next = slow.next.next;        return dumyHead.next;  &#125;\n步骤一：先移动快指针，快指针移动的位置与 n 相同。\n步骤二：同时移动快慢指针，当快指针下一节点的位置为 0 时，此时慢指针指向的位置为要删除的节点的前一节点。\n步骤三：删除指定节点。\n注：为了避免多处理头节点的情况，添加虚拟头节点。\n面试题 02.07 链表相交\n题目链接/文章讲解：https://programmercarl.com/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4.html\n除了初步题解那种解法，还有一种，但是不是很能看懂理解，可以说第一次完全想不到，下面是解法和图解：\nhttps://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/solutions/1190240/mian-shi-ti-0207-lian-biao-xiang-jiao-sh-b8hn/\n// 合并链表实现移动public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;\t// p1 指向 A 链表头结点，p2 指向 B 链表头结点\tListNode p1 = headA, p2 = headB;\twhile (p1 != p2) &#123;\t\t// p1 走一步，如果走到 A 链表末尾，转到 B 链表\t\tif (p1 == null) p1 = headB;\t\telse            p1 = p1.next;\t\t// p2 走一步，如果走到 B 链表末尾，转到 A 链表\t\tif (p2 == null) p2 = headA;\t\telse            p2 = p2.next;\t&#125;\treturn p1;&#125;\n142 环形链表 II\n题目链接/文章讲解/视频讲解：https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html\n\n题解思路：\n\n\n如何判断链表是否有环：首先这题使用快慢指针解法。如果无环，那么快指针到最后也不会与慢指针相遇；如果可以相遇，则说明有环。\n\n\n快指针一定先进入环形，慢指针后进入环形。当慢指针进入环形时，就变成了追击问题，由快追击慢。因为指定快指针速度为 2 个节点，慢指针为 1 个节点，相对速度为 1 个节点，因此快慢一定会在环内相遇。\n\n\n如图所示：假设相遇在点 P，入口在 start，三段路径分别如图所示，则此时 A 的行走路径为：x + n(y + z) + y，B 的行走路径为 x + y\n\n\n又因为快指针速度为满指针的两倍，所以 x + n(y + z) + y = 2(x + y)，得出 x = n(y + z) - y，等式变形为 x = (n - 1)(y + z) + z，又 n &gt;= 1。可以简化为，在相遇处，出发处各设一个指针，一起移动，两个指针一定会相遇。相遇处即为 start。\n\n\n疑难点：\nQ：为什么B的路径一定在一圈以内？\nA：关键在当慢指针进入环形时，就变成了追击问题。也就是说，快指针的追击路线一定小于一圈，即追击时间一定不够慢指针跑满一圈。\nQ：快慢指针一定会在环内相遇？\nA：因为指定快指针速度为 2 个节点，慢指针为 1 个节点，相对速度为 1 个节点，因此快慢一定会在环内相遇。（如果快指针的速度为 3，那就可能会跳过了）\npublic LE707.ListNode detectCycle(LE707.ListNode head) &#123;      LE707.ListNode fast = head;      LE707.ListNode slow = head;        while (fast!= null  &amp;&amp; fast.next != null) &#123;          fast = fast.next.next;          slow = slow.next;          // 找到相遇点          if (slow == fast) &#123;              LE707.ListNode index1 = head;              LE707.ListNode index2 = fast;              while (index1 != index2) &#123;                  index1 = index1.next;                  index2 = index2.next;              &#125;              return index1;          &#125;      &#125;      return null;  &#125;\n","categories":["面试","代码随想录"],"tags":["双指针","链表","虚拟头节点","环形链表"]},{"title":"代码随想录算法训练营第六天-454四数相加II、383赎金信、15三数之和、18四数之和","url":"/posts/27f1326/","content":"\n\n前言状态：454 和 383 可以 AC，15 超时，18 根据 15 做出，还可以进一步优化\n\n\n更新\n\n\n24.05.24 初始记录\n\n初步题解\n454 四数相加 II\n题目链接：(https://leetcode.cn/problems/4sum-ii/)\npublic class LE454 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          int[] nums1 = Arrays.stream(scanner.nextLine().split(&quot;,&quot;)).filter(Objects::nonNull).mapToInt(Integer::parseInt).toArray();          int[] nums2 = Arrays.stream(scanner.nextLine().split(&quot;,&quot;)).filter(Objects::nonNull).mapToInt(Integer::parseInt).toArray();          int[] nums3 = Arrays.stream(scanner.nextLine().split(&quot;,&quot;)).filter(Objects::nonNull).mapToInt(Integer::parseInt).toArray();          int[] nums4 = Arrays.stream(scanner.nextLine().split(&quot;,&quot;)).filter(Objects::nonNull).mapToInt(Integer::parseInt).toArray();          System.out.println(fourSumCount(nums1, nums2, nums3, nums4));      &#125;  \t// 和昨天的最后一题差不多    public static int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) &#123;          int res = 0;          HashMap&lt;Integer, Integer&gt; map = new HashMap();          for (int k : nums1) &#123;              for (int i : nums2) &#123;                  int sum = k + i;                  map.put(sum, map.getOrDefault(sum, 0) + 1);              &#125;          &#125;            for (int i : nums3) &#123;              for (int j : nums4) &#123;                  res += map.getOrDefault(-i - j, 0);              &#125;          &#125;            return res;      &#125;  &#125;\n383 赎金信\n题目链接：(https://leetcode.cn/problems/ransom-note/submissions/534463469/)\npublic class LE383 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          String ransomNote = scanner.nextLine();          String magazine = scanner.nextLine();          System.out.println(canConstruct(ransomNote, magazine));      &#125;  \t// 和242一样的思路    public static boolean canConstruct(String ransomNote, String magazine) &#123;          int[] ints = new int[26];          // 遍历存储数量          for (int i = 0; i &lt; magazine.length(); i++) &#123;              ints[magazine.charAt(i) - 97]++;          &#125;          // 遍历扣除数量          for (int i = 0; i &lt; ransomNote.length(); i++) &#123;              ints[ransomNote.charAt(i) - 97]--;          &#125;          for (int i : ints) &#123;              if (i &lt; 0) &#123;                  return false;              &#125;          &#125;          return true;      &#125;  &#125;\n15 三数之和\n题目链接：(https://leetcode.cn/problems/3sum/description/)\n暴力解法，但是这样超时了。\npublic static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;      // 判断是否重复      HashMap&lt;String, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;();        for (int i = 0; i &lt; nums.length; i++) &#123;          for (int j = i + 1; j &lt; nums.length; j++) &#123;              for (int k = j + 1; k &lt; nums.length; k++) &#123;                  if (nums[i] + nums[j] + nums[k] == 0) &#123;                      List&lt;Integer&gt; list = new ArrayList&lt;&gt;();                      list.add(nums[i]);                      list.add(nums[j]);                      list.add(nums[k]);                      list.sort(Integer::compareTo);                      map.put(list.stream().map(integer -&gt; integer + &quot;&quot;).collect(Collectors.joining(&quot;,&quot;)), list);                  &#125;              &#125;          &#125;      &#125;      List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();      for (Map.Entry&lt;String, List&lt;Integer&gt;&gt; stringListEntry : map.entrySet()) &#123;          list.add(stringListEntry.getValue());      &#125;      return list;  &#125;\n看了部分解析改用双指针，可以通过，但是比较慢。而且费时\npublic static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;      nums = Arrays.stream(nums).sorted().toArray();      ArrayList&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();      // 递增序列，前三位和大于0，直接返回      if (nums[0] + nums[1] + nums[2] &gt; 0) &#123;          return list;      &#125;        int i = 0;      int j = i + 1;      int k = nums.length - 1;      while (i &lt; j &amp;&amp; j &lt; k) &#123;          System.out.println(i + &quot; &quot; + j + &quot; &quot; + k);          int sum = nums[i] + nums[j] + nums[k];          if (sum == 0) &#123;              list.add(Arrays.asList(nums[i], nums[j], nums[k]));              j++;          &#125; else if (sum &lt; 0) &#123;              j++;          &#125; else &#123;              k--;          &#125;          while (j &gt; i + 1 &amp;&amp; j &lt;= nums.length - 1 &amp;&amp; nums[j] == nums[j - 1]) &#123;              j++;          &#125;          while (k &gt; j &amp;&amp; k != nums.length - 1 &amp;&amp; nums[k] == nums[k + 1]) &#123;              k--;          &#125;          if (j &gt;= k) &#123;              i = i + 1;              while (i != 0 &amp;&amp; i &lt;= nums.length - 1 &amp;&amp; nums[i] == nums[i - 1]) &#123;                  i++;              &#125;              j = i + 1;              k = nums.length - 1;          &#125;      &#125;      return list;  &#125;\n18 四数之和\n题目链接：(https://leetcode.cn/problems/4sum/description/)\n看到题目，就觉得是 15 的进阶版，按照上一题的思路写了一下\npublic static List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123;      Arrays.sort(nums);        ArrayList&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();      for (int i = 0; i &lt; nums.length; i++) &#123;          if (i != 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;              continue;          &#125;            for (int j = i + 1; j &lt; nums.length; j++) &#123;              if (j != i + 1 &amp;&amp; nums[j] == nums[j - 1]) &#123;                  continue;              &#125;                int left = j + 1;              int right = nums.length - 1;              while (left &lt; right) &#123;                  long sum = (long) nums[i] + (long) nums[j] + (long) nums[left] + (long) nums[right];                  if (sum &lt; target) &#123;                      left++;                  &#125; else if (sum &gt; target) &#123;                      right--;                  &#125; else &#123;                      list.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));                      while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) &#123;                          left++;                      &#125;                      while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) &#123;                          right--;                      &#125;                      left++;                      right--;                  &#125;              &#125;          &#125;      &#125;      return list;  &#125;\n看讲解\n454 四数相加 II\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0454.四数相加II.html)\n383 赎金信\n题目链接/文章讲解：(https://programmercarl.com/0383.赎金信.html)\n15 三数之和\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0015.三数之和.html)\n确实用 for 循环更好理解。题解的思路更加清晰，而且更快。\npublic static List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;      List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();      Arrays.sort(nums);      for (int i = 0; i &lt; nums.length; i++) &#123;          // 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了          if (nums[i] &gt; 0) &#123;              return result;          &#125;            /**           * 只能是与前一个比较进行去重           */          if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;              continue;          &#125;            int left = i + 1;          int right = nums.length - 1;          while (right &gt; left) &#123;              int sum = nums[i] + nums[left] + nums[right];              if (sum &gt; 0) &#123;                  right--;              &#125; else if (sum &lt; 0) &#123;                  left++;              &#125; else &#123;                  result.add(Arrays.asList(nums[i], nums[left], nums[right]));                  /**                   * 去重逻辑应该放在找到一个三元组之后                   * 否则获取不到结果集                   */                  while (right &gt; left &amp;&amp; nums[right] == nums[right - 1]) &#123;                      right--;                  &#125;                  while (right &gt; left &amp;&amp; nums[left] == nums[left + 1]) &#123;                      left++;                  &#125;                    right--;                  left++;              &#125;          &#125;      &#125;      return result;  &#125;\n18 四数之和\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0018.四数之和.html)\n看了解析。加上剪枝操作。\npublic static List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123;      Arrays.sort(nums);        ArrayList&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();      for (int i = 0; i &lt; nums.length; i++) &#123;          // nums[i] &gt; target 直接返回, 剪枝操作          if (nums[i] &gt; 0 &amp;&amp; nums[i] &gt; target) &#123;              return list;          &#125;            for (int j = i + 1; j &lt; nums.length; j++) &#123; \t        // 二级剪枝            if (nums[i] + nums[j] &gt; 0 &amp;&amp; nums[i] + nums[j] &gt; target) &#123;                  break;              &#125;                if (j != i + 1 &amp;&amp; nums[j] == nums[j - 1]) &#123;                  continue;              &#125;                int left = j + 1;              int right = nums.length - 1;              while (left &lt; right) &#123;                  long sum = (long) nums[i] + (long) nums[j] + (long) nums[left] + (long) nums[right];                  if (sum &lt; target) &#123;                      left++;                  &#125; else if (sum &gt; target) &#123;                      right--;                  &#125; else &#123;                      list.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));                      while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) &#123;                          left++;                      &#125;                      while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) &#123;                          right--;                      &#125;                      left++;                      right--;                  &#125;              &#125;          &#125;      &#125;      return list;  &#125;\n","categories":["面试","代码随想录"],"tags":["双指针","哈希表"]},{"title":"代码随想录算法训练营第五天-242有效的字母异位词、349两个数组的交集、202快乐数、1两数之和","url":"/posts/bed5d8f6/","content":"\n\n前言状态：全部可以 AC。看了解析之后，242、202 可再优化。\n\n\n更新\n\n\n24.05.23 初始记录\n\n初步题解\n242 有效的字母异位词\n题目链接：(https://leetcode.cn/problems/valid-anagram/description/)\npublic class LE242 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          String s = scanner.nextLine();          String t = scanner.nextLine();          System.out.println(isAnagram(s, t));      &#125;        /**       * 思路：       * 1.用map接收每个字符出现的次数       * 2.比较次数是否相同       */      public static boolean isAnagram(String s, String t) &#123;          char[] charsS = s.toCharArray();          char[] charsT = t.toCharArray();            HashMap&lt;String, Integer&gt; numMapS = getNumMap(charsS);          HashMap&lt;String, Integer&gt; numMapT = getNumMap(charsT);            if (numMapS.size() != numMapT.size()) &#123;              return false;          &#125;          for (String key : numMapS.keySet()) &#123;              if (!numMapS.get(key).equals(numMapT.get(key))) &#123;                  return false;              &#125;          &#125;          return true;      &#125;        /**       * 获取每个字符的数量       * @param charsS 字符串       * @return 每个字符的数量       */      private static HashMap&lt;String, Integer&gt; getNumMap(char[] charsS) &#123;          HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;();          for (char c : charsS) &#123;              if (map.containsKey(String.valueOf(c))) &#123;                  map.put(String.valueOf(c) , map.get(String.valueOf(c)) + 1);              &#125; else &#123;                  map.put(String.valueOf(c), 1);              &#125;          &#125;          return map;      &#125;  &#125;\n349 两个数组的交集\n题目链接：(https://leetcode.cn/problems/intersection-of-two-arrays/description/)\npublic class LE349 &#123;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        int[] nums1 = Arrays.stream(scanner.nextLine().split(&quot;,&quot;)).filter(Objects::nonNull).mapToInt(Integer::parseInt).toArray();        int[] nums2 = Arrays.stream(scanner.nextLine().split(&quot;,&quot;)).filter(Objects::nonNull).mapToInt(Integer::parseInt).toArray();        int[] intersection = intersection(nums1, nums2);    &#125;    public static int[] intersection(int[] nums1, int[] nums2) &#123;        HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;();        HashSet&lt;Integer&gt; intersection = new HashSet&lt;&gt;();        for (int i : nums1) &#123;            set.add(i);        &#125;        for (int i : nums2) &#123;            if (set.contains(i)) &#123;                intersection.add(i);            &#125;        &#125;        return intersection.stream().filter(Objects::nonNull).mapToInt(i -&gt; i).toArray();    &#125;&#125;\n202 快乐数\n题目链接：(https://leetcode.cn/problems/happy-number/description/)\npublic class LE202 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          String s = scanner.nextLine();          System.out.println(isHappy(Integer.parseInt(s)));      &#125;        /**       * 思路：放到set中，重复或者为1，跳出循环       * @param n 数       * @return 是否是快乐数       */      public static boolean isHappy(int n) &#123;          HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;();          String num = n + &quot;&quot;;          set.add(n);          while (true) &#123;              int sum = 0;              for (int i = 0; i &lt; num.length(); i++) &#123;                  sum += Math.pow(Integer.parseInt(num.charAt(i) + &quot;&quot;), 2);              &#125;                if (sum == 1) &#123;                  return true;              &#125;                if (set.contains(sum)) &#123;                  return false;              &#125;              num = sum + &quot;&quot;;              set.add(sum);          &#125;      &#125;  &#125;\n1 两数之和\n题目链接：(https://leetcode.cn/problems/two-sum/)\npublic class LE1 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          int[] nums = Arrays.stream(scanner.nextLine().split(&quot;,&quot;)).filter(Objects::nonNull).mapToInt(Integer::parseInt).toArray();          int target = Integer.parseInt(scanner.next());          twoSum(nums, target);      &#125;        /**       * 暴力解法肯定是循环两遍       * 但是这题放在哈希表专题里，就应该哈希表也能解决       * 用值为key，下标为value放入map       */         public static int[] twoSum(int[] nums, int target) &#123;          HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();          for (int i = 0; i &lt; nums.length; i++) &#123;              if (map.containsKey(target - nums[i])) &#123;                  return new int[]&#123;map.get(target - nums[i]), i&#125;;              &#125;              map.put(nums[i], i);          &#125;            return null;      &#125;  &#125;\n看讲解\n242 有效的字母异位词\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0242.有效的字母异位词.html)\n/**   * 优化：   * 改为定义数组去接收数值（其实和map是一样的思想，但是这样代码量更少）   * 改为第二次遍历，在原数组上直接--（空间用得更少了）   */  public static boolean isAnagram1(String s, String t) &#123;      int[] record = new int[26];        for (int i = 0; i &lt; s.length(); i++) &#123;          record[s.charAt(i) - &#x27;a&#x27;]++;      &#125;        for (int i = 0; i &lt; t.length(); i++) &#123;          record[t.charAt(i) - &#x27;a&#x27;]--;      &#125;        for (int count : record) &#123;          if (count != 0) &#123;              return false;          &#125;      &#125;      return true;  &#125;\n349 两个数组的交集\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0349.两个数组的交集.html)\n202 快乐数\n题目链接/文章讲解：(https://programmercarl.com/0202.快乐数.html)\n// 可以再优化，一个数各个位数平方求和while (n &gt; 0) &#123;      int temp = n % 10;      sum += temp * temp;      n = n / 10;  &#125;\n1 两数之和\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0001.两数之和.html)\n","categories":["面试","代码随想录"],"tags":["哈希表"]},{"title":"代码随想录算法训练营第七天-344反转字符串、541反转字符串II、卡码网54替换数字、151翻转字符串里的单词、卡码网55右旋转字符串","url":"/posts/b80d2810/","content":"\n\n前言状态：都是可以写出来的。但是有些与参考种给出的解析思路不同。\n\n\n更新\n\n\n24.05.27 初始记录\n\n初步题解\n344 反转字符串\n题目链接：(https://leetcode.cn/problems/reverse-string/description/)\npublic class LE344 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          reverseString(scanner.nextLine().toCharArray());      &#125;        public static void reverseString(char[] s) &#123;          for (int i = 0, j = s.length - 1; i &lt;= j; i++, j--) &#123;              char temp = s[i];              s[i] = s[j];              s[j] = temp;          &#125;          System.out.println(Arrays.toString(s));      &#125;  &#125;\n541 反转字符串 II\n题目链接：(https://leetcode.cn/problems/reverse-string-ii/description/)\npublic class LE541 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          System.out.println(reverseStr(scanner.nextLine(), Integer.parseInt(scanner.nextLine())));      &#125;        /**       * 画图翻译了一下       * 大概意思就是奇数段反转       */      public static String reverseStr(String s, int k) &#123;          // 判断能拆分成几段          int size = s.length() / k;          if (s.length() % k != 0) &#123;              size = size + 1;          &#125;            StringBuilder reverseStr = new StringBuilder();          for (int i = 1; i &lt;= size; i++) &#123;              String substring = s.substring((i - 1) * k, Math.min(i * k, s.length()));              if (i % 2 != 0) &#123;                  char[] chars = substring.toCharArray();                  for (int n = 0, m = chars.length - 1; n &lt;= m; n++, m--) &#123;                      char temp = chars[n];                      chars[n] = chars[m];                      chars[m] = temp;                  &#125;                  reverseStr.append(chars);              &#125; else &#123;                  reverseStr.append(substring);              &#125;          &#125;            return reverseStr.toString();      &#125;  &#125;\n卡码网 54 替换数字\n题目链接：(https://kamacoder.com/problempage.php?pid=1064)\npublic class CM54 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          System.out.println(replaceNumber(scanner.nextLine()));      &#125;        public static String replaceNumber(String s) &#123;          StringBuilder stringBuilder = new StringBuilder();          char[] chars = s.toCharArray();          for (char c : chars) &#123;              if (&#x27;0&#x27; &lt;= c &amp;&amp; &#x27;9&#x27; &gt;= c) &#123;                  stringBuilder.append(&quot;number&quot;);              &#125; else &#123;                  stringBuilder.append(c);              &#125;          &#125;          return stringBuilder.toString();      &#125;  &#125;\n151 翻转字符串里的单词\n题目链接：(https://leetcode.cn/problems/reverse-words-in-a-string/description/)\npublic static void main(String[] args) &#123;      Scanner scanner = new Scanner(System.in);      System.out.println(reverseWords(scanner.nextLine()));  &#125;    private static String reverseWords(String s) &#123;      String[] split = s.trim().split(&quot; &quot;);      StringBuilder stringBuilder = new StringBuilder();      for (int i = split.length - 1; i &gt;= 0; i--) &#123;          String trim = split[i].trim();          if (&quot;&quot;.equals(trim)) &#123;              continue;          &#125;          stringBuilder.append(trim).append(&quot; &quot;);      &#125;        return stringBuilder.toString().trim();  &#125;\n卡码网 55 右旋转字符串\n题目链接：(https://kamacoder.com/problempage.php?pid=1065)\npublic class CM55 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          int k = Integer.parseInt(scanner.nextLine());          String s = scanner.nextLine();          System.out.println(rightString(k, s));      &#125;        private static String rightString(int k, String s) &#123;          // 过界判断          if (k &gt;= s.length() || k &lt;= 0) &#123;              return s;          &#125;            return s.substring(s.length() - k) + s.substring(0, s.length() - k);      &#125;  &#125;\n看讲解\n344 反转字符串\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0344.反转字符串.html)\n541 反转字符串 II\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0541.反转字符串II.html)\n卡码网 54 替换数字\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/kamacoder/0054.替换数字.html)\n根据讲解，这题本意是先扩充再分配。要用到双指针的方法。\npublic class Main &#123;    public static String replaceNumber(String s) &#123;        int count = 0; // 统计数字的个数        int sOldSize = s.length();        for (int i = 0; i &lt; s.length(); i++) &#123;            if(Character.isDigit(s.charAt(i)))&#123;                count++;            &#125;        &#125;        // 扩充字符串s的大小，也就是每个空格替换成&quot;number&quot;之后的大小        char[] newS = new char[s.length() + count * 5];        int sNewSize = newS.length;        // 将旧字符串的内容填入新数组        System.arraycopy(s.toCharArray(), 0, newS, 0, sOldSize);        // 从后先前将空格替换为&quot;number&quot;        for (int i = sNewSize - 1, j = sOldSize - 1; j &lt; i; j--, i--) &#123;            if (!Character.isDigit(newS[j])) &#123;                newS[i] = newS[j];            &#125; else &#123;                newS[i] = &#x27;r&#x27;;                newS[i - 1] = &#x27;e&#x27;;                newS[i - 2] = &#x27;b&#x27;;                newS[i - 3] = &#x27;m&#x27;;                newS[i - 4] = &#x27;u&#x27;;                newS[i - 5] = &#x27;n&#x27;;                i -= 5;            &#125;        &#125;        return new String(newS);    &#125;;    public static void main(String[] args) &#123;        Scanner scanner = new Scanner(System.in);        String s = scanner.next();        System.out.println(replaceNumber(s));        scanner.close();    &#125;&#125;\n151 翻转字符串里的单词\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0151.翻转字符串里的单词.html)\n这题。。。Java 不好像没有办法空间复杂度为 O(n)。（面试的话，不太清楚会不会这么细，平时可能就直接 API 搞定了。。。一般机考也不会考这个吧😶‍🌫️）\n只能说思路很重要：\n\n\n移除多余空格（）\n\n\n将整个字符串反转\n\n\n将每个单词反转\n\n\npublic class LE151 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          System.out.println(reverseWords(scanner.nextLine()));      &#125;        /**       * 本题考察点应该和上一题一样       * 步骤如下:       * 1.移除字符串中的空格       * 2.倒序       * 3.每个单词再反转       * 要求：不使用任何内置API       */    public static String reverseWords(String s) &#123;          String removeSpace = removeSpace(s);          System.out.println(removeSpace);          return reverseWord(removeSpace);      &#125;        /**       * 单个单词倒置       */      private static String reverseWord(String s) &#123;          String[] list = s.split(&quot; &quot;);          if (list.length &lt;= 0) &#123;              return &quot;&quot;;          &#125;          StringBuilder stringBuilder = new StringBuilder();          for (String s1 : list) &#123;              char[] chars = s1.toCharArray();              for (int i = 0, j = chars.length - 1; i &lt;= j; i++, j--) &#123;                  char temp = chars[i];                  chars[i] = chars[j];                  chars[j] = temp;              &#125;              stringBuilder.append(chars).append(&quot; &quot;);          &#125;          return stringBuilder.substring(0, stringBuilder.length() - 1);      &#125;        /**       * 去除字符串中的多余空格       * 并进行倒序       */      private static String removeSpace(String s) &#123;          char[] chars = s.toCharArray();          int start = 0;          int end = s.length() - 1;          while (s.charAt(start) == &#x27; &#x27;) &#123;              start++;          &#125;          while (s.charAt(end) == &#x27; &#x27;) &#123;              end--;          &#125;          if (start &gt; end) &#123;              return &quot;&quot;;          &#125;          StringBuilder stringBuilder = new StringBuilder();          for (int i = end; i &gt;= start; i--) &#123;              if (chars[i] == &#x27; &#x27; &amp;&amp; chars[i - 1] == &#x27; &#x27;) &#123;                  continue;              &#125;              stringBuilder.append(chars[i]);          &#125;          return stringBuilder.toString();      &#125;    &#125;\n卡码网 55 右旋转字符串\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/kama55.右旋字符串.html)\n这题也是。。。反正直接用 API 了，看了说《剑指 Offer》有差不多的题目。\n没有再写一遍，直接抄了解析中的写法。\npublic class Main &#123;    public static void main(String[] args) &#123;        Scanner in = new Scanner(System.in);        int n = Integer.parseInt(in.nextLine());        String s = in.nextLine();        int len = s.length();  //获取字符串长度        char[] chars = s.toCharArray();        reverseString(chars, 0, len - 1);  //反转整个字符串        reverseString(chars, 0, n - 1);  //反转前一段字符串，此时的字符串首尾尾是0,n - 1        reverseString(chars, n, len - 1);  //反转后一段字符串，此时的字符串首尾尾是n,len - 1                System.out.println(chars);    &#125;    public static void reverseString(char[] ch, int start, int end) &#123;        //异或法反转字符串，参照题目 344.反转字符串的解释        while (start &lt; end) &#123;            ch[start] ^= ch[end];            ch[end] ^= ch[start];            ch[start] ^= ch[end];            start++;            end--;        &#125;    &#125;&#125;\n","categories":["面试","代码随想录"],"tags":["双指针","反转","字符串"]},{"title":"代码随想录算法训练营第九天-232用栈实现队列、225用队列实现栈","url":"/posts/64880820/","content":"\n\n前言状态：都是直接看的解析，不是很难。\n\n\n更新\n\n\n24.05.30 初始记录\n\n初步题解\n232 用栈实现队列\n题目链接：(https://leetcode.cn/problems/implement-queue-using-stacks/description/)\npublic class LE232 &#123;      public static void main(String[] args) &#123;          MyQueue queue = new MyQueue();          queue.push(1);          queue.push(2);          System.out.println(&quot;queue.peek() = &quot; + queue.peek());          System.out.println(&quot;queue.pop() = &quot; + queue.pop());          System.out.println(&quot;queue.empty() = &quot; + queue.empty());      &#125;        static class MyQueue &#123;          Stack&lt;Integer&gt; stackIn;          Stack&lt;Integer&gt; stackOut;            public MyQueue() &#123;              stackIn = new Stack&lt;&gt;();              stackOut = new Stack&lt;&gt;();          &#125;            public void push(int x) &#123;              stackIn.push(x);          &#125;            public int pop() &#123;              // 把in的内容复制到out              in2out();              return stackOut.pop();          &#125;            private void in2out() &#123;              if (stackOut.isEmpty()) &#123;                  while (!stackIn.isEmpty()) &#123;                      stackOut.push(stackIn.pop());                  &#125;              &#125;          &#125;            /**           * 返回列表开头的数据           * @return 结果           */          public int peek() &#123;              // 把in的内容复制到out              in2out();              return stackOut.peek();          &#125;            public boolean empty() &#123;              return stackIn.empty() &amp;&amp; stackOut.empty();          &#125;      &#125;  &#125;\n225 用队列实现栈\n题目链接：(https://leetcode.cn/problems/implement-queue-using-stacks/description/)\npublic class LE225 &#123;      public static void main(String[] args) &#123;          MyStack myStack = new MyStack();          myStack.push(1);          myStack.push(2);          System.out.println(&quot;myStack.top() = &quot; + myStack.top());          System.out.println(&quot;myStack.pop() = &quot; + myStack.pop());          System.out.println(&quot;myStack.empty() = &quot; + myStack.empty());      &#125;        static class MyStack &#123;          Queue&lt;Integer&gt; queue;            public MyStack() &#123;              queue = new LinkedList&lt;&gt;();          &#125;            public void push(int x) &#123;              queue.offer(x);              int size = queue.size() - 1;              while (size != 0) &#123;                  size--;                  queue.offer(queue.poll());              &#125;          &#125;            public int pop() &#123;              return queue.poll();          &#125;            public int top() &#123;              return queue.peek();          &#125;            /**           * 判断是否为空           */          public boolean empty() &#123;              return queue.isEmpty();          &#125;      &#125;  &#125;\n看讲解\n232 用栈实现队列\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0232.用栈实现队列.html)\n思路：用栈模拟队列需要两个栈。一个栈作为入栈，一个栈作为出栈。如果出栈为空，将入栈中的元素压入出栈。\n\n225 用队列实现栈\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0225.用队列实现栈.html)\n思路：用队列模拟栈，可以只用一个队列。每当有新元素入队列，将原有的旧元素重新入队列，这样新元素就变成栈顶元素。（一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时再去弹出元素就是栈的顺序了。）\n\n","categories":["面试","代码随想录"],"tags":["栈","队列"]},{"title":"代码随想录算法训练营第十天-20有效的括号、1047删除字符串中的所有相邻重复项、150逆波兰表达式求值","url":"/posts/d079314e/","content":"\n\n前言状态：20AC，1047AC，150AC\n\n\n更新\n\n\n24.05.30 初始记录\n\n初步题解\n20 有效的括号\n题目链接：(https://leetcode.cn/problems/valid-parentheses/description/)\npublic class LE20 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          System.out.println(isValid(scanner.nextLine()));      &#125;        public static boolean isValid(String s) &#123;          Stack&lt;Character&gt; stack = new Stack&lt;&gt;();          for (char c : s.toCharArray()) &#123;              if (c == &#x27;(&#x27; || c == &#x27;[&#x27; || c == &#x27;&#123;&#x27;) &#123;                  stack.push(c);                  continue;              &#125;              if (stack.isEmpty()) &#123;                  return false;              &#125;              Character pop = stack.pop();              if ((c == &#x27;)&#x27; &amp;&amp; pop != &#x27;(&#x27; ) || (c == &#x27;]&#x27; &amp;&amp; pop != &#x27;[&#x27; ) || (c == &#x27;&#125;&#x27; &amp;&amp; pop != &#x27;&#123;&#x27; )) &#123;                  return false;              &#125;          &#125;          return stack.isEmpty();      &#125;  &#125;\n1047 删除字符串中的所有相邻重复项\n题目链接：(https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/)\npublic static void main(String[] args) &#123;      Scanner scanner = new Scanner(System.in);      System.out.println(removeDuplicates(scanner.nextLine()));  &#125;    public static String removeDuplicates(String s) &#123;      Stack&lt;Character&gt; stack = new Stack&lt;&gt;();      for (char c : s.toCharArray()) &#123;          if (stack.isEmpty()) &#123;              stack.push(c);              continue;          &#125;          if (c == stack.peek()) &#123;              stack.pop();          &#125; else &#123;              stack.push(c);          &#125;      &#125;        StringBuilder str = new StringBuilder();      int size = stack.size();      for (int i = 0; i &lt; size; i++) &#123;          str.insert(0, stack.pop());      &#125;      return str.toString();  &#125;\n150 逆波兰表达式求值\n题目链接：(https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/)\n可以直接根据题目中给的链接查看 逆波兰表示法 的意思\npublic int evalRPN(String[] tokens) &#123;      Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();      int num = Integer.parseInt(tokens[0]);      for (String token : tokens) &#123;          switch (token) &#123;              case &quot;+&quot;: &#123;                  num = stack.pop() + stack.pop();                  stack.push(num);                  break;              &#125;              case &quot;-&quot;: &#123;                  Integer num2 = stack.pop();                  Integer num1 = stack.pop();                  num = num1 - num2;                  stack.push(num);                  break;              &#125;              case &quot;*&quot;: &#123;                  num = stack.pop() * stack.pop();                  stack.push(num);                  break;              &#125;              case &quot;/&quot;: &#123;                  Integer num2 = stack.pop();                  Integer num1 = stack.pop();                  num = num1 / num2;                  stack.push(num);                  break;              &#125;              default: &#123;                  stack.push(Integer.parseInt(token));              &#125;          &#125;      &#125;      return num;  &#125;\n看解析\n20 有效的括号\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0020.有效的括号.html)\n1047 删除字符串中的所有相邻重复项\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/1047.删除字符串中的所有相邻重复项.html)\n150 逆波兰表达式求值\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0150.逆波兰表达式求值.html)\n","categories":["面试","代码随想录"],"tags":["栈"]},{"title":"代码随想录算法训练营第十一天-239滑动窗口最大值、347前 K 个高频元素","url":"/posts/e45cf8/","content":"\n\n前言状态：239 超时，347 直接用的 Stream 流。\n\n\n更新\n\n\n24.05.31 初始记录24.06.01 完成题目\n\n初步题解\n239 滑动窗口最大值\n题目链接：(https://leetcode.cn/problems/sliding-window-maximum/description/)\n暴力解法：循环判断最大值（超时）\npublic class LE239 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          String s = scanner.nextLine();          int[] split = Arrays.stream(s.split(&quot;,&quot;)).mapToInt(Integer::parseInt).toArray();          int[] ints = maxSlidingWindow(split, Integer.parseInt(scanner.nextLine()));          for (int anInt : ints) &#123;              System.out.println(anInt);          &#125;      &#125;        public static int[] maxSlidingWindow(int[] nums, int k) &#123;          if (nums.length &lt;= k) &#123;              return new int[]&#123;getMax(nums, 0, nums.length - 1)&#125;;          &#125;            ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();          for (int i = 0; i &lt;= nums.length - k; i++) &#123;              int max = getMax(nums, i, i + k - 1);              list.add(max);          &#125;          return list.stream().mapToInt(i -&gt; i).toArray();      &#125;        private static int getMax(int[] nums, int i, int j) &#123;          int max = Integer.MIN_VALUE;          for (int k = i; k &lt;= j; k++) &#123;              max = Math.max(max, nums[k]);          &#125;          return max;      &#125;  &#125;\n347 前 K 个高频元素\n题目链接：(https://leetcode.cn/problems/top-k-frequent-elements/description/)\n直接用 Stream 流的解法，估计上班会用这个。。。甚至可以优化成一行\npublic static int[] topKFrequent(int[] nums, int k) &#123;      // map用于计数      TreeMap&lt;Integer, Integer&gt; map = new TreeMap&lt;&gt;();      for (int num : nums) &#123;          map.put(num, map.getOrDefault(num, 0) + 1);      &#125;        return map.entrySet().stream()              .sorted((o1, o2) -&gt; o2.getValue() - o1.getValue())              .limit(k)              .map(Map.Entry::getKey)              .mapToInt(i -&gt; i)              .toArray();  &#125;\n看解析\n239 滑动窗口最大值\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0239.滑动窗口最大值.html#思路)\n\n思路：这题放在队列专题，肯定是要用到队列思想的。按暴力的解法，求最大值的那个循环（这样效率就是 O(n * k)），在这边可以用单调队列解决。\n其实队列没有必要维护窗口里的所有元素，只需要维护有可能成为窗口里最大值的元素就可以了，同时保证队列里的元素数值是由大到小的。\n那么这个维护元素单调递减的队列就叫做单调队列，即单调递减或单调递增的队列。Java 中没有直接支持单调队列，需要我们自己来实现一个单调队列\n\n设计单调队列的时候，pop，和 push 操作要保持如下规则：\n\n\npop(value)：如果窗口移除的元素 value 等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作\n\n\npush(value)：如果 push 的元素 value 大于入口元素的数值，那么就将队列入口的元素弹出，直到 push 元素的数值小于等于队列入口元素的数值为止（所以这里要用 while）\n\n\n保持如上规则，每次窗口移动的时候，只要问 que.peek() 就可以返回当前窗口的最大值。\n/**   * 定义一个单调队列   */  static class MyQueue &#123;      Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();        public void push(int num) &#123;          while (!deque.isEmpty() &amp;&amp; num &gt; deque.getLast()) &#123;              deque.removeLast();          &#125;          deque.add(num);      &#125;        /**       * 判断队顶元素是否是要移除的元素       */      public void pull(int num) &#123;          if (!deque.isEmpty() &amp;&amp; deque.peek() == num) &#123;              deque.poll();          &#125;      &#125;        public int peek() &#123;          return deque.peek();      &#125;  &#125;    public static int[] maxSlidingWindow(int[] nums, int k) &#123;      MyQueue myQueue = new MyQueue();      for (int i = 0; i &lt; k; i++) &#123;          myQueue.push(nums[i]);      &#125;        int j = 0;      int[] ints = new int[nums.length - k + 1];      ints[j++] = myQueue.peek();      for (int i = k; i &lt;nums.length; i++) &#123;          // 窗口滑动，移除元素（移除时要判断元素是否在单调队列内）          myQueue.pull(nums[i - k]);          // 窗口滑动，添加最新元素到单调队列          myQueue.push(nums[i]);          // 获取单调队列队顶元素（根据定义的规则，一定是区间内最大的）          ints[j++] = myQueue.peek();      &#125;      return ints;  &#125;\n347 前 K 个高频元素\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0347.前K个高频元素.html)\n这题属于：前 K 个大数问题。这种问题一般用大顶堆（根节点最大）或小顶堆（根节点最小）。需要使用小顶堆，因为要统计最大前 k 个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前 k 个最大元素。\nemmmmm 感觉和 Stream 流没有什么区别（可能在于他用的容器吧）。\n/*Comparator接口说明: * 返回负数，形参中第一个参数排在前面；返回正数，形参中第二个参数排在前面 * 对于队列：排在前面意味着往队头靠 * 对于堆（使用PriorityQueue实现）：从队头到队尾按从小到大排就是最小堆（小顶堆）， *                                从队头到队尾按从大到小排就是最大堆（大顶堆）---&gt;队头元素相当于堆的根节点 * */class Solution &#123;    //解法1：基于大顶堆实现    public int[] topKFrequent1(int[] nums, int k) &#123;        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); //key为数组元素值,val为对应出现次数        for (int num : nums) &#123;            map.put(num, map.getOrDefault(num,0) + 1);        &#125;        //在优先队列中存储二元组(num, cnt),cnt表示元素值num在数组中的出现次数        //出现次数按从队头到队尾的顺序是从大到小排,出现次数最多的在队头(相当于大顶堆)        PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((pair1, pair2) -&gt; pair2[1] - pair1[1]);        for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;//大顶堆需要对所有元素进行排序            pq.add(new int[]&#123;entry.getKey(), entry.getValue()&#125;);        &#125;        int[] ans = new int[k];        for (int i = 0; i &lt; k; i++) &#123; //依次从队头弹出k个,就是出现频率前k高的元素            ans[i] = pq.poll()[0];        &#125;        return ans;    &#125;    //解法2：基于小顶堆实现    public int[] topKFrequent2(int[] nums, int k) &#123;        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); //key为数组元素值,val为对应出现次数        for (int num : nums) &#123;            map.put(num, map.getOrDefault(num, 0) + 1);        &#125;        //在优先队列中存储二元组(num, cnt),cnt表示元素值num在数组中的出现次数        //出现次数按从队头到队尾的顺序是从小到大排,出现次数最低的在队头(相当于小顶堆)        PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((pair1, pair2) -&gt; pair1[1] - pair2[1]);        for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123; //小顶堆只需要维持k个元素有序            if (pq.size() &lt; k) &#123; //小顶堆元素个数小于k个时直接加                pq.add(new int[]&#123;entry.getKey(), entry.getValue()&#125;);            &#125; else &#123;                if (entry.getValue() &gt; pq.peek()[1]) &#123; //当前元素出现次数大于小顶堆的根结点(这k个元素中出现次数最少的那个)                    pq.poll(); //弹出队头(小顶堆的根结点),即把堆里出现次数最少的那个删除,留下的就是出现次数多的了                    pq.add(new int[]&#123;entry.getKey(), entry.getValue()&#125;);                &#125;            &#125;        &#125;        int[] ans = new int[k];        for (int i = k - 1; i &gt;= 0; i--) &#123; //依次弹出小顶堆,先弹出的是堆的根,出现次数少,后面弹出的出现次数多            ans[i] = pq.poll()[0];        &#125;        return ans;    &#125;&#125;\n","categories":["面试","代码随想录"],"tags":["队列","单调队列","优先级队列"]},{"title":"代码随想录算法训练营第十二天-二叉树理论基础、递归遍历、迭代遍历、统一迭代","url":"/posts/a297f438/","content":"\n\n前言递归、迭代、统一迭代。都是看完解析之后完成的。统一迭代有点难理解。\n\n\n更新\n\n\n24-06-03 初始记录\n\n144 二叉树的前序遍历\n题目链接：(https://leetcode.cn/problems/binary-tree-preorder-traversal/description/)\npublic List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;      ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();      preOrder(root, list);      return list;  &#125;/**   * 前序遍历 * @param root 节点   * @param list 遍历结果   */  private void preOrder(TreeNode root, ArrayList&lt;Integer&gt; list) &#123;      if (root == null) &#123;          return;      &#125;      // 当前      list.add(root.val);      // 左子树      preOrder(root.left, list);      // 右子树      preOrder(root.right, list);  &#125;\n/**   * 迭代法   * 前序遍历 中左右   * @param root 根节点   * @return 结果   */  public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;      ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();      if (root == null) &#123;          return list;      &#125;      Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();      stack.push(root);      while (!stack.isEmpty()) &#123;          TreeNode pop = stack.pop();          list.add(pop.val);            // 栈先进后出，先进右          if (pop.right != null) &#123;              stack.push(pop.right);          &#125;          if (pop.left != null) &#123;              stack.push(pop.left);          &#125;      &#125;        return list;  &#125;\npublic List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;      ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();      Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();      if (root != null) &#123;          stack.push(root);      &#125;      while (!stack.isEmpty()) &#123;          TreeNode node = stack.peek();          if (node != null) &#123;              stack.pop();              // 判断右节点              if (node.right != null) &#123;                  stack.push(node.right);              &#125;              // 左节点              if (node.left != null) &#123;                  stack.push(node.left);              &#125;              // 中间节点              stack.push(node);              stack.push(null);              // 只有到最后一个节点，才会进这个else          &#125; else &#123;              // 遇到空节点，说明后一个是要处理的节点，先弹出空节点              stack.pop();                // 再把要处理的节点弹出并加入到列表中              node = stack.peek();              stack.pop();              list.add(node.val);          &#125;      &#125;      return list;  &#125;\n94 二叉树的中序遍历\n题目链接：(https://leetcode.cn/problems/binary-tree-inorder-traversal/description/)\n中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进 result 数组中），这就造成了处理顺序和访问顺序是不一致的。\n那么在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。\npublic List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;      ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();      inOrder(root, list);      return list;  &#125;/**   * 中序遍历   * @param root 节点   * @param list 遍历结果   */  private void inOrder(TreeNode root, ArrayList&lt;Integer&gt; list) &#123;      if (root == null) &#123;          return;      &#125;      inOrder(root.left, list);      list.add(root.val);      inOrder(root.right, list);  &#125;\n/**   * 迭代法   * 中序遍历 左中右   * @param root 根节点   * @return 结果   */  public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;      ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();      if (root == null) &#123;          return list;      &#125;      Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();      TreeNode cur = root;      while (!stack.isEmpty() || cur != null) &#123;          if (cur != null) &#123;              // 先遍历左子节点(直至到最后一个左子节点)              stack.push(cur);              cur = cur.left;          &#125; else &#123;              // 此时从栈里弹出的数据，就是要处理的数据              cur = stack.pop();              list.add(cur.val);              cur = cur.right;          &#125;      &#125;        return list;  &#125;\n/**   * 中序遍历   * @param root 根节点   * @return 返回遍历结果   */  public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;      ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();      Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();      if (root != null) &#123;          stack.push(root);      &#125;      while (!stack.isEmpty()) &#123;          TreeNode node = stack.peek();          if (node != null) &#123;              stack.pop();              // 判断右节点              if (node.right != null) &#123;                  stack.push(node.right);              &#125;              // 中间节点              stack.push(node);              stack.push(null);              // 左节点              if (node.left != null) &#123;                  stack.push(node.left);              &#125;              // 只有到最后一个节点，才会进这个else          &#125; else &#123;              // 遇到空节点，说明后一个是要处理的节点，先弹出空节点              stack.pop();                // 再把要处理的节点弹出并加入到列表中              node = stack.peek();              stack.pop();              list.add(node.val);          &#125;      &#125;      return list;  &#125;\n145 二叉树的后序遍历\n题目链接：(https://leetcode.cn/problems/binary-tree-postorder-traversal/description/)\n// 递归法public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;      ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();      postOrder(root, list);      return list;  &#125;    /**   * 后序遍历   * @param root 节点   * @param list 遍历结果   */  private void postOrder(TreeNode root, ArrayList&lt;Integer&gt; list) &#123;      if (root == null) &#123;          return;      &#125;      postOrder(root.left, list);      postOrder(root.right, list);      list.add(root.val);  &#125;\n/**   * 后序遍历 左右中   * @param root 根节点   * @return 结果   */  public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;      ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();      if (root == null) &#123;          return list;      &#125;      Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();      stack.push(root);      while (!stack.isEmpty()) &#123;          TreeNode pop = stack.pop();          list.add(pop.val);            // 栈先进后出，先进右          if (pop.left != null) &#123;              stack.push(pop.left);          &#125;          if (pop.right != null) &#123;              stack.push(pop.right);          &#125;      &#125;      // 上部分代码与前序相同，left和right遍历顺序颠倒。得到的数组为中右左遍历得出的结果      // 翻转得到的结果，即为左右中遍历得出的结果      Collections.reverse(list);      return list;  &#125;\npublic List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;      ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();      Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();      if (root != null) &#123;          stack.push(root);      &#125;      while (!stack.isEmpty()) &#123;          TreeNode node = stack.peek();          if (node != null) &#123;              stack.pop();              // 中间节点              stack.push(node);              stack.push(null);              // 判断右节点              if (node.right != null) &#123;                  stack.push(node.right);              &#125;              // 左节点              if (node.left != null) &#123;                  stack.push(node.left);              &#125;              // 只有到最后一个节点，才会进这个else          &#125; else &#123;              // 遇到空节点，说明后一个是要处理的节点，先弹出空节点              stack.pop();                // 再把要处理的节点弹出并加入到列表中              node = stack.peek();              stack.pop();              list.add(node.val);          &#125;      &#125;      return list;  &#125;\n看解析\n❗递归的三要素\n文章讲解：(https://programmercarl.com/二叉树的递归遍历.html)\n\n\n确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。\n\n\n确定终止条件： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。\n\n\n确定单层递归的逻辑： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。\n\n\n迭代法\n递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中所以所有递归的题目，理论上都可以使用栈解决。\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/二叉树的迭代遍历.html)\n统一迭代\n迭代法实现的先中后序，其实风格也不是那么统一，除了先序和后序，有关联，中序完全就是另一个风格了，一会用栈遍历，一会又用指针来遍历。\n在迭代法的中序遍历中提到说使用栈的话，无法同时解决访问节点（遍历节点）和处理节点（将元素放进结果集）不一致的情况。那我们就将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。 这种方法也可以叫做标记法。\n题目链接/文章讲解：(https://programmercarl.com/二叉树的统一迭代法.html)\n","categories":["面试","代码随想录"],"tags":["二叉树"]},{"title":"代码随想录算法训练营第十三天-层序遍历、226翻转二叉树、101对称二叉树","url":"/posts/b6d70614/","content":"\n\n前言状态：层序遍历直接看解析。226、101 看了部分解析。可以完成递归法。\n\n\n更新\n\n\n24.06.03 初始记录\n\n初步题解\n102 二叉树的层序遍历\n题目链接：(https://leetcode.cn/problems/binary-tree-level-order-traversal/description/)\npublic List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;      ArrayList&lt;List&lt;Integer&gt;&gt; resultList = new ArrayList&lt;&gt;();      levelOrderDFS(root, 0, resultList);      levelOrderBFS(root, resultList);      return resultList;  &#125;    /**   * 迭代法实现层序遍历（广度优先）   * @param root 根节点   * @param resultList 返回的list   */private void levelOrderBFS(TreeNode root, ArrayList&lt;List&lt;Integer&gt;&gt; resultList) &#123;      if (root == null) &#123;          return;      &#125;        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();      queue.offer(root);      while (!queue.isEmpty()) &#123;          ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();          int size = queue.size();            // 遍历当前层所有节点          while (size &gt; 0) &#123;              TreeNode node = queue.poll();              list.add(node.val);                // 把这层所有的左节点加入              if (node.left != null) &#123;                  queue.offer(node.left);              &#125;              // 把这层所有的右节点加入              if (node.right != null) &#123;                  queue.offer(node.right);              &#125;              size--;          &#125;          resultList.add(list);      &#125;  &#125;    /**   * 递归方式实现层序遍历(深度优先)   * @param root 根节点   * @param i 层数   * @param resultList 遍历结果   */  private void levelOrderDFS(TreeNode root, int i, ArrayList&lt;List&lt;Integer&gt;&gt; resultList) &#123;      if (root == null) &#123;          return;      &#125;        i++;        // 如果小于，说明第一次进这层，需要初始化这个位置的list      if (resultList.size() &lt; i) &#123;          ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();          resultList.add(list);      &#125;      resultList.get(i - 1).add(root.val);        levelOrderDFS(root.left, i, resultList);      levelOrderDFS(root.right, i, resultList);  &#125;\n226 翻转二叉树\n题目链接：(https://leetcode.cn/problems/invert-binary-tree/description/)\n看了一部分的题目解析，突然反应过来 tree 不用自己构建，直接用方法简单很多。\n/**   * DFS递归   * @param root 根节点   * @return 翻转结果   */  public TreeNode invertTree(TreeNode root) &#123;      invertTreePreorder(root);      return root;  &#125;    private void invertTreePreorder(TreeNode root) &#123;      if (root == null) &#123;          return;      &#125;      TreeNode temp = new TreeNode();      // 指针交换      temp = root.left;      root.left = root.right;      root.right = temp;        if (root.left != null) &#123;          invertTreePreorder(root.left);      &#125;      if (root.right != null) &#123;          invertTreePreorder(root.right);      &#125;  &#125;\n101 对称二叉树\n题目链接：(https://leetcode.cn/problems/symmetric-tree/description/)\n/**   * 这题和翻转放在一起   * 第一思路就是翻转之后比较是否相等(但是是指针引用，翻转之后是不能进行比较的)   * 看了部分讲解，说是把左子，右子拆分成两棵树来看.   * 可以拆分之后翻转一棵树，然后比较是否相等。   *   * @param root 根节点   * @return 结果   */  public static boolean isSymmetric(TreeNode root) &#123;      if (root == null) &#123;          return true;      &#125;      TreeNode right = root.right;      TreeNode left = root.left;        // 左子树翻转      invertTreePreorder(left);      return isEqual(right, left);  &#125;    private static boolean isEqual(TreeNode right, TreeNode left) &#123;      if (right == null &amp;&amp; left == null) &#123;          return true;      &#125;      if ((right == null &amp;&amp; left != null) || (right != null &amp;&amp; left == null)) &#123;          return false;      &#125;      if (right.val != left.val) &#123;          return false;      &#125;        return isEqual(right.right, left.right) &amp;&amp; isEqual(right.left, left.left);  &#125;    private static void invertTreePreorder(TreeNode root) &#123;      if (root == null) &#123;          return;      &#125;      TreeNode temp;      // 指针交换      temp = root.left;      root.left = root.right;      root.right = temp;        if (root.left != null) &#123;          invertTreePreorder(root.left);      &#125;      if (root.right != null) &#123;          invertTreePreorder(root.right);      &#125;  &#125;\n看解析\n102 二叉树的层序遍历\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0102.二叉树的层序遍历.html)\n层序遍历一个二叉树。需要借用一个辅助数据结构即队列来实现，队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。\n而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。\n226 翻转二叉树\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0226.翻转二叉树.html)\n递归的中序遍历是不行的，因为使用递归的中序遍历，某些节点的左右孩子会翻转两次。\n101 对称二叉树\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0101.对称二叉树.html)\n本题遍历只能是“后序遍历”，因为我们要通过递归函数的返回值来判断两个子树的内侧节点和外侧节点是否相等。\n正是因为要遍历两棵树而且要比较内侧和外侧节点，所以准确的来说是一个树的遍历顺序是左右中，一个树的遍历顺序是右左中。\n/**    * 看完解析后的思路，不用翻转直接比较是否相等   *   * @param root 根节点   * @return 结果   */public static boolean isSymmetric(TreeNode root) &#123;      if (root == null) &#123;          return true;      &#125;      TreeNode right = root.right;      TreeNode left = root.left;        return compare(right, left);  &#125;    private static boolean compare(TreeNode right, TreeNode left) &#123;      if (right == null &amp;&amp; left == null) &#123;          return true;      &#125;      if ((right == null &amp;&amp; left != null) || (right != null &amp;&amp; left == null)) &#123;          return false;      &#125;      if (right.val != left.val) &#123;          return false;      &#125;        return compare(right.right, left.left) &amp;&amp; compare(right.left, left.right);  &#125;\n    /**     * 迭代法     * 使用双端队列，相当于两个栈     */    public boolean isSymmetric2(TreeNode root) &#123;        Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();        deque.offerFirst(root.left);        deque.offerLast(root.right);        while (!deque.isEmpty()) &#123;            TreeNode leftNode = deque.pollFirst();            TreeNode rightNode = deque.pollLast();            if (leftNode == null &amp;&amp; rightNode == null) &#123;                continue;            &#125;//            if (leftNode == null &amp;&amp; rightNode != null) &#123;//                return false;//            &#125;//            if (leftNode != null &amp;&amp; rightNode == null) &#123;//                return false;//            &#125;//            if (leftNode.val != rightNode.val) &#123;//                return false;//            &#125;            // 以上三个判断条件合并            if (leftNode == null || rightNode == null || leftNode.val != rightNode.val) &#123;                return false;            &#125;            deque.offerFirst(leftNode.left);            deque.offerFirst(leftNode.right);            deque.offerLast(rightNode.right);            deque.offerLast(rightNode.left);        &#125;        return true;    &#125;    /**     * 迭代法     * 使用普通队列     */    public boolean isSymmetric3(TreeNode root) &#123;        Queue&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();        deque.offer(root.left);        deque.offer(root.right);        while (!deque.isEmpty()) &#123;            TreeNode leftNode = deque.poll();            TreeNode rightNode = deque.poll();            if (leftNode == null &amp;&amp; rightNode == null) &#123;                continue;            &#125;//            if (leftNode == null &amp;&amp; rightNode != null) &#123;//                return false;//            &#125;//            if (leftNode != null &amp;&amp; rightNode == null) &#123;//                return false;//            &#125;//            if (leftNode.val != rightNode.val) &#123;//                return false;//            &#125;            // 以上三个判断条件合并            if (leftNode == null || rightNode == null || leftNode.val != rightNode.val) &#123;                return false;            &#125;            // 这里顺序与使用Deque不同            deque.offer(leftNode.left);            deque.offer(rightNode.right);            deque.offer(leftNode.right);            deque.offer(rightNode.left);        &#125;        return true;    &#125;\n","categories":["面试","代码随想录"],"tags":["二叉树"]},{"title":"代码随想录算法训练营第十四天-104二叉树的最大深度、111二叉树的最小深度、222完全二叉树的节点个数","url":"/posts/39075b30/","content":"\n\n前言状态：104、111 可以 AC，222 没有思路\n\n\n更新\n\n\n24.06.04 初始记录\n\n初步题解\n104 二叉树的最大深度\n题目链接：(https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/)\n/**   * 思路：递归计算左右子树的深度。取较大值   * @param root 根节点   * @return 结果   */  public int maxDepth(TreeNode root) &#123;      if (root == null) &#123;          return 0;      &#125;      int leftLength = maxDepth(root.left);      int rightLength = maxDepth(root.right);      return 1 + Math.max(leftLength, rightLength);  &#125;\n111 二叉树的最小深度\n题目链接：(https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/)\n/**   * 思路：   * 递归终止条件   * 1.根节点为空，直接返回0   * 2.根节点的左右节点有一个为空，返回另一个节点的最小深度   *   * @param root 根节点   * @return 结果   */  public int minDepth(TreeNode root) &#123;      if (root == null) &#123;          return 0;      &#125;        if (root.right == null) &#123;          return 1 + minDepth(root.left);      &#125;      if (root.left == null) &#123;          return 1 + minDepth(root.right);      &#125;        return 1 + Math.min(minDepth(root.right), minDepth(root.left));  &#125;\n222 完全二叉树的节点个数\n题目链接:(https://leetcode.cn/problems/count-complete-tree-nodes/description/)\n没有 AC，思路只有一半。根据题解：递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后按满二叉树的情况来算。\n// 错误解法，正确解法在看解析部分。/**   * 思路：既然是完全二叉树。深度可以很简单的求出来   * @param root 根节点   * @return 结果   */  public int countNodes(TreeNode root) &#123;      int depth = getDepth(root);      // n - 1 层的节点数量      int num = (depth - 1) ^ 2 - 1;  &#125;      /**   * 求完全二叉树的深度   * @param root 根节点   * @return 结果   */  private int getDepth(TreeNode root) &#123;      int depth = 0;      while (root != null) &#123;          depth++;          root = root.left;      &#125;      return depth;  &#125;\n看解析\n104 二叉树的最大深度\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0104.二叉树的最大深度.html)\n本题可以使用前序（中左右），也可以使用后序遍历（左右中），使用前序求的就是深度，使用后序求的是高度。\n\n\n二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数或者节点数（取决于深度从 0 开始还是从 1 开始）\n\n\n二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数或者节点数（取决于高度从 0 开始还是从 1 开始）\n根节点的高度就是二叉树的最大深度。\n\n\n559. N 叉树的最大深度\n题目链接 (https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/)\npublic int maxDepth(Node root) &#123;      if (root == null) &#123;          return 0;      &#125;        int max = 0;      for (Node child : root.children) &#123;          max = Math.max(maxDepth(child), max);      &#125;      return 1 + max;  &#125;\n111 二叉树的最小深度\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0111.二叉树的最小深度.html)\n最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 注意是叶子节点。（左右孩子都为空的节点才是叶子节点）\n222 完全二叉树的节点个数\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0222.完全二叉树的节点个数.html)\n递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后按满二叉树的情况来算。所以需要判断是否是满二叉树\n/**   * 完全二叉树求节点   * @param root 根节点   * @return 结果   */  public int countNodes(TreeNode root) &#123;      if (root == null) &#123;          return 0;      &#125;        TreeNode left = root.left;      TreeNode right = root.right;        int leftLength = 0, rightLength = 0;      while (left != null) &#123;          left = left.left;          leftLength++;      &#125;      while (right != null) &#123;          right = right.right;          rightLength++;      &#125;      if (leftLength == rightLength) &#123;          return (2 &lt;&lt; leftLength) - 1;      &#125;      return countNodes(root.left) + countNodes(root.right) + 1;  &#125;\n","categories":["面试","代码随想录"],"tags":["二叉树"]},{"title":"代码随想录算法训练营第十五天-110平衡二叉树 、257二叉树的所有路径、404左叶子之和","url":"/posts/eb9bb750/","content":"\n\n前言状态：110，404AC，257 不会。迭代法没有写\n\n\n更新\n\n\n24.06.06 初始记录\n\n初步题解\n110 平衡二叉树\n题目链接：(https://leetcode.cn/problems/balanced-binary-tree/)\npublic class LE110 &#123;      public boolean isBalanced(TreeNode root) &#123;          return getHeight(root) != -1;      &#125;        private int getHeight(TreeNode root) &#123;          if (root == null) &#123;              return 0;          &#125;            int leftHeight = getHeight(root.left);          if (leftHeight == -1) &#123;              return -1;          &#125;          int rightHeight = getHeight(root.right);          if (rightHeight == -1) &#123;              return -1;          &#125;            if (Math.abs(leftHeight - rightHeight) &gt; 1) &#123;              return -1;          &#125;          return 1 + Math.max(leftHeight, rightHeight);      &#125;  &#125;\n257 二叉树的所有路径\n题目链接：(https://leetcode.cn/problems/binary-tree-paths/description/)\n(不会)\n404 左叶子之和\npublic int sumOfLeftLeaves(TreeNode root) &#123;      if (root == null) &#123;          return 0;      &#125;        int sum = 0;      if (root.left != null &amp;&amp; root.left.left == null &amp;&amp; root.left.right == null) &#123;          sum += root.left.val;      &#125;      return sum + sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);  &#125;\n看解析\n110 平衡二叉树\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0110.平衡二叉树.html)\n分别求出其左右子树的高度，然后如果差值小于等于 1，则返回当前二叉树的高度，否则返回 -1，表示已经不是二叉平衡树了。\n257 二叉树的所有路径\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0257.二叉树的所有路径.html)\n主要是这个回溯有点懵，不知道怎么写了。但是写完代码跟着断点跑一遍，可以看到：在有下个节点时，会一直递归，直到进入到最后一个节点。在返回的途中，会把所有的进入操作，回退回去（即回退到交叉节点那个位置）。可能表述的不是很清楚，写完代码跑一遍就清楚了。\npublic static List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;      List&lt;String&gt; pathString = new ArrayList&lt;&gt;();      if (root == null) &#123;          return pathString;      &#125;      List&lt;Integer&gt; path = new ArrayList&lt;&gt;();      binaryTree(root, path, pathString);      return pathString;  &#125;    private static void binaryTree(TreeNode root, List&lt;Integer&gt; path, List&lt;String&gt; pathString) &#123;     path.add(root.val);        if (root != null &amp;&amp; (root.right == null &amp;&amp; root.left == null)) &#123;          pathString.add(path.stream().map(Object::toString).collect(Collectors.joining(&quot;-&gt;&quot;)));          return;      &#125;        if (root.left != null) &#123;          binaryTree(root.left, path, pathString);          path.remove(path.size() - 1);      &#125;      if (root.right != null) &#123;          binaryTree(root.right, path, pathString);          path.remove(path.size() - 1);      &#125;  &#125;\n404 左叶子之和\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0404.左叶子之和.html)\n","categories":["面试","代码随想录"],"tags":["二叉树"]},{"title":"代码随想录算法训练营第十六天-513找树左下角的值、112路径总和、113路径总和ii、106从中序与后序遍历序列构造二叉树、105从前序与中序遍历序列构造二叉树","url":"/posts/2305b4a/","content":"\n\n前言状态：513 用层序 AC、112AC（但时间复杂度较高））（解析中给的方法和想的不一样），113AC、106 不会\n\n\n更新\n\n\n24.06.07 初始记录\n\n初步题解\n513 找树左下角的值\n题目链接：(https://leetcode.cn/problems/find-bottom-left-tree-value)\n/**   * 看题目感觉层序遍历简单一点   * @param root 根节点   * @return 结果   */  public int findBottomLeftValue(TreeNode root) &#123;      List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();      findBottomDFS(root, 0, list);      List&lt;Integer&gt; theLastLayer = list.get(list.size() - 1);      return theLastLayer.stream().filter(Objects::nonNull).collect(Collectors.toList()).get(0);  &#125;    private void findBottomDFS(TreeNode root, int i, List&lt;List&lt;Integer&gt;&gt; list) &#123;      if (root == null) &#123;          return;      &#125;        // 深度增加      i++;        if (list.size() &lt; i) &#123;          ArrayList&lt;Integer&gt; innerList = new ArrayList&lt;&gt;();          list.add(innerList);      &#125;      list.get(i - 1).add(root.val);        findBottomDFS(root.left, i, list);      findBottomDFS(root.right, i, list);  &#125;\n112 路径总和、113 路径总和 ii\n题目链接：(https://leetcode.cn/problems/path-sum/description/)\n/**   * 感觉之前做过求路径的题（递归+迭代）这题应该变换一下   * 时间复杂度好像有点高，剩下那题等看完解析后再写 * 后面改用sum直接加减不遍历求总和，但是leetcode不通过，本地倒是测试没问题 * @param root 根节点   * @param targetSum 目标和   * @return 结果   */  public boolean hasPathSum(TreeNode root, int targetSum) &#123;      if (root == null) &#123;          return false;      &#125;      List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();      return hasPathSumBFS(root, list, targetSum);  &#125;    private boolean hasPathSumBFS(TreeNode root, List&lt;Integer&gt; list, int targetSum) &#123;      list.add(root.val);        if (root.left == null &amp;&amp; root.right == null) &#123;          // 求list中的总和          long sum = list.stream().collect(Collectors.summarizingInt(value -&gt; value)).getSum();          return sum == targetSum;      &#125;        boolean left = false;      boolean right = false;      if (root.left != null) &#123;          left = hasPathSumBFS(root.left, list, targetSum);          list.remove(list.size() - 1);      &#125;      if (root.right != null) &#123;          right = hasPathSumBFS(root.right, list, targetSum);          list.remove(list.size() - 1);      &#125;            return left || right;  &#125;\n题目链接：(https://leetcode.cn/problems/path-sum-ii/)\npublic static List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int targetSum) &#123;      List&lt;Integer&gt; list = new ArrayList&lt;&gt;();      List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();      pathSumBFS(root, targetSum, result, list);      return result;  &#125;    private static void pathSumBFS(TreeNode root, int targetSum, List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; list) &#123;      if (root == null) &#123;          return;      &#125;        targetSum -= root.val;      list.add(root.val);        if (root.left == null &amp;&amp; root.right == null) &#123;          if (targetSum == 0) &#123;              List&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(list);              result.add(arrayList);          &#125;      &#125;        if (root.left != null) &#123;          pathSumBFS(root.left, targetSum, result, list);          list.remove(list.size() - 1);      &#125;      if (root.right != null) &#123;          pathSumBFS(root.right, targetSum, result, list);          list.remove(list.size() - 1);      &#125;  &#125;\n106 从中序与后序遍历序列构造二叉树、105 从前序与中序遍历序列构造二叉树\n题目链接：(https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/)\n不会，直接看解析\n题目链接：(https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)\n更快的解法是把 inorder 放到 map 内，这样查找不用遍历。\npublic static TreeNode buildTree(int[] preorder, int[] inorder) &#123;      if (preorder.length == 0) &#123;          return null;      &#125;      TreeNode root = new TreeNode(preorder[0]);      if (preorder.length == 1) &#123;          return root;      &#125;        int indexIn = -1;      for (int i = 0; i &lt; inorder.length; i++) &#123;          if (inorder[i] == preorder[0]) &#123;              indexIn = i;              break;          &#125;      &#125;      // 左子树      int[] leftTreeInorder = Arrays.copyOfRange(inorder, 0, indexIn);      // 右子树      int[] rightTreeInorder = Arrays.copyOfRange(inorder, indexIn + 1, inorder.length);        root.left = buildTree(Arrays.copyOfRange(preorder, 1, leftTreeInorder.length + 1), leftTreeInorder);      root.right = buildTree(Arrays.copyOfRange(preorder, inorder.length - rightTreeInorder.length, inorder.length), rightTreeInorder);      return root;  &#125;\n看解析\n513 找树左下角的值\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0513.找树左下角的值.html)\n那么如何找最左边的呢？可以使用前序遍历（当然中序，后序都可以，因为本题没有 中间节点的处理逻辑，只要左优先就行），保证优先左边搜索，然后记录深度最大的叶子节点，此时就是树的最后一行最左边的值。\n// 递归法int value;  int maxDeep = Integer.MIN_VALUE;  public int findBottomLeftValueBFS(TreeNode root) &#123;      value = root.val;      findLeftValue(root,0);      return value;  &#125;    private void findLeftValue(TreeNode root, int deep) &#123;      if (root == null) &#123;          return;      &#125;      if (root.left == null &amp;&amp; root.right == null) &#123;          if (deep &gt; maxDeep) &#123;              value = root.val;              maxDeep = deep;          &#125;      &#125;        if (root.left != null) &#123;          findLeftValue(root.left, deep + 1);      &#125;      if (root.right != null) &#123;          findLeftValue(root.right, deep + 1);      &#125;  &#125;\n112 路径总和、113 路径总和 ii\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0112.路径总和.html)\n绕晕了，如果把 targetSum -= root.val; 这句话写在函数最前面，就不用回溯。可以看三行简化的那个注释。我理解的是 Java 里 int 不能传递值，递归内层对 targetSum 的值进行改变，外层不会变化，所以就不用回溯了。\n// 没搞懂怎么就不用回溯了，因为int不能传值吗？/**   * 感觉之前做过求路径的题（递归+迭代）这题应该变换一下   * @param root 根节点   * @param targetSum 目标和   * @return 结果   */  public static boolean hasPathSum(TreeNode root, int targetSum) &#123;      if (root == null) &#123;          return false;      &#125;      targetSum -= root.val;      return hasPathSumBFS(root, targetSum);  &#125;    private static boolean hasPathSumBFS(TreeNode root, int targetSum) &#123;      if (root.left == null &amp;&amp; root.right == null) &#123;          // 求list中的总和          return targetSum == 0;      &#125;        if (root.left != null) &#123;          targetSum -= root.left.val;          if (hasPathSumBFS(root.left, targetSum)) &#123;              return true;          &#125;          // 这里的回溯就是把当前节点减掉（数值加上）。包括之前也是，但是之前是list不太好移除，所以选择移除最后一位        targetSum += root.left.val;      &#125;    \t/*\t// 上面三行可以简化成  \tif (root.left != null) &#123;  \t    // 这里targetSum的值是没有变化的。减完的值进入循环，就不用回溯了  \t    hasPathSumBFS(root.left, targetSum - root.left.val);  \t&#125;\t*/\t    if (root.right != null) &#123;          targetSum -= root.right.val;          if (hasPathSumBFS(root.right, targetSum)) &#123;              return true;          &#125;          targetSum += root.right.val;      &#125;        return false;  &#125;/**   * 简化版本   */  public static boolean hasPathSum(TreeNode root, int targetSum) &#123;      if (root == null) &#123;          return false;      &#125;        if (root.left == null &amp;&amp; root.right == null) &#123;          return targetSum == 0;      &#125;            return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);  &#125;\n106 从中序与后序遍历序列构造二叉树、105 从前序与中序遍历序列构造二叉树\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0106.从中序与后序遍历序列构造二叉树.html)\n更快的解法是把 inorder 放到 map 内，这样查找不用遍历。\n/**   * 1.后序最后一个节点为根节点   * 2.根据这个节点切割中序数组（节点前为左子树，节点后为右子树）   * 3.根据中序数组的切割切割后序数组   * 4.递归   * @param inorder 中序遍历结果   * @param postorder 后序遍历结果   * @return 树   */  public static TreeNode buildTree(int[] inorder, int[] postorder) &#123;      if (inorder.length != postorder.length) &#123;          return null;      &#125;        if (postorder.length == 0) &#123;          return null;      &#125;      TreeNode root = new TreeNode(postorder[postorder.length - 1]);      if (postorder.length == 1) &#123;          return root;      &#125;        int indexIn = -1;      for (int i = 0; i &lt; inorder.length; i++) &#123;          if (inorder[i] == postorder[postorder.length - 1]) &#123;              indexIn = i;              break;          &#125;      &#125;      // 左子树      int[] leftTreeInorder = Arrays.copyOfRange(inorder, 0, indexIn);      // 右子树      int[] rightTreeInorder = Arrays.copyOfRange(inorder, indexIn + 1, inorder.length);        root.left = buildTree(leftTreeInorder, Arrays.copyOfRange(postorder, 0, leftTreeInorder.length));      root.right = buildTree(rightTreeInorder, Arrays.copyOfRange(postorder, leftTreeInorder.length, postorder.length - 1));      return root;  &#125;\n","categories":["面试","代码随想录"],"tags":["二叉树"]},{"title":"代码随想录算法训练营第十七天-654最大二叉树、617合并二叉树、700二叉搜索树中的搜索、98验证二叉搜索树","url":"/posts/c463689e/","content":"\n\n前言状态：654AC、617AC 可优化、700AC、98 不会\n\n\n更新\n\n\n24.06.07 初始记录\n\n初步题解\n654 最大二叉树\n题目链接：(https://leetcode.cn/problems/maximum-binary-tree/)\npublic static TreeNode constructMaximumBinaryTree(int[] nums) &#123;      if (nums.length == 0) &#123;          return null;      &#125;        int maxIndex = getMaxIndex(nums);      TreeNode root = new TreeNode(nums[maxIndex]);      if (nums.length == 1) &#123;          return root;      &#125;        root.left = constructMaximumBinaryTree(Arrays.copyOfRange(nums, 0, maxIndex));      root.right = constructMaximumBinaryTree(Arrays.copyOfRange(nums, maxIndex + 1, nums.length));      return root;  &#125;    private static int getMaxIndex(int[] nums) &#123;      int max = Integer.MIN_VALUE;      int maxIndex = -1;      for (int i = 0; i &lt; nums.length; i++) &#123;          if (nums[i] &gt; max) &#123;              maxIndex = i;              max = nums[i];          &#125;      &#125;      return maxIndex;  &#125;\n617 合并二叉树\n题目链接：(https://leetcode.cn/problems/merge-two-binary-trees/)\npublic TreeNode mergeTrees(TreeNode root1, TreeNode root2) &#123;      if (root1 == null &amp;&amp; root2 == null) &#123;          return null;      &#125;        int value1 = root1 == null ? 0 : root1.val;      int value2 = root2 == null ? 0 : root2.val;        TreeNode node = new TreeNode(value1 + value2);        if (root1 == null) &#123;          node.left = mergeTrees(null, root2.left);          node.right = mergeTrees(null, root2.right);      &#125; else if (root2 == null)&#123;          node.left = mergeTrees(root1.left, null);          node.right = mergeTrees(root1.right, null);      &#125; else &#123;          node.left = mergeTrees(root1.left, root2.left);          node.right = mergeTrees(root1.right, root2.right);      &#125;      return node;  &#125;\n700 二叉搜索树中的搜索\n题目链接：(https://leetcode.cn/problems/search-in-a-binary-search-tree)\n/**   * BFS  */public TreeNode searchBST(TreeNode root, int val) &#123;      if (root == null) &#123;          return null;      &#125;      if (val == root.val) &#123;          return root;      &#125; else if (val &lt; root.val) &#123;          return searchBST(root.left, val);      &#125; else &#123;          return searchBST(root.right, val);      &#125;  &#125;    /**   * DFS  */ public TreeNode searchBSTDFS(TreeNode root, int val) &#123;      while (root != null) &#123;          if (val == root.val) &#123;              return root;          &#125; else if (val &lt; root.val)&#123;              root = root.left;          &#125; else &#123;              root = root.right;          &#125;      &#125;      return null;  &#125;\n98 验证二叉搜索树\n题目链接：(https://leetcode.cn/problems/validate-binary-search-tree/)\n只比较了左节点小于中间节点，右节点大于中间节点，实际上要加上左子树所有节点小于中间节点，右子树所有节点大于中间节点\n// 没有通过，少算了一种情况public boolean isValidBST(TreeNode root) &#123;      if (root == null) &#123;          return true;      &#125;        // 左子树不为空并且大于      if (root.left != null &amp;&amp; root.left.val &gt;= root.val) &#123;          return false;          // 右子树不为空并且小于      &#125; else if (root.right != null &amp;&amp; root.right.val &lt;= root.val) &#123;          return false;      &#125;        return isValidBST(root.left) &amp;&amp; isValidBST(root.right);  &#125;\n看解析\n654 最大二叉树\n题目链接/文章讲解：(https://programmercarl.com/0654.最大二叉树.html)\n视频讲解：https://www.bilibili.com/video/BV1MG411G7ox\n617 合并二叉树\n题目链接/文章讲解：(https://programmercarl.com/0617.合并二叉树.html)\n视频讲解：https://www.bilibili.com/video/BV1m14y1Y7JK\n// 优化后public TreeNode mergeTrees1(TreeNode root1, TreeNode root2) &#123;      if (root1 == null &amp;&amp; root2 != null) &#123;          return root2;      &#125; else if (root1 != null &amp;&amp; root2 == null) &#123;          return root1;      &#125; else if (root1 == null &amp;&amp; root2 == null) &#123;          return null;      &#125; else &#123;          TreeNode node = new TreeNode(root1.val + root2.val);          node.left = mergeTrees(root1.left, root2.left);          node.right = mergeTrees(root1.right, root2.right);          return node;      &#125;  &#125;\n700 二叉搜索树中的搜索\n题目链接/文章讲解：(https://programmercarl.com/0700.二叉搜索树中的搜索.html)\n视频讲解：https://www.bilibili.com/video/BV1wG411g7sF\n二叉搜索树是一个有序树：\n\n\n若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；\n\n\n若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；\n\n\n它的左、右子树也分别为二叉搜索树\n\n\n98 验证二叉搜索树\n题目链接/文章讲解：(https://programmercarl.com/0098.验证二叉搜索树.html)\n视频讲解：https://www.bilibili.com/video/BV18P411n7Q4\n关键在于：中序遍历下，输出的二叉搜索树节点的数值是有序序列。\npublic boolean isValidBST(TreeNode root) &#123;      List&lt;Integer&gt; list = new ArrayList&lt;&gt;();      inorder(root, list);        if (list.size() &lt;= 1) &#123;          return true;      &#125;      for (int i = 0; i &lt; list.size() - 1; i++) &#123;          if (list.get(i) &gt;= list.get(i + 1)) &#123;              return false;          &#125;      &#125;      return true;  &#125;    private void inorder(TreeNode root, List&lt;Integer&gt; list) &#123;      if (root == null) &#123;          return;      &#125;      inorder(root.left, list);      list.add(root.val);      inorder(root.right, list);  &#125;    /**   * 单次循环搞定 * 双指针法 */  TreeNode max;  public boolean isValidBST1(TreeNode root) &#123;      if (root == null) &#123;          return true;      &#125;      // 左      boolean left = isValidBST1(root.left);      if (!left) &#123;          return false;      &#125;      // 中      if (max != null &amp;&amp; root.val &lt;= max.val) &#123;          return false;      &#125;      max = root;      // 右      return isValidBST1(root.right);  &#125;\n","categories":["面试","代码随想录"],"tags":["双指针","二叉树","二叉搜索树"]},{"title":"代码随想录算法训练营第十八天-530二叉搜索树的最小绝对差、501二叉搜索树中的众数、236二叉树的最近公共祖先","url":"/posts/47cc7c82/","content":"\n\n前言状态：530 暴力遍历、501 暴力、236 不会。看了昨天的题解把 530 改成了双指针。\n\n\n更新\n\n\n24.06.08 初始记录\n\n初步题解\n530 二叉搜索树的最小绝对差\n题目链接：(https://leetcode.cn/problems/minimum-absolute-difference-in-bst)\n// 暴力遍历public int getMinimumDifference(TreeNode root) &#123;      List&lt;Integer&gt; list = new ArrayList&lt;&gt;();      getMinDiff(root, list);      int min = Math.abs(list.get(0) - list.get(1));        for (int i = 2; i &lt; list.size(); i++) &#123;          min = Math.min(Math.abs(list.get(i) - list.get(i - 1)), min);      &#125;        return min;  &#125;    private void getMinDiff(TreeNode root, List&lt;Integer&gt; list) &#123;      if (root == null) &#123;          return;      &#125;        getMinDiff(root.left, list);      list.add(root.val);      getMinDiff(root.right, list);  &#125;// 后面看了昨天最后一题的题解，这里可以用双指针/**   * 双指针的解法   * @param root 根节点   */  Integer min = Integer.MAX_VALUE;  TreeNode pre;  public int getMinimumDifference1(TreeNode root) &#123;      if (root == null) &#123;          return min;      &#125;        getMinimumDifference1(root.left);        // 中间遍历      if (pre != null) &#123;          min = Math.min(Math.abs(root.val - pre.val), min);      &#125;      pre = root;        getMinimumDifference1(root.right);        return min;  &#125;\n501 二叉搜索树中的众数\n题目链接：(https://leetcode.cn/problems/find-mode-in-binary-search-tree)\npublic static int[] findMode(TreeNode root) &#123;      if (root == null) &#123;          return new int[]&#123;&#125;;      &#125;        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();      find(root, map);      List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; collect = map.entrySet().stream()              .sorted((o1, o2) -&gt; o2.getValue() - o1.getValue())              .collect(Collectors.toList());      List&lt;Integer&gt; list = new ArrayList&lt;&gt;();      list.add(collect.get(0).getKey());      for (int i = 1; i &lt; collect.size(); i++) &#123;          if (collect.get(i).getValue().equals(collect.get(0).getValue())) &#123;              list.add(collect.get(i).getKey());          &#125;      &#125;      return list.stream().mapToInt(i -&gt; i).toArray();  &#125;    private static void find(TreeNode root, Map&lt;Integer, Integer&gt; map) &#123;      if (root == null)&#123;          return;      &#125;        find(root.left, map);      map.put(root.val, map.getOrDefault(root.val, 0) + 1);      find(root.right, map);  &#125;\n236 二叉树的最近公共祖先\n题目链接：(https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree)\n没有思路。\n看解析\n530 二叉搜索树的最小绝对差\n题目链接/文章讲解：https://programmercarl.com/0530.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE.html\n视频讲解：https://www.bilibili.com/video/BV1DD4y11779\n501 二叉搜索树中的众数\n题目链接/文章讲解：https://programmercarl.com/0501.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0.html\n视频讲解：https://www.bilibili.com/video/BV1fD4y117gp\n// 双指针的前一个节点  TreeNode pre = null;  int count = 0;  int maxCount = 0;    /**   * 双指针解法   * @param root 根节点   * @return 结果   */  public int[] findMode(TreeNode root) &#123;      List&lt;Integer&gt; list = new ArrayList&lt;&gt;();        // 递归逻辑      findModeTravel(root, list);        return list.stream().mapToInt(i -&gt; i).toArray();  &#125;    private void findModeTravel(TreeNode root, List&lt;Integer&gt; list) &#123;      if (root == null) &#123;          return;      &#125;        findModeTravel(root.left, list);        if (pre == null) &#123;          count = 1;      &#125;else if (pre.val == root.val)&#123;          count++;      &#125; else &#123;          count = 1;      &#125;      pre = root;        if (count == maxCount) &#123;          list.add(root.val);      &#125; else if (count &gt; maxCount) &#123;          maxCount = count;          list.clear();          list.add(root.val);      &#125;        findModeTravel(root.right, list);  &#125;\n236 二叉树的最近公共祖先\n题目链接/文章讲解：https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html\n视频讲解：https://www.bilibili.com/video/BV1jd4y1B7E2\npublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;      // return root也是空 可以和下面一起写      if (root == null) &#123;          return null;      &#125;      if (root == p || root == q) &#123;          return root;      &#125;        TreeNode left = lowestCommonAncestor(root.left, p, q);      TreeNode right = lowestCommonAncestor(root.right, p, q);        if (left!= null &amp;&amp; right != null) &#123;          return root;      &#125; else if (left != null &amp;&amp; right == null) &#123;          return left;      &#125; else if (right != null &amp;&amp; left == null) &#123;          return right;      &#125; else &#123;          return null;      &#125;  &#125;\n","categories":["面试","代码随想录"],"tags":["双指针","二叉树","二叉搜索树"]},{"title":"代码随想录算法训练营第二十天-669修剪二叉搜索树、108将有序数组转换为二叉搜索树、538把二叉搜索树转换为累加树","url":"/posts/d99de55b/","content":"\n\n前言状态：669 通过，但是有更简单的方法。108AC。538 没有思路，看了解题思路写出来了。\n\n\n更新\n\n\n24-06-09 初始记录\n\n初步题解\n669 修剪二叉搜索树\n题目链接：(https://leetcode.cn/problems/trim-a-binary-search-tree)\n\t/**     * 思路：查找节点，删除节点     *      * @param root 根节点     * @param low  区间左范围     * @param high 区间右范围     * @return     */    public static TreeNode trimBST(TreeNode root, int low, int high) &#123;        if (root == null) &#123;            return root;        &#125;        // 先剪枝        cut(root, low, high);        // 再减单个        return travel(root, low, high);    &#125;    private static TreeNode travel(TreeNode root, int low, int high) &#123;        if (root == null) &#123;            return root;        &#125;        if (low &lt;= root.val &amp;&amp; root.val &lt;= high) &#123;            root.left = travel(root.left, low, high);            root.right = travel(root.right, low, high);        &#125; else &#123;            if (root.left == null) &#123;                return root.right;            &#125; else if (root.right == null) &#123;                return root.left;            &#125; else &#123;                // 删除这个节点                // 1.右子树补位(找到右子树的最左侧节点)                TreeNode cur = root.right;                while (cur.left != null) &#123;                    cur = cur.left;                &#125;                cur.left = root.left;                root = root.right;                return root;            &#125;        &#125;        root.left = travel(root.left, low, high);        root.right = travel(root.right, low, high);        return root;    &#125;    private static void cut(TreeNode root, int low, int high) &#123;        if (root == null) &#123;            return;        &#125;        // 整条剪掉        if (root.val &gt; high) &#123;            root.right = null;            root.left = trimBST(root.left, low, high);        &#125;        if (root.val &lt; low) &#123;            root.left = null;            root.right = trimBST(root.right, low, high);        &#125;        cut(root.left, low, high);        cut(root.right, low, high);    &#125;// 因为时间复杂度太高，后面又写了一个版本，但是这个版本AC不了public static TreeNode trimBST(TreeNode root, int low, int high) &#123;          if (root == null) &#123;              return root;          &#125;            if (root.val &gt; high) &#123;  \t\t\treturn root.left;              // return trimBST(root.left, low, high);          &#125;          if (root.val &lt; low) &#123;              // 继续向右遍历  \t\t\treturn root.right;              // return trimBST(root.right, low, high);          &#125;            if (low &lt;= root.val &amp;&amp; root.val &lt;= high) &#123;              root.left = trimBST(root.left, low, high);              root.right = trimBST(root.right, low, high);          &#125;            while (root != null &amp;&amp; (root.val &lt; low || root.val &gt; high)) &#123;              if (root.left == null) &#123;                  root = root.right;              &#125; else if (root.right == null) &#123;                  root = root.left;              &#125; else &#123;                  // 删除这个节点                  // 1.右子树补位(找到右子树的最左侧节点)                  TreeNode cur = root.right;                  while (cur.left != null) &#123;                      cur = cur.left;                  &#125;                  cur.left = root.left;                  root = root.right;              &#125;          &#125;          return root;      &#125;\n108 将有序数组转换为二叉搜索树\n题目链接：(https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)\npublic static TreeNode sortedArrayToBST(int[] nums) &#123;      if (nums.length == 0) &#123;          return null;      &#125;      return sortedDFS(nums, 0, nums.length);  &#125;    private static TreeNode sortedDFS(int[] nums, int i, int j) &#123;      if (i &gt;= j) &#123;          return null;      &#125;        int mid = (j - i) / 2 + i;      TreeNode treeNode = new TreeNode(nums[mid]);      treeNode.left = sortedDFS(nums, i, mid);      treeNode.right = sortedDFS(nums , mid + 1, j);      return treeNode;  &#125;\n538 把二叉搜索树转换为累加树\n题目链接：(https://leetcode.cn/problems/convert-bst-to-greater-tree)\n/**   * 看了题解之后写出来的   * 思路：   * 1.二叉搜索树，中序遍历（左中右）有序   * 2.要按倒序相加，遍历方向相反   * 3.取一个指针指向前节点不断累加   */  TreeNode pre = new TreeNode(0);  public TreeNode convertBST(TreeNode root) &#123;      getTreeNodeTravel(root);      return root;  &#125;    private void getTreeNodeTravel(TreeNode root) &#123;      if (root == null) &#123;          return;      &#125;        getTreeNodeTravel(root.right);        root.val = pre.val + root.val;      pre = root;      getTreeNodeTravel(root.left);  &#125;\n看解析\n669 修剪二叉搜索树\n题目链接/文章讲解： https://programmercarl.com/0669.%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html\n视频讲解： [https://www.bilibili.com/video/BV17P41177ud](https://www.bilibili.com/video/BV17P41177ud\n看了题解发现是下面两行导致不能 AC。这里不能直接剪掉，忽略了情况。\n并且用了下面的继续递归，就不用再删除节点了。\nif (root.val &gt; high) &#123;  \treturn root.left;      // return trimBST(root.left, low, high);  &#125;  if (root.val &lt; low) &#123;      // 继续向右遍历  \treturn root.right;      // return trimBST(root.right, low, high);  &#125;  \n正确方法（🥴好难）：\npublic static TreeNode trimBST(TreeNode root, int low, int high) &#123;      if (root == null) &#123;          return root;      &#125;      if (root.val &gt; high) &#123;          return trimBST(root.left, low, high);      &#125;      if (root.val &lt; low) &#123;           return trimBST(root.right, low, high);      &#125;      if (low &lt;= root.val &amp;&amp; root.val &lt;= high) &#123;          root.left = trimBST(root.left, low, high);          root.right = trimBST(root.right, low, high);      &#125;      return root;  &#125;\n108 将有序数组转换为二叉搜索树\n题目链接/文章讲解： https://programmercarl.com/0108.%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html\n视频讲解：[https://www.bilibili.com/video/BV1uR4y1X7qL](https://www.bilibili.com/video/BV1uR4y1X7qL\n538 把二叉搜索树转换为累加树\n题目链接/文章讲解： https://programmercarl.com/0538.%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91.html\n视频讲解：https://www.bilibili.com/video/BV1d44y1f7wP\n","categories":["面试","代码随想录"],"tags":["二叉树","二叉搜索树","累加树"]},{"title":"代码随想录算法训练营第二十一天-理论基础、77组合","url":"/posts/ff56c28f/","content":"\n\n前言状态：理论基础总结在 [[面试-数据结构和算法]] 中。\n\n\n更新\n\n\n24-05-10 初始记录\n\n初步题解\n77 组合\n题目链接：(https://leetcode.cn/problems/combinations/)\npublic List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123;      List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();      List&lt;Integer&gt; list = new ArrayList&lt;&gt;();      combineDFS(1, n, k, list, result);      return result;  &#125;    /**   * * @param start 当前开始节点   * @param n n   * @param k k   * @param list 每个list   * @param result 最后的结果   */  private void combineDFS(int start, int n, int k, List&lt;Integer&gt; list, List&lt;List&lt;Integer&gt;&gt; result) &#123;      if (list.size() == k) &#123;          List&lt;Integer&gt; resultOne = new ArrayList&lt;&gt;(k);          resultOne.addAll(list);          result.add(resultOne);          return;      &#125;        for (int j = start; j &lt;= n; j++) &#123;          list.add(j);          combineDFS(j + 1, n, k, list, result);          list.remove(list.size() - 1);      &#125;  &#125;\n看解析\n77 组合\n题目链接/文章讲解：https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html\n视频讲解：https://www.bilibili.com/video/BV1ti4y1L7cv\n剪枝操作：https://www.bilibili.com/video/BV1wi4y157er\npublic List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123;      List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();      List&lt;Integer&gt; list = new ArrayList&lt;&gt;();      combineDFS(1, n, k, list, result);      return result;  &#125;    /**   * * @param start 当前开始节点   * @param n n   * @param k k   * @param list 每个list   * @param result 最后的结果   */  private void combineDFS(int start, int n, int k, List&lt;Integer&gt; list, List&lt;List&lt;Integer&gt;&gt; result) &#123;      if (list.size() == k) &#123;          List&lt;Integer&gt; resultOne = new ArrayList&lt;&gt;(k);          resultOne.addAll(list);          result.add(resultOne);          return;      &#125;  \t// 附带剪枝操作    for (int j = start; j &lt;= (n - (k - list.size())) + 1; j++) &#123;          list.add(j);          combineDFS(j + 1, n, k, list, result);          list.remove(list.size() - 1);      &#125;  &#125;\n","categories":["面试","代码随想录"],"tags":["回溯算法"]},{"title":"代码随想录算法训练营第二十二天-216组合总和III、17电话号码的字母组合","url":"/posts/82bed832/","content":"\n\n前言状态：216 可以 AC。17 看了部分解析写出来的。\n\n\n更新\n\n\n24-06-10 初始记录\n\n初步题解\n216 组合总和 III\n题目链接：(https://leetcode.cn/problems/combination-sum-iii)\npublic class LE22 &#123;      public static void main(String[] args) &#123;          List&lt;List&lt;Integer&gt;&gt; combinationSum3 = combinationSum3(9, 45);          for (List&lt;Integer&gt; integerList : combinationSum3) &#123;              System.out.println(Arrays.toString(integerList.stream().mapToInt(n -&gt; n).toArray()));          &#125;      &#125;        public static List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) &#123;          // 结果集          List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();          // 单个结果          List&lt;Integer&gt; list = new ArrayList&lt;&gt;();            combinationSum(1, k, n, 0, list, result);          return result;      &#125;        private static void combinationSum(int start, int k, int n, int sum, List&lt;Integer&gt; list, List&lt;List&lt;Integer&gt;&gt; result) &#123;          // 剪枝操作          if (sum &gt; n) &#123;              return;          &#125;            if (list.size() == k) &#123;              if (sum == n) &#123;                  List&lt;Integer&gt; resultOne = new ArrayList&lt;&gt;(list);                  result.add(resultOne);              &#125;              return;          &#125;            for (int j = start; j &lt;= 9 - (k - list.size()) + 1; j++) &#123;              list.add(j);              combinationSum(j + 1, k, n, sum + j, list, result);              list.remove(list.size() - 1);          &#125;      &#125;  &#125;\n17 电话号码的字母组合\n题目链接：(https://leetcode.cn/problems/letter-combinations-of-a-phone-number)\n/**   * @param digits 按键数组   * @return 结果   */  public static List&lt;String&gt; letterCombinations(String digits) &#123;      List&lt;String&gt; list = new ArrayList&lt;&gt;();      String[] buttonList = &#123;&quot;&quot;, &quot;&quot;, &quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;, &quot;jkl&quot;, &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;&#125;;        if (digits == null || &quot;&quot;.equals(digits)) &#123;          return list;      &#125;        combinations(0, digits, buttonList, &quot;&quot;, list);      return list;  &#125;    /**   * * @param i 遍历的层数   */  private static void combinations(int i, String digits, String[] buttonList, String str, List&lt;String&gt; list) &#123;      if (i == digits.length()) &#123;          list.add(str);          return;      &#125;        int digit = Integer.parseInt(digits.charAt(i) + &quot;&quot;);      String letter = buttonList[digit];      for (int j = 0; j &lt; letter.length(); j++) &#123;          str+=letter.charAt(j);          combinations(i + 1, digits, buttonList, str, list);          str = str.substring(0, str.length() - 1);      &#125;  &#125;\n看解析\n216 组合总和 III\n题目链接/文章讲解：(https://programmercarl.com/0216.组合总和III.html)\n视频讲解：https://www.bilibili.com/video/BV1wg411873x\n17 电话号码的字母组合\n题目链接/文章讲解：(https://programmercarl.com/0017.电话号码的字母组合.html)\n视频讲解：https://www.bilibili.com/video/BV1yV4y1V7Ug\n","categories":["面试","代码随想录"],"tags":["回溯算法"]},{"title":"代码随想录算法训练营第十九天-235二叉搜索树的最近公共祖先、701二叉搜索树中的插入操作、450删除二叉搜索树中的节点","url":"/posts/49e785ab/","content":"\n\n前言状态：235、701AC，701 还有更简单的写法。450 通过失败。\n\n\n更新\n\n\n24-06-09 初始记录\n\n初步题解\n235 二叉搜索树的最近公共祖先\n题目链接：(https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree)\n看了一部分的解析。主要在于当我们从上向下去递归遍历，第一次遇到 cur 节点是数值在 [q, p] 区间中，那么 cur 就是 q 和 p 的最近公共祖先。\npublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;      if (p.val &lt; q.val) &#123;          return lowestCommonAncestorTravel(root, p, q);      &#125; else &#123;          return lowestCommonAncestorTravel(root, q, p);      &#125;  &#125;    private TreeNode lowestCommonAncestorTravel(TreeNode root, TreeNode p, TreeNode q) &#123;      if (root == null || (p.val &lt;= root.val &amp;&amp; root.val &lt;= q.val)) &#123;          return root;      &#125; else if (root.val &gt; q.val) &#123;          return lowestCommonAncestor(root.left, p, q);      &#125; else &#123;          return lowestCommonAncestor(root.right, p, q);      &#125;  &#125;\n701 二叉搜索树中的插入操作\n题目链接：(https://leetcode.cn/problems/insert-into-a-binary-search-tree/description/)\n// 用双指针TreeNode pre;  public TreeNode insertIntoBST(TreeNode root, int val) &#123;      if (pre == null) &#123;          if (root == null) &#123;              return new TreeNode(val);          &#125;      &#125; else &#123;          if (root == null) &#123;              if (pre.val &gt; val)&#123;                  pre.left = new TreeNode(val);              &#125; else if (pre.val &lt; val) &#123;  \t                pre.right = new TreeNode(val);              &#125;              return root;          &#125;      &#125;      pre = root;        if (root.val &gt; val) &#123;          insertIntoBST(root.left, val);      &#125; else if (root.val &lt; val) &#123;          insertIntoBST(root.right, val);      &#125;        return root;  &#125;\n450 删除二叉搜索树中的节点\n题目链接：(https://leetcode.cn/problems/delete-node-in-a-bst)\n想的是左子树顶位子的情况。看了解析用了右子树顶位，好像确实好理解一点。（包括讲解中的普通二叉树删除，也是用了右子树顶位）\n// 这样子用例85不能通过public TreeNode deleteNode(TreeNode root, int key) &#123;      // 为空直接返回      if (root == null) &#123;          return root;      &#125;        if (root.val == key) &#123;          if (root.left == null) &#123;              root = root.right;          &#125; else if (root.right == null) &#123;              root = root.left;          &#125; else &#123;          // 应该是这里写得不对            TreeNode right = root.right;              TreeNode leftRight = root.left.right;              root = root.left;              if (leftRight != null) &#123;                  root.right = leftRight;                  root.right.right = right;              &#125; else &#123;                  root.right = right;              &#125;          &#125;          return root;      &#125;        if (root.val &gt; key) &#123;          root.left = deleteNode(root.left, key);      &#125; else &#123;          root.right = deleteNode(root.right, key);      &#125;        return root;  &#125;\n看解析\n235 二叉搜索树的最近公共祖先\n题目链接/文章讲解：https://programmercarl.com/0235.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html\n视频讲解：[https://www.bilibili.com/video/BV1Zt4y1F7ww](https://www.bilibili.com/video/BV1Zt4y1F7ww\n701 二叉搜索树中的插入操作\n题目链接/文章讲解：https://programmercarl.com/0701.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.html\n视频讲解：https://www.bilibili.com/video/BV1Et4y1c78Y\n// 文章中给的简化版本，确实这样子思路更清晰了    public TreeNode insertIntoBST(TreeNode root, int val) &#123;        if (root == null) // 如果当前节点为空，也就意味着val找到了合适的位置，此时创建节点直接返回。            return new TreeNode(val);                    if (root.val &lt; val)&#123;            root.right = insertIntoBST(root.right, val); // 递归创建右子树        &#125;else if (root.val &gt; val)&#123;            root.left = insertIntoBST(root.left, val); // 递归创建左子树        &#125;        return root;    &#125;\n450 删除二叉搜索树中的节点\n题目链接/文章讲解：https://programmercarl.com/0450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html\n视频讲解：https://www.bilibili.com/video/BV1tP41177us\npublic TreeNode deleteNode(TreeNode root, int key) &#123;  if (root == null) return root;  if (root.val == key) &#123;    if (root.left == null) &#123;      return root.right;    &#125; else if (root.right == null) &#123;      return root.left;    &#125; else &#123;    // 只有这部分不一样      TreeNode cur = root.right;      while (cur.left != null) &#123;        cur = cur.left;      &#125;      cur.left = root.left;      root = root.right;      return root;    &#125;  &#125;  if (root.val &gt; key) root.left = deleteNode(root.left, key);  if (root.val &lt; key) root.right = deleteNode(root.right, key);  return root;&#125;\n","categories":["面试","代码随想录"],"tags":["二叉树","二叉搜索树"]},{"title":"代码随想录算法训练营第二十三天-39组合总和、40组合总和II、131分割回文串","url":"/posts/2f09909f/","content":"\n\n前言状态：39AC 但是可以继续优化剪枝。40AC。131 分割没有做过，直接看解析了（动态规划求回文这个没有看，后面刷到动态规划再研究）。\n\n\n更新\n\n\n24-06-11 初始记录\n\n初步题解\n39 组合总和\n题目链接：(https://leetcode.cn/problems/combination-sum)\npublic static List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;      List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();      List&lt;Integer&gt; resultOne = new ArrayList&lt;&gt;();        combinationSumDFS(0, 0, target, candidates, resultOne, result);      return result;  &#125;      private static void combinationSumDFS(int startIndex, int sum, int target, int[] candidates, List&lt;Integer&gt; resultOne, List&lt;List&lt;Integer&gt;&gt; result) &#123;      if (sum &gt;= target) &#123;          if (target == sum) &#123;              result.add(new ArrayList&lt;&gt;(resultOne));          &#125;          return;      &#125;        for (int i = startIndex; i &lt; candidates.length; i++) &#123;          resultOne.add(candidates[i]);          combinationSumDFS(i, sum + candidates[i], target, candidates, resultOne, result);          resultOne.remove(resultOne.size() - 1);      &#125;  &#125;\n40 组合总和 II\n题目链接：(https://leetcode.cn/problems/combination-sum-ii)\npublic static List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123;      Arrays.sort(candidates);        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();      List&lt;Integer&gt; resultOne = new ArrayList&lt;&gt;();        combinationSum2DFS(0, 0, target, candidates, resultOne, result);      return result;  &#125;    /**   * 思路：   * 1. 和上题差不多。但是数组变成有重复元素的了。   * 2. 想法是每层遍历的时候，去重   */  private static void combinationSum2DFS(int startIndex, int sum, int target, int[] candidates, List&lt;Integer&gt; resultOne, List&lt;List&lt;Integer&gt;&gt; result) &#123;      if (sum == target) &#123;          result.add(new ArrayList&lt;&gt;(resultOne));          return;      &#125;        for (int i = startIndex; i &lt; candidates.length &amp;&amp; sum + candidates[i] &lt;= target; i++) &#123;\t\t// 在单层的数组内去重        if (i - 1 &gt;= startIndex &amp;&amp; candidates[i] == candidates[i - 1]) &#123;              continue;          &#125;          resultOne.add(candidates[i]);          combinationSum2DFS(i + 1, sum + candidates[i], target, candidates, resultOne, result);          resultOne.remove(resultOne.size() - 1);      &#125;  &#125;\n131 分割回文串\n题目链接：(https://leetcode.cn/problems/palindrome-partitioning)\n看解析\n39 组合总和\n题目链接/文章讲解：(https://programmercarl.com/0039.组合总和.html)\n视频讲解：(https://www.bilibili.com/video/BV1KT4y1M7HJ/)\n本来以为只要 return 就不用优化了（好像没有什么关系，还是会继续往下走），但是题解中说可以减少一次进入递归。\npublic static List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;      // 要剪枝必须要排序      Arrays.sort(candidates);        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();      List&lt;Integer&gt; resultOne = new ArrayList&lt;&gt;();        combinationSumDFS(0, 0, target, candidates, resultOne, result);      return result;  &#125;      private static void combinationSumDFS(int startIndex, int sum, int target, int[] candidates, List&lt;Integer&gt; resultOne, List&lt;List&lt;Integer&gt;&gt; result) &#123;      if (target == sum) &#123;          result.add(new ArrayList&lt;&gt;(resultOne));          return;      &#125;        // for循环的判断做了剪枝优化处理      for (int i = startIndex; i &lt; candidates.length &amp;&amp; sum + candidates[i] &lt;= target; i++) &#123;          resultOne.add(candidates[i]);          combinationSumDFS(i, sum + candidates[i], target, candidates, resultOne, result);          resultOne.remove(resultOne.size() - 1);      &#125;  &#125;\n40 组合总和 II\n题目链接/文章讲解：(https://programmercarl.com/0040.组合总和II.html)\n视频讲解：(https://www.bilibili.com/video/BV12V4y1V73A/)\n\n在 candidates[i] == candidates[i - 1] 相同的情况下：\n\n\nused[i - 1] == true，说明同一树枝 candidates[i - 1] 使用过\n\n\nused[i - 1] == false，说明同一树层 candidates[i - 1] 使用过\n\n\n131 分割回文串\n题目链接/文章讲解：(https://programmercarl.com/0131.分割回文串.html)\n视频讲解：(https://www.bilibili.com/video/BV1c54y1e7k6/)\npublic static List&lt;List&lt;String&gt;&gt; partition(String s) &#123;      List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;();      List&lt;String&gt; string = new ArrayList&lt;&gt;();      partitionDFS(0, s, string, result);      return result;  &#125;    private static void partitionDFS(int startIndex, String s, List&lt;String&gt; string, List&lt;List&lt;String&gt;&gt; result) &#123;      if (startIndex &gt;= s.length()) &#123;          result.add(new ArrayList&lt;&gt;(string));      &#125;        for (int i = startIndex; i &lt; s.length(); i++) &#123;          String substring = s.substring(startIndex, i + 1);          if (!isPartition(substring)) &#123;              continue;          &#125;          string.add(substring);          partitionDFS(i + 1, s, string, result);          string.remove(string.size() - 1);      &#125;  &#125;    /**   * 判断传入字符串是否为回文字符串   * @param substring 截取的字符串   * @return 结果   */  private static boolean isPartition(String substring) &#123;      for (int i = 0, j= substring.length() - 1; i &lt; j; i++, j--) &#123;          if (substring.charAt(i) != substring.charAt(j)) &#123;              return false;          &#125;      &#125;      return true;  &#125;\n// 优化版 动态规划法class Solution &#123;    List&lt;List&lt;String&gt;&gt; result;    LinkedList&lt;String&gt; path;    boolean[][] dp;    public List&lt;List&lt;String&gt;&gt; partition(String s) &#123;        result = new ArrayList&lt;&gt;();        char[] str = s.toCharArray();        path = new LinkedList&lt;&gt;();        dp = new boolean[str.length + 1][str.length + 1];        isPalindrome(str);        backtracking(s, 0);        return result;    &#125;    public void backtracking(String str, int startIndex) &#123;        if (startIndex &gt;= str.length()) &#123;            //如果起始位置大于s的大小，说明找到了一组分割方案            result.add(new ArrayList&lt;&gt;(path));        &#125; else &#123;            for (int i = startIndex; i &lt; str.length(); ++i) &#123;                if (dp[startIndex][i]) &#123;                    //是回文子串，进入下一步递归                    //先将当前子串保存入path                    path.addLast(str.substring(startIndex, i + 1));                    //起始位置后移，保证不重复                    backtracking(str, i + 1);                    path.pollLast();                &#125; else &#123;                    //不是回文子串，跳过                    continue;                &#125;            &#125;        &#125;    &#125;    //通过动态规划判断是否是回文串,参考动态规划篇 52 回文子串    public void isPalindrome(char[] str) &#123;        for (int i = 0; i &lt;= str.length; ++i) &#123;            dp[i][i] = true;        &#125;        for (int i = 1; i &lt; str.length; ++i) &#123;            for (int j = i; j &gt;= 0; --j) &#123;                if (str[j] == str[i]) &#123;                    if (i - j &lt;= 1) &#123;                        dp[j][i] = true;                    &#125; else if (dp[j + 1][i - 1]) &#123;                        dp[j][i] = true;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;\n","categories":["面试","代码随想录"],"tags":["回溯算法"]},{"title":"代码随想录算法训练营第二十四天-93复原IP地址、78子集、90子集II","url":"/posts/c27b36b8/","content":"\n\n前言状态：93 可以 AC。78、90AC。\n\n\n更新\n\n\n24-06-11 初始记录\n\n初步题解\n93 复原 IP 地址\n题目链接：(https://leetcode.cn/problems/restore-ip-addresses)\n解的时候不知道单字符串怎么操作了，加了一个数组。慢了很多。\npublic static List&lt;String&gt; restoreIpAddresses(String s) &#123;      List&lt;String&gt; result = new ArrayList&lt;&gt;();      List&lt;String&gt; temp = new ArrayList&lt;&gt;();          if (s.length() &lt; 4 || s.length() &gt; 12)&#123;          return result;      &#125;        restoreIpAddressesDFS(0, temp, s, result);      return result;  &#125;    /**   * * @param startIndex 开始Index   * @param s 输入的s   * @param result 切割的字符串集   */  private static void restoreIpAddressesDFS(int startIndex, List&lt;String&gt; temp, String s, List&lt;String&gt; result) &#123;      if (startIndex &gt;= s.length() &amp;&amp; temp.size() == 4) &#123;          String resultOne = String.join(&quot;.&quot;, temp);          result.add(resultOne);      &#125;        for (int i = startIndex; i &lt; s.length() &amp;&amp; Integer.parseInt(s.substring(startIndex, i + 1)) &lt; 256; i++) &#123;          // 8 为 substring 的取值就在 1 - 3之间          String substring = s.substring(startIndex, i + 1);          if (substring.length() &lt; 1 || substring.length() &gt; 3) &#123;              continue;          &#125;          if (substring.length() &gt; 1 &amp;&amp; substring.startsWith(&quot;0&quot;)) &#123;              continue;          &#125;          temp.add(substring);          restoreIpAddressesDFS(i + 1, temp, s, result);          temp.remove(temp.size() - 1);      &#125;  &#125;\n78 子集\n题目链接：(https://leetcode.cn/problems/subsets)\npublic static List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123;      List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();      List&lt;Integer&gt; resultOne = new ArrayList&lt;&gt;();        // 排序      Arrays.sort(nums);          subsetsDFS(0, nums, resultOne, result);      return result;  &#125;    /**   * 这个和之前的区别在于，如果转化成一颗树。之前只要求叶子节点。这个全部都要   * 而且还要不重复（😗写错了，看成90的题了。这题还要更简单一点。） * @param startIndex 起始index   */private static void subsetsDFS(int startIndex, int[] nums, List&lt;Integer&gt; resultOne, List&lt;List&lt;Integer&gt;&gt; result) &#123;        result.add(new ArrayList&lt;&gt;(resultOne));      for (int i = startIndex; i &lt; nums.length; i++) &#123;          resultOne.add(nums[i]);          subsetsDFS(i + 1, nums, resultOne, result);          resultOne.remove(resultOne.size() - 1);      &#125;  &#125;\n90 子集 II\n题目链接：(https://leetcode.cn/problems/subsets-ii)\npublic static List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123;      List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();      List&lt;Integer&gt; resultOne = new ArrayList&lt;&gt;();        // 排序      Arrays.sort(nums);        subsetsDFS(0, nums, resultOne, result);      return result;  &#125;    /**   * @param startIndex 起始index   */private static void subsetsDFS(int startIndex, int[] nums, List&lt;Integer&gt; resultOne, List&lt;List&lt;Integer&gt;&gt; result) &#123;      result.add(new ArrayList&lt;&gt;(resultOne));        for (int i = startIndex; i &lt; nums.length; i++) &#123;          if (i - 1 &gt;= startIndex &amp;&amp; nums[i] == nums[i - 1]) &#123;              continue;          &#125;          resultOne.add(nums[i]);          subsetsDFS(i + 1, nums, resultOne, result);          resultOne.remove(resultOne.size() - 1);      &#125;  &#125;\n看解析\n93 复原 IP 地址\n题目链接/文章讲解：(https://programmercarl.com/0093.复原IP地址.html)\n视频讲解：(https://www.bilibili.com/video/BV1XP4y1U73i/)\nclass Solution &#123;    List&lt;String&gt; result = new ArrayList&lt;String&gt;();\tStringBuilder stringBuilder = new StringBuilder();\tpublic List&lt;String&gt; restoreIpAddresses(String s) &#123;\t\trestoreIpAddressesHandler(s, 0, 0);\t\treturn result;\t&#125;\t// number表示stringbuilder中ip段的数量\tpublic void restoreIpAddressesHandler(String s, int start, int number) &#123;\t\t// 如果start等于s的长度并且ip段的数量是4，则加入结果集，并返回\t\tif (start == s.length() &amp;&amp; number == 4) &#123;\t\t\tresult.add(stringBuilder.toString());\t\t\treturn;\t\t&#125;\t\t// 如果start等于s的长度但是ip段的数量不为4，或者ip段的数量为4但是start小于s的长度，则直接返回\t\tif (start == s.length() || number == 4) &#123;\t\t\treturn;\t\t&#125;\t\t// 剪枝：ip段的长度最大是3，并且ip段处于[0,255]\t\tfor (int i = start; i &lt; s.length() &amp;&amp; i - start &lt; 3 &amp;&amp; Integer.parseInt(s.substring(start, i + 1)) &gt;= 0\t\t\t\t&amp;&amp; Integer.parseInt(s.substring(start, i + 1)) &lt;= 255; i++) &#123;\t\t\t// 如果ip段的长度大于1，并且第一位为0的话，continue\t\t\tif (i + 1 - start &gt; 1 &amp;&amp; s.charAt(start) - &#x27;0&#x27; == 0) &#123;\t\t\t\tcontinue;\t\t\t&#125;\t\t\tstringBuilder.append(s.substring(start, i + 1));\t\t\t// 当stringBuilder里的网段数量小于3时，才会加点；如果等于3，说明已经有3段了，最后一段不需要再加点\t\t\tif (number &lt; 3) &#123;\t\t\t\tstringBuilder.append(&quot;.&quot;);\t\t\t&#125;\t\t\tnumber++;\t\t\trestoreIpAddressesHandler(s, i + 1, number);\t\t\tnumber--;\t\t\t// 删除当前stringBuilder最后一个网段，注意考虑点的数量的问题\t\t\t// 主要这里没有写出来❗\t\t\tstringBuilder.delete(start + number, i + number + 2);\t\t&#125;\t&#125;&#125;\n78 子集\n题目链接/文章讲解：(https://programmercarl.com/0078.子集.html)\n视频讲解：(https://www.bilibili.com/video/BV1U84y1q7Ci)\n90 子集 II\n题目链接/文章讲解：(https://programmercarl.com/0090.子集II.html)\n视频讲解：(https://www.bilibili.com/video/BV1vm4y1F71J)\n","categories":["面试","代码随想录"],"tags":["回溯算法"]},{"title":"代码随想录算法训练营第二十五天-491递增子序列 、46全排列 、47全排列 II","url":"/posts/f191c36/","content":"\n\n前言状态：491 超时。46AC。47 不是很对，要看解析，主要是去重那一步。\n\n\n更新\n\n\n24-06-11 初始记录24-06-12 完成\n\n初步题解\n491 递增子序列\n题目链接：(https://leetcode.cn/problems/non-decreasing-subsequences)\n超时了，主要是去重那一步应该。\npublic static List&lt;List&lt;Integer&gt;&gt; findSubsequences(int[] nums) &#123;      List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();      List&lt;Integer&gt; resultOne = new ArrayList&lt;&gt;();        findSubsequencesDFS(0 , nums, resultOne, result);      return result;  &#125;    private static void findSubsequencesDFS(int startIndex, int[] nums, List&lt;Integer&gt; resultOne, List&lt;List&lt;Integer&gt;&gt; result) &#123;      // 先这样判断是否重复      if (resultOne.size() &gt;= 2 &amp;&amp; !result.contains(resultOne)) &#123;          result.add(new ArrayList&lt;&gt;(resultOne));      &#125;        for (int i = startIndex; i &lt; nums.length; i++) &#123;          if (resultOne.size() != 0 &amp;&amp; resultOne.get(resultOne.size() - 1) &gt; nums[i]) &#123;              continue;          &#125;          resultOne.add(nums[i]);           findSubsequencesDFS(i + 1, nums, resultOne, result);          resultOne.remove(resultOne.size() - 1);      &#125;  &#125;\n46 全排列\n题目链接：(https://leetcode.cn/problems/permutations/description/)\n// 排列每个变量都要统计，所以不需要startIndexpublic static List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;      List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();      List&lt;Integer&gt; resultOne = new ArrayList&lt;&gt;();        if (nums == null || nums.length == 0) &#123;          return result;      &#125;        permuteDFS(nums, resultOne, result);      return result;  &#125;    private static void permuteDFS(int[] nums, List&lt;Integer&gt; resultOne, List&lt;List&lt;Integer&gt;&gt; result) &#123;      if (resultOne.size() == nums.length) &#123;          result.add(new ArrayList&lt;&gt;(resultOne));          return;      &#125;        for (int i = 0; i &lt; nums.length; i++) &#123;          if (resultOne.contains(nums[i])) &#123;              continue;          &#125;          resultOne.add(nums[i]);          permuteDFS(nums, resultOne, result);          resultOne.remove(resultOne.size() - 1);      &#125;  &#125;\n47 全排列 II\n题目链接：(leetcode.cn/problems/permutations-ii/)\n/**   * 和上一题唯一的区别就是数组元素重复。   * 所以不能用数组直接统计，得用index记录这个是否被记过   * 还有点缺陷。重复元素会按不同下标被重复计入.   * 和之前一样，单层元素不能重复。   * @param nums nums   * @return 结果   */  public static List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123;      List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();      List&lt;Integer&gt; resultOne = new ArrayList&lt;&gt;();          if (nums == null || nums.length == 0) &#123;          return result;      &#125;        Arrays.sort(nums);      permuteUniqueDFS(nums, new ArrayList&lt;&gt;(), resultOne, result);      return result;  &#125;    private static void permuteUniqueDFS(int[] nums, List&lt;Integer&gt; resultIndex, List&lt;Integer&gt; resultOne, List&lt;List&lt;Integer&gt;&gt; result) &#123;      if (resultOne.size() == nums.length) &#123;          result.add(new ArrayList&lt;&gt;(resultOne));          return;      &#125;        // 判断这层有没有使用过这个数字，和LE491一样      HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;();      // set记录下标      for (int i = 0; i &lt; nums.length; i++) &#123;          if (resultIndex.contains(i)) &#123;              continue;          &#125;          if (set.contains(nums[i])) &#123;              continue;          &#125;          resultIndex.add(i);          resultOne.add(nums[i]);          set.add(nums[i]);          permuteUniqueDFS(nums, resultIndex, resultOne, result);          resultOne.remove(resultOne.size() - 1);          resultIndex.remove(resultIndex.size() - 1);      &#125;  &#125;\n看题解\n491 递增子序列\n(https://programmercarl.com/0491.递增子序列.html)\n视频讲解：(https://www.bilibili.com/video/BV1EG4y1h78v)\n加了剪枝操作的优化。\npublic static List&lt;List&lt;Integer&gt;&gt; findSubsequences(int[] nums) &#123;      List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();      List&lt;Integer&gt; resultOne = new ArrayList&lt;&gt;();        findSubsequencesDFS(0 , nums, resultOne, result);      return result;  &#125;    private static void findSubsequencesDFS(int startIndex, int[] nums, List&lt;Integer&gt; resultOne, List&lt;List&lt;Integer&gt;&gt; result) &#123;       if (resultOne.size() &gt;= 2) &#123;          result.add(new ArrayList&lt;&gt;(resultOne));      &#125;        HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();      for (int i = startIndex; i &lt; nums.length; i++) &#123;          if (resultOne.size() != 0 &amp;&amp; resultOne.get(resultOne.size() - 1) &gt; nums[i]) &#123;              continue;          &#125;          // 判断这层是否使用          if (map.getOrDefault(nums[i], 0) &gt;= 1) &#123;              continue;          &#125;          map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);          resultOne.add(nums[i]);          findSubsequencesDFS(i + 1, nums, resultOne, result);          resultOne.remove(resultOne.size() - 1);      &#125;  &#125;\n46 全排列\n(https://programmercarl.com/0046.全排列.html)\n视频讲解：(https://www.bilibili.com/video/BV19v4y1S79W)\n47 全排列 II\n(https://programmercarl.com/0047.全排列II.html)\n视频讲解：(https://www.bilibili.com/video/BV1R84y1i7Tm)\npublic static List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123;      List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();      List&lt;Integer&gt; resultOne = new ArrayList&lt;&gt;();          if (nums == null || nums.length == 0) &#123;          return result;      &#125;        Arrays.sort(nums);      permuteUniqueDFS(nums, new boolean[]&#123;&#125;, resultOne, result);      return result;  &#125;    /**   * 用数组标记因为这个树更像一个矩阵   * 数组可以标记nums又可以标记层数   */  private static void permuteUniqueDFS(int[] nums, boolean[] used, List&lt;Integer&gt; resultOne, List&lt;List&lt;Integer&gt;&gt; result) &#123;      if (resultOne.size() == nums.length) &#123;          result.add(new ArrayList&lt;&gt;(resultOne));          return;      &#125;        // set记录下标      for (int i = 0; i &lt; nums.length; i++) &#123;          // 记录了index值，即这index被使用了（这里可以理解）          if (used[i]) &#123;              continue;          &#125;            // 如果这个数值和前面的数值相同          // 首先一定要排序，这样nums数组中的前面一个节点，就一定是被用过了          // 然后现在到这个节点，前面一个节点的状态是false(这里横向看)，说明已经回溯了。节点已经被添加，跳过这层          if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]) &#123;              continue;          &#125;          // 这层是否使用过          used[i] = true;          resultOne.add(nums[i]);          permuteUniqueDFS(nums, used, resultOne, result);          resultOne.remove(resultOne.size() - 1);          used[i] = false;      &#125;  &#125;\n","categories":["面试","代码随想录"],"tags":["回溯算法"]},{"title":"代码随想录算法训练营第二十六天-332重新安排行程、51N皇后、 37解数独","url":"/posts/cf86d462/","content":"\n\n前言状态：今天的题，看标注说都很难，先去总结再做这个。时间不太够了，都是直接看的解析然后做题。\n\n\n更新\n\n\n24-06-12 初始记录24-06-13 完成题解\n\n初步题解\n332 重新安排行程\n题目链接：(https://leetcode.cn/problems/reconstruct-itinerary)\n51N 皇后\n题目链接：(https://leetcode.cn/problems/n-queens)\n37 解数独\n题目链接：(https://leetcode.cn/problems/sudoku-solver)\n看解析\n332 重新安排行程\n题目链接/文章讲解：(https://programmercarl.com/0332.重新安排行程.html)\n解法超时（第 80 个用例）：加上剪枝不会超时。别的思路都和清晰，但是剪枝那一步有点难想到。\npublic static List&lt;String&gt; findItinerary(List&lt;List&lt;String&gt;&gt; tickets) &#123;      List&lt;String&gt; resultOne = new ArrayList&lt;&gt;();        // 按字典排序排序（目的地排序）    tickets.sort(Comparator.comparing(o -&gt; o.get(1)));      // 用于记录当前节点是否使用      boolean[] flagList = new boolean[tickets.size()];        // 行程必须从JFK开始      resultOne.add(&quot;JFK&quot;);        // 这里如果找到一条就直接返回      findItineraryDFS(flagList, tickets, resultOne);      return resultOne;  &#125;    private static boolean findItineraryDFS(boolean[] flagList, List&lt;List&lt;String&gt;&gt; tickets, List&lt;String&gt; resultOne) &#123;      // tickets为线路数，节点数要加1      if (resultOne.size() == tickets.size() + 1) &#123;          return true;      &#125;        for (int i = 0; i &lt; tickets.size(); i++) &#123;  \t    // 为了防止超时加上这句的剪枝\t    // 如果这张票和上张票相同 且上张票没用过 说明是从上张票回溯过来的，已经遍历过这种情况，跳过\t    if(i &gt; 0 &amp;&amp; tickets.get(i).equals(tickets.get(i - 1)) &amp;&amp; !flagList[i - 1]) continue;\t            if (!flagList[i] &amp;&amp; tickets.get(i).get(0).equals(resultOne.get(resultOne.size() - 1))) &#123;              resultOne.add(tickets.get(i).get(1));              flagList[i] = true;                if (findItineraryDFS(flagList, tickets, resultOne)) &#123;                  return true;              &#125;                resultOne.remove(resultOne.size() - 1);              flagList[i] = false;          &#125;      &#125;      return false;  &#125;\n51N 皇后\n题目链接/文章讲解：(https://programmercarl.com/0051.N皇后.html)\npublic class LE51 &#123;      public static void main(String[] args) &#123;          solveNQueens(4);      &#125;        public static List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123;          List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;();          char[][] chars = new char[n][n];            for (char[] c : chars) &#123;              Arrays.fill(c, &#x27;.&#x27;);          &#125;            solveNQueensDFS(0, n, chars, result);          return result;      &#125;        /**       * @param row    行数       * @param n      棋盘大小       * @param chars  棋盘摆法       * @param result 结果       */      private static void solveNQueensDFS(int row, int n, char[][] chars, List&lt;List&lt;String&gt;&gt; result) &#123;          if (row == n) &#123;              List&lt;String&gt; list = new ArrayList&lt;&gt;();              for (char[] aChar : chars) &#123;                  list.add(String.copyValueOf(aChar));              &#125;              result.add(list);              return;          &#125;            for (int i = 0; i &lt; n; i++) &#123;              if (isValid(row, i, n, chars)) &#123;                  chars[row][i] = &#x27;Q&#x27;;                  solveNQueensDFS(row + 1, n, chars, result);                  chars[row][i] = &#x27;.&#x27;;              &#125;          &#125;      &#125;        private static boolean isValid(int row, int col, int n, char[][] chars) &#123;          // 检查列          for (int i = 0; i &lt; row; ++i) &#123;              if (chars[i][col] == &#x27;Q&#x27;) &#123;                  return false;              &#125;          &#125;            // 检查45度对角线          for (int i = row - 1, j = col - 1; i &gt;= 0 &amp;&amp; j &gt;= 0; i--, j--) &#123;              if (chars[i][j] == &#x27;Q&#x27;) &#123;                  return false;              &#125;          &#125;            // 检查135度对角线          for (int i = row - 1, j = col + 1; i &gt;= 0 &amp;&amp; j &lt;= n - 1; i--, j++) &#123;              if (chars[i][j] == &#x27;Q&#x27;) &#123;                  return false;              &#125;          &#125;          return true;      &#125;  &#125;\n37 解数独\n题目链接/文章讲解：(https://programmercarl.com/0037.解数独.html)\npublic class LE37 &#123;      public void solveSudoku(char[][] board) &#123;          solveSudokuDFS(board);      &#125;        private boolean solveSudokuDFS(char[][] board) &#123;          for (int i = 0; i &lt; board.length; i++) &#123;              for (int j = 0; j &lt; board[0].length; j++) &#123;                  if (board[i][j] != &#x27;0&#x27;) &#123;                      continue;                  &#125;                  for (char k = &#x27;1&#x27;; k &lt;= &#x27;9&#x27;; k++) &#123;                      if (isvalid(i, j, k, board)) &#123;                          board[i][j] = k;                            if (solveSudokuDFS(board)) &#123;                              return true;                          &#125;                          board[i][j] = &#x27;.&#x27;;                      &#125;                  &#125;                  // 走到这一行，说明直到递归完毕，都没有返回true   return false;              &#125;            &#125;            return true;      &#125;        /**       * 判断棋盘放入这个数是否合法       *       * @param i     行       * @param j     列       * @param k     值       * @param board 棋盘       * @return 是否合法       */      private boolean isvalid(int i, int j, char k, char[][] board) &#123;          // 行中是否含有这个数          // 列中是否含有这个数          for (int index = 0; index &lt; board.length; index++) &#123;              if (board[i][index] == k) &#123;                  return false;              &#125;              if (board[index][j] == k) &#123;                  return false;              &#125;          &#125;            // 9宫格中是否含有这个数          int x = (i / 3) * 3;          int y = (j / 3) * 3;            for (int indexX = x; indexX &lt; x + 3; indexX++) &#123;              for (int indexY = y; indexY &lt; y + 3; indexY++) &#123;                  if (board[indexX][indexY] == k) &#123;                      return false;                  &#125;              &#125;          &#125;            return true;      &#125;  &#125;\n","categories":["面试","代码随想录"],"tags":["回溯算法"]},{"title":"代码随想录算法训练营第二十七天-455分发饼干、376摆动序列、53最大子序和","url":"/posts/dc3e282a/","content":"\n\n前言状态：455AC、376、53 都需要看解析，感觉贪心上来都是一点思路都没有，可能题做的不够多。\n\n\n更新\n\n\n24-06-13 初始记录\n\n初步题解\n455 分发饼干\n题目链接：(https://leetcode.cn/problems/assign-cookies)\n属于小饼干优先。\npublic static void main(String[] args) &#123;      int[] g = &#123;10,9,8,7&#125;;      int[] s = &#123;5,6,7,8&#125;;      System.out.println(findContentChildren(g, s));  &#125;      /**   * 感觉上s从小排序，g从小排序。按序分配就行。   * @param g 孩子胃口   * @param s 饼干数   * @return 结果   */  public static int findContentChildren(int[] g, int[] s) &#123;      Arrays.sort(s);      Arrays.sort(g);        int count = 0;      for (int i = 0, j = 0; i &lt; g.length &amp;&amp; j &lt; s.length; j++) &#123;          if (g[i] &lt;= s[j]) &#123;              count++;              i++;          &#125;      &#125;      return count;  &#125;\n376 摆动序列\n题目链接：(https://leetcode.cn/problems/wiggle-subsequence)\n没有思路。看了一点点解析，画图。把坡删了。（但是又忽略了单调坡的情况，具体题解在看解析部分）\npublic int wiggleMaxLength(int[] nums) &#123;      if (nums.length &lt;= 1) &#123;          return nums.length;      &#125;      int count = 0;      if (nums[0] != nums[1]) &#123;          if (nums.length == 2) &#123;              return 2;          &#125;          count = 2;      &#125; else &#123;          count = 1;      &#125;      for (int i = 2; i &lt; nums.length; i++) &#123;          int slopePre = nums[i - 1] - nums[i - 2];          int slope = nums[i] - nums[i - 1];            if ((slopePre &gt;= 0  &amp;&amp; slope &lt; 0) || (slopePre &lt;= 0 &amp;&amp; slope &gt; 0)) &#123;              count++;          &#125;      &#125;      return count;  &#125;\n53 最大子序和\n题目链接：(https://leetcode.cn/problems/maximum-subarray)\n没有思路。看了部分解析，说是连续和如果出现负数，直接抛弃，从下一个数开始。\n// 思路是连续和为负，就直接抛弃连续和  public int maxSubArray(int[] nums) &#123;      int max = Integer.MIN_VALUE;      int sum = 0;        for (int num : nums) &#123;          sum += num;          max = Math.max(sum, max);            if (sum &lt; 0) &#123;              sum = 0;          &#125;      &#125;        return max;  &#125;\n看解析\n455 分发饼干\n解析：(https://programmercarl.com/0455.分发饼干.html)\n有两种思路，大饼干优先满足胃口大的；小饼干优先满足胃口小的。\n376 摆动序列\n解析：(https://programmercarl.com/0376.摆动序列.html)\n思路：\n\n\n怎样算有峰值 (preDiff &gt;= 0  &amp;&amp; curDiff &lt; 0) || (preDiff &lt;= 0 &amp;&amp; curDiff &gt; 0)\n\n\n数组首怎么计数：默认加上一个平节点，即 preDiff 为 0\n\n\n单调坡度有平坡：只在坡度进行更新的时候，才把前一个坡值进行记录\n\n\npublic int wiggleMaxLength(int[] nums) &#123;      if (nums.length &lt;= 1) &#123;          return nums.length;      &#125;        // 当前的差值      int curDiff = 0;      // 前一个坡的差值      int preDiff = 0;      int count = 1;        for (int i = 1; i &lt; nums.length; i++) &#123;          curDiff = nums[i] - nums[i - 1];            if ((preDiff &gt;= 0  &amp;&amp; curDiff &lt; 0) || (preDiff &lt;= 0 &amp;&amp; curDiff &gt; 0)) &#123;              count++;              // 只有坡度更新才记录坡值              preDiff = curDiff;          &#125;      &#125;        return count;  &#125;\n还有一个偷懒版本是先去重，再找坡。但是要循环两次，时间复杂度变高。\n53 最大子序和\n解析：(https://programmercarl.com/0053.最大子序和.html)\n","categories":["面试","代码随想录"],"tags":["贪心算法"]},{"title":"代码随想录算法训练营第二十八天-122买卖股票的最佳时机II、55 跳跃游戏、45跳跃游戏II、1005K次取反后最大化的数组和","url":"/posts/8d31312e/","content":"\n\n前言状态：122AC，55 看了题解 AC，45AC，题解代码更简单一点\n\n\n更新\n\n\n24-06-14 初始记录\n\n初步题解\n122 买卖股票的最佳时机 II\n题目链接：(https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii)\n画图很简单\n/**   * 就是算所有增区间的值   * @param prices 列表   * @return 股票金额   */  public int maxProfit(int[] prices) &#123;      int sum = 0;        for (int i = 1; i &lt; prices.length; i++) &#123;          if (prices[i] &gt;= prices[i - 1]) &#123;              sum +=prices[i] - prices[i - 1];          &#125;      &#125;        return sum;  &#125;\n55 跳跃游戏\n题目链接：(https://leetcode.cn/problems/jump-game/)\n没有思路。看了部分题解，说是求覆盖最大的范围。\npublic static boolean canJump(int[] nums) &#123;      int maxIndex = 0;        for (int i = 0; i &lt; nums.length; i++) &#123;          if (i &gt; maxIndex) &#123;              return false;          &#125;  \t\t// 这里看了题解优化了一下        maxIndex = Math.max(nums[i] + i, maxIndex);          if (maxIndex &gt;= nums.length - 1)&#123;              return true;          &#125;      &#125;      return false;  &#125;  \n45 跳跃游戏 II\n题目链接：(https://leetcode.cn/problems/jump-game-ii/)\n/**   * 假设每次都跳跃区间内最远的距离   * @param nums 数组   * @return 结果   */  public static int jump(int[] nums) &#123;      int maxIndex = 0;      int maxJ = 0;      int count = 0;        if (nums.length == 1) &#123;          return count;      &#125;        for (int i = 0; i &lt; nums.length;) &#123;          if (i + nums[i] &gt;= nums.length - 1) &#123;              count++;              return count;          &#125;            for (int j = i + 1; j &lt;= i + nums[i] &amp;&amp; j &lt; nums.length; j++) &#123;                if (j + nums[j] &gt;= maxIndex) &#123;                  maxIndex = j + nums[j];                  maxJ = j;              &#125;          &#125;          count++;          i = maxJ;      &#125;        return count;  &#125;\n1005K 次取反后最大化的数组和\n题目链接：(https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations)\n/**   * 思路：可以多次选择同一个数字，返回最大和，说明可以先排序   * 1. 从小到大排列， 把所有负数变正   * 2. 还有次数剩余。奇数次剩余，就把绝对值最小的翻转一次。   *   * @param nums 数组   * @param k 翻转次数   * @return 结果   */  public static int largestSumAfterKNegations(int[] nums, int k) &#123;      Arrays.sort(nums);      int minAbs = Integer.MAX_VALUE;      int index = 0;      int sum = 0;        for (int i = 0; i &lt; nums.length; i++) &#123;            if (Math.abs(nums[i]) &lt; minAbs) &#123;              minAbs = Math.min(minAbs, Math.abs(nums[i]));              index = i;          &#125;            if (k &gt; 0 &amp;&amp; nums[i] &lt; 0) &#123;              nums[i] = -nums[i];              k--;          &#125;          sum += nums[i];      &#125;        if (k % 2 == 1) &#123;          sum -= 2 * nums[index];      &#125;        return sum;  &#125;\n看解析\n122 买卖股票的最佳时机 II\n解析：(https://programmercarl.com/0122.买卖股票的最佳时机II.html)\n55 跳跃游戏\n解析：(https://programmercarl.com/0055.跳跃游戏.html)\n45 跳跃游戏 II\n解析：(https://programmercarl.com/0045.跳跃游戏II.html)\n题解的思路在于增加覆盖范围。每更新一次覆盖范围，就结果 +1（这里比较绕，但是这样就不用双层循环了）。\n简化版本：\npublic int jump(int[] nums) &#123;      int result = 0;      // 当前覆盖的最远距离下标      int end = 0;      // 下一步覆盖的最远距离下标      int temp = 0;      for (int i = 0; i &lt;= end &amp;&amp; end &lt; nums.length - 1; ++i) &#123;          temp = Math.max(temp, i + nums[i]);          // 可达位置的改变次数就是跳跃次数          if (i == end) &#123;              end = temp;              result++;          &#125;      &#125;      return result;  &#125;\n1005K 次取反后最大化的数组和\n解析：(https://programmercarl.com/1005.K次取反后最大化的数组和.html)\n","categories":["面试","代码随想录"],"tags":["贪心算法"]},{"title":"代码随想录算法训练营第二十九天-134加油站、135分发糖果、860柠檬水找零、406根据身高重建队列","url":"/posts/d65e5e22/","content":"\n\n前言状态：134AC 但是时间比较长、135 看了部分题解 AC、860AC（但是 HashMap）、406 不会\n\n\n更新\n\n\n24-06-14 初始记录\n\n初步题解\n134 加油站\n题目链接：(https://leetcode.cn/problems/gas-station)\n/**   * 思路：有两个 式子 相-，可以得到一个数组。   * 然后求这个数组，sum &gt; 0 的情况。   * 环形循环不好处理，直接将路线延长一倍   * @param gas 汽油   * @param cost 消耗   * @return 结果   */  public static int canCompleteCircuit(int[] gas, int[] cost) &#123;      int startIndex = -1;      int sum = 0;        for (int i = 0, j = i; i &lt; gas.length * 2 &amp;&amp; startIndex &lt; gas.length; i++, j++) &#123;          if (startIndex != -1 &amp;&amp; i - startIndex == gas.length) &#123;              break;          &#125;            if (sum == 0 &amp;&amp; i &lt; gas.length) &#123;              startIndex = i;          &#125;            if (j &gt;= gas.length) &#123;              j = i - gas.length;          &#125;            // 获取本段路的剩余情况          int diff = gas[j] - cost[j];            sum += diff;            if (sum &lt; 0) &#123;              startIndex = -1;              sum = 0;          &#125;      &#125;        return startIndex;  &#125;\n135 分发糖果\n题目链接：(https://leetcode.cn/problems/candy)\n提前看了一部分解析，不能同时考虑左右（没看真的想不到🤕）。但是很慢。看了解析，和我写的一样。\npublic static int candy(int[] ratings) &#123;      if (ratings.length &lt;= 1) &#123;          return ratings.length;      &#125;        int[] result = new int[ratings.length];      result[0] = 1;      for (int i = 1; i &lt; ratings.length; i++) &#123;          if (ratings[i] &gt; ratings[i - 1]) &#123;              result[i] = result[i - 1] + 1;          &#125; else &#123;              result[i] = 1;          &#125;      &#125;      System.out.println(Arrays.toString(result));          for (int i = ratings.length - 2; i &gt;= 0; i--) &#123;          if (ratings[i] &gt; ratings[i + 1] &amp;&amp; result[i] &lt;= result[i + 1]) &#123;              result[i] = result[i + 1] + 1;          &#125;      &#125;      System.out.println(Arrays.toString(result));        return Arrays.stream(result).sum();  &#125;\n860 柠檬水找零\n题目链接：(https://leetcode.cn/problems/lemonade-change)\npublic boolean lemonadeChange(int[] bills) &#123;      Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();      map.put(5, 0);      map.put(10, 0);      map.put(20, 0);        for (int bill : bills) &#123;          // 收钱          map.put(bill, map.get(bill) + 1);            if (bill == 10) &#123;              if (map.get(5) &lt; 1) &#123;                  return false;              &#125;              map.put(5, map.get(5) - 1);          &#125;          if (bill == 20) &#123;              if (map.get(5) &gt;= 1 &amp;&amp; map.get(10) &gt;= 1) &#123;                  map.put(5, map.get(5) - 1);                  map.put(10, map.get(10) - 1);              &#125; else if (map.get(5) &gt;= 3)&#123;                  map.put(5, map.get(5) - 3);              &#125; else &#123;                  return false;              &#125;          &#125;      &#125;      return true;  &#125;\n406 根据身高重建队列\n题目链接：(https://leetcode.cn/problems/queue-reconstruction-by-height)\n没有思路，虽然看了提示要和 135 一样分开处理，但是还是没有思路。\n看解析\n134 加油站\n题解：(https://programmercarl.com/0134.加油站.html)\n看了解析，明明思路是一样的，就是慢一点。❗忽略了一个点，如果总和大于 0， 那么必定有解。无语解析里那个 totalSum 真的太妙了。\npublic static int canCompleteCircuit(int[] gas, int[] cost) &#123;      int curSum = 0;      int totalSum = 0;      int index = 0;      for (int i = 0; i &lt; gas.length; i++) &#123;          curSum += gas[i] - cost[i];          totalSum += gas[i] - cost[i];          if (curSum &lt; 0) &#123;              index = (i + 1) % gas.length;              curSum = 0;          &#125;      &#125;      if (totalSum &lt; 0) &#123;          return -1;      &#125;      return index;  &#125;\n135 分发糖果\n解析：(https://programmercarl.com/0135.分发糖果.html)\n860 柠檬水找零\n解析：(https://programmercarl.com/0860.柠檬水找零.html)\n不用HashMap，直接两个int进行加减🤡public boolean lemonadeChange(int[] bills) &#123;      int five = 0;      int ten = 0;      for (int bill : bills) &#123;          if (bill == 5) &#123;              five++;          &#125; else if (bill == 10) &#123;              ten++;              five--;              if (five &lt; 0) &#123;                  return false;              &#125;          &#125; else if (bill == 20) &#123;              if (five &gt;= 1 &amp;&amp; ten &gt;= 1) &#123;                  five--;                  ten--;              &#125; else if (five &gt;= 3) &#123;                  five -= 3;              &#125; else &#123;                  return false;              &#125;          &#125;      &#125;      return true;  &#125;\n406 根据身高重建队列\n解析：(https://programmercarl.com/0406.根据身高重建队列.html)\n/**   * 思路: 先按身高排序, 然后根据前面的人数进行队列调整。   * @param people 队伍需求   * @return 排号的队列   */  public int[][] reconstructQueue(int[][] people) &#123;      Arrays.sort(people, (o1, o2) -&gt; &#123;          if (o1[0] == o2[0]) &#123;              return o1[1] - o2[1];          &#125;          return o2[0] - o1[0];      &#125;);  \t// 队列调整用LinkedList。按顺序在下标位置插入，这样每次插入的值都在相应的下标上。\t// 把旧的大于等于它的值往后调整，不影响之前的排序。    LinkedList&lt;int[]&gt; list = new LinkedList&lt;&gt;();        for (int[] person : people) &#123;          list.add(person[1], person);      &#125;        return list.toArray(new int[people.length][]);  &#125;\n","categories":["面试","代码随想录"],"tags":["贪心算法"]},{"title":"代码随想录算法训练营第三十天-452用最少数量的箭引爆气球、435无重叠区间、763划分字母区间","url":"/posts/253a4d3a/","content":"\n\n前言状态：可能因为熬夜，思绪都是飘的。都是看了解析写出来的。\n\n\n更新\n\n\n24-06-15 初始记录\n\n初步题解\n452 用最少数量的箭引爆气球\n题目链接：(https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons)\n没有思路。\n435 无重叠区间\n题目链接：(https://leetcode.cn/problems/non-overlapping-intervals)\n还是没有思路。\n763 划分字母区间\n题目链接：(https://leetcode.cn/problems/partition-labels/description/)\n直接看的解析。\n看解析\n452 用最少数量的箭引爆气球\n解析：(https://programmercarl.com/0452.用最少数量的箭引爆气球.html)\n/**   * 思路：看了一下题目就是要求重叠的区间   * 关键在于更新最小右边界   * @param points 坐标点   * @return 最小弓箭数   */  public static int findMinArrowShots(int[][] points) &#123;      Arrays.sort(points, Comparator.comparingInt(o -&gt; o[0]));        if (points.length &lt;= 1) &#123;          return points.length;      &#125;        int count = 1;      for (int i = 1; i &lt; points.length; i++) &#123;          if (points[i][0] &gt; points[i - 1][1]) &#123;              count++;          &#125; else &#123;              points[i][1] = Math.min(points[i][1], points[i - 1][1]);          &#125;      &#125;      return count;  &#125;\n435 无重叠区间\n解析：(https://programmercarl.com/0435.无重叠区间.html)\n/**   * 思路：和上一题差不多，找重叠的，然后移除了   * @param intervals 区间的集合   * @return 结果   */  public static int eraseOverlapIntervals(int[][] intervals) &#123;      Arrays.sort(intervals, Comparator.comparingInt(o -&gt; o[0]));        int count = 0;        if (intervals.length &lt;= 1) &#123;          return count;      &#125;        for (int i = 1; i &lt; intervals.length; i++) &#123;          if (intervals[i][0] &gt;= intervals[i - 1][1])&#123;          &#125; else &#123;              count++;              intervals[i][1] = Math.min(intervals[i][1], intervals[i - 1][1]);          &#125;      &#125;        return count;  &#125;\n763 划分字母区间\n解析：(https://programmercarl.com/0763.划分字母区间.html)\n/**   * 思路：   * 1. 找到每个字母的区间   * 2. 根据遍历中最远结束节点，更新切割位置   * @param s 字符串   * @return 结果   */  public List&lt;Integer&gt; partitionLabels(String s) &#123;      char[] chars = s.toCharArray();        // 记录每个字母最后出现的节点      int[] ints = new int[26];      Arrays.fill(ints, -1);      for (int i = 0; i &lt; chars.length; i++) &#123;          ints[chars[i] - &#x27;a&#x27;] = i;      &#125;        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();        int idx = 0;      // 记录上一个切割的位置（用于计算存入list的长度）      int last = -1;      for (int i = 0; i &lt; chars.length; i++) &#123;          // 把节点更新为要结束的地方          idx = Math.max(idx, ints[chars[i] - &#x27;a&#x27;]);          // 直到可以结束          if (i == idx) &#123;              list.add(i - last);              last = i;          &#125;      &#125;      return list;  &#125;\n","categories":["面试","代码随想录"],"tags":["贪心算法"]},{"title":"代码随想录算法训练营第三十一天-56合并区间、738单调递增的数字、968监控二叉树","url":"/posts/28ed1b79/","content":"\n\n前言状态：56、738AC。968 看提示说比较难，先去做贪心的总结。968 不会，直接看解析。\n\n\n更新\n\n\n24-06-17 初始记录\n\n初步题解\n56 合并区间\n题目链接：(https://leetcode.cn/problems/merge-intervals)\npublic static int[][] merge(int[][] intervals) &#123;      ArrayList&lt;int[]&gt; list = new ArrayList&lt;&gt;();      // 按左边界排序      Arrays.sort(intervals, (o1, o2) -&gt; &#123;          if (o1[0] == o2[0]) &#123;              return o1[1] - o2[1];          &#125;          return o1[0] - o2[0];      &#125;);        if (intervals.length &lt;= 1) &#123;          return intervals;      &#125;        int start = intervals[0][0];      int end = intervals[0][1];      for (int i = 1; i &lt; intervals.length; i++) &#123;          // 没有重合区间，将上一个合并区间加入list，并更新最新的合并区间          if (intervals[i][0] &gt; intervals[i - 1][1]) &#123;              list.add(new int[]&#123;start, end&#125;);              start = intervals[i][0];              end = intervals[i][1];          // 更新合并的右边界          &#125; else &#123;              end = Math.max(end, intervals[i][1]);              // 更新右边界              intervals[i][1] = end;          &#125;      &#125;      // 最后需要将最后一个合并区间加入      list.add(new int[]&#123;start, end&#125;);      return list.toArray(new int[list.size()][]);  &#125;\n738 单调递增的数字\n题目链接：(https://leetcode.cn/problems/monotone-increasing-digits)\npublic static int monotoneIncreasingDigits(int n) &#123;      String num = n + &quot;&quot;;      if (num.length() &lt;= 1) &#123;          return n;      &#125;        char[] chars = num.toCharArray();      for (int i = chars.length - 1; i &gt;= 1; i--) &#123;          if (chars[i - 1] &gt; chars[i]) &#123;              chars[i - 1]--;              // 从i开始都变成9              for (int j = i; j &lt; chars.length; j++) &#123;                  chars[j] = &#x27;9&#x27;;              &#125;          &#125;      &#125;        return Integer.parseInt(String.valueOf(chars));  &#125;// 优化了一下，感觉循环还是放外面好public static int monotoneIncreasingDigits(int n) &#123;      String num = n + &quot;&quot;;      if (num.length() &lt;= 1) &#123;          return n;      &#125;        int start = -1;      char[] chars = num.toCharArray();      for (int i = chars.length - 1; i &gt;= 1; i--) &#123;          if (chars[i - 1] &gt; chars[i]) &#123;              chars[i - 1]--;              start = i;  //          // 从i开始都变成9  //          for (int j = i; j &lt; chars.length; j++) &#123;  //              chars[j] = &#x27;9&#x27;;  //          &#125;          &#125;      &#125;      if (start != -1) &#123;          // 从i开始都变成9          for (int j = start; j &lt; chars.length; j++) &#123;              chars[j] = &#x27;9&#x27;;          &#125;      &#125;        return Integer.parseInt(String.valueOf(chars));  &#125;\n968 监控二叉树\n题目链接：(https://leetcode.cn/problems/binary-tree-cameras)\n看解析\n56 合并区间\n解析：(https://programmercarl.com/0056.合并区间.html)\n738 单调递增的数字\n解析：(https://programmercarl.com/0738.单调递增的数字.html)\n968 监控二叉树\n解析：(https://programmercarl.com/0968.监控二叉树.html)\n思路：本题要从叶子节点分析，贪心贪叶子节点的上一个节点为摄像头（这种情况下摄像头最少）。然后，根据节点状态，一共分了 3 种：0 无覆盖；1 有摄像头；2 有覆盖。按照下图的思路做题，就可以解出，还是比较难想的。\n内链：[[968监控二叉树图示.excalidraw]]\n外链：\nint res = 0;  public int minCameraCover(TreeNode root) &#123;      if (minCameraCoverTravel(root) == 0) &#123;          res++;      &#125;      return res;  &#125;    private int minCameraCoverTravel(TreeNode root) &#123;      if (root == null) &#123;          // 空节点默认为有覆盖的状态          return 2;      &#125;        // 后续遍历      int left = minCameraCoverTravel(root.left);      int right = minCameraCoverTravel(root.right);        // 前两个if可以互换      // 情况1      if (left == 2 &amp;&amp; right == 2) &#123;          return 0;      // 情况2，加一个摄像头   &#125; else if (left == 0 || right == 0) &#123;          res++;          return 1;      &#125; else &#123;          return 2;      &#125;  &#125;\n","categories":["面试","代码随想录"],"tags":["贪心算法"]},{"title":"代码随想录算法训练营第三十二天-509斐波那契数、70爬楼梯、746使用最小花费爬楼梯","url":"/posts/bae90a3d/","content":"\n\n前言状态：动态规划之前没有接触过，基本都不会。看了前面两题 746 按照解题方法 AC 了。\n\n\n更新\n\n\n24-06-18 初始记录\n\n初步题解\n509 斐波那契数\n题目链接：(https://leetcode.cn/problems/fibonacci-number)\n// 递归做法public int fib(int n) &#123;      if (n == 0) &#123;          return 0;      &#125;      if (n == 1) &#123;          return 1;      &#125;        return fib(n - 1) + fib(n - 2);  &#125;\n70 爬楼梯\n题目链接：(https://leetcode.cn/problems/climbing-stairs/)\n不会。\n746 使用最小花费爬楼梯\n题目链接：(https://leetcode.cn/problems/min-cost-climbing-stairs/)\n\n\n确定 dp[i] 的含义：爬到 i 台阶需要的最小花费\n\n\n递推公式：Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2])\n\n\ndp 数组的初始化 dp[0] = 0、dp[1] = 1\n\n\n遍历顺序：从前向后遍历。\n\n\n打印 dp 数组（用于 debug）\n\n\npublic static void main(String[] args) &#123;      int[] cost = &#123;1, 100, 1, 1, 1, 100, 1, 1, 100, 1&#125;;      minCostClimbingStairs(cost);  &#125;  public static int minCostClimbingStairs(int[] cost) &#123;      int[] dp = new int[cost.length + 1];      dp[0] = 0;      dp[1] = 0;        for (int i = 2; i &lt; dp.length; i++) &#123;          dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);      &#125;        System.out.println(Arrays.toString(dp));        return dp[cost.length];  &#125;\n看解析\n509 斐波那契数\n题解：(https://programmercarl.com/0509.斐波那契数.html)\n\n\n确定 dp[i] 的含义：第 i 个斐波那契数\n\n\n递推公式：dp[i] = dp[i - 1] + dp[i - 2]\n\n\ndp 数组的初始化 dp[0] = 1、dp[1] = 1\n\n\n遍历顺序：从前向后遍历。\n\n\n打印 dp 数组（用于 debug）\n\n\npublic static int fibBp(int n) &#123;      if (n &lt;= 1) &#123;          return n;      &#125;      int[] dp = new int[n + 1];      dp[0] = 0;      dp[1] = 1;      for (int i = 2; i &lt;= n; i++) &#123;          dp[i] = dp[i - 1] + dp[i - 2];      &#125;        System.out.println(Arrays.toString(dp));        return dp[n];  &#125;// 只维护两个数值的版本public int fib(int n) &#123;    if(n == 0) return 0;    if(n == 1) return 1;    int[] dp = new int[2];    dp[0] = 0;    dp[1] = 1;    for(int i = 2 ; i &lt; n+1 ; i++)&#123;        int sum  = dp[0] + dp[1];        dp[0] = dp[1];        dp[1] = sum;    &#125;    return dp[1];&#125;\n70 爬楼梯\n解析：(https://programmercarl.com/0070.爬楼梯.html)\n\n\n确定 dp[i] 的含义：爬 i 阶有几种方法\n\n\n递推公式：dp[i] = dp[i - 1] + dp[i - 2]这里有点难理解：因为走到 i 阶只有两种情况，1️⃣从 i - 2 到 i 走两步；2️⃣从 i - 1 到 i 走两步。所以到 i 阶的总方法数 : dp[i] = dp[i - 1] + dp[i - 2]\n\n\ndp 数组的初始化 dp[1] = 1、dp[2] = 2。根据题目描述，n &gt; 0 所以这里这么设置。\n\n\n遍历顺序：从前向后遍历。\n\n\n打印 dp 数组（用于 debug）\n\n\npublic int climbStairs(int n) &#123;      if (n &lt;= 2) &#123;          return n;      &#125;        int[] dp = new int[n + 1];      dp[1] = 1;      dp[2] = 2;      for (int i = 3; i &lt;= n; i++) &#123;          dp[i] = dp[i - 1] + dp[i - 2];      &#125;        return dp[n];  &#125;\n746 使用最小花费爬楼梯\n解析：(https://programmercarl.com/0746.使用最小花费爬楼梯.html)\n","categories":["面试","代码随想录"]},{"title":"代码随想录算法训练营第三十四天-01背包问题 二维、01背包问题 一维、416分割等和子集","url":"/posts/23390fe6/","content":"\n\n前言状态：前两题为背包基础题，直接看的题解。416 也是看的解析。\n\n\n更新\n\n\n24-06-20 初始记录\n\n初步题解\n416 分割等和子集\n题目链接：(https://leetcode.cn/problems/partition-equal-subset-sum)\n看解析\n01 背包问题 二维\n题目链接 + 解析：(https://programmercarl.com/背包理论基础01背包-1.html)\n\n\n确定 dp[i][j] 的含义：从下标为 [0-i] 的物品里任意取，放进容量为 j 的背包，价值总和最大是多少。\n\n\n递推公式：dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])（即，不存放当前物品/存放当前物品）\n\n\ndp 数组的初始化：dp[i][0] 均为 0，dp[0][j] 需要根据实际情况来。\n\n\n遍历顺序：从前向后遍历。\n\n\n打印 dp 数组（用于 debug）\n\n\npublic static void main(String[] args) &#123;      integerBreak(4, new int[][]&#123;&#123;1, 15&#125;, &#123;3, 20&#125;, &#123;4, 30&#125;&#125;);  &#125;    /**   * 二维数组解法   * @param n 背包大小   * @param item 物品及重量及价值   */public static void integerBreak(int n, int[][] item) &#123;      int[][] dp = new int[item.length][n + 1];        for (int i = 1; i &lt; dp[0].length &amp;&amp; n &gt;= item[0][0]; i++) &#123;          dp[0][i] = item[0][1];      &#125;        for (int i = 1; i &lt; item.length; i++) &#123;          for (int j = 1; j &lt;= n; j++) &#123;              if (j - item[i][0] &lt; 0) &#123;                  dp[i][j] = dp[i - 1][j];              &#125;else &#123;                  dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - item[i][0]] + item[i][1]);              &#125;          &#125;      &#125;        System.out.println(Arrays.deepToString(dp));  &#125;\n01 背包问题 一维\n题目链接 + 解析：(https://programmercarl.com/背包理论基础01背包-2)\n\n\n确定 dp[j] 的含义：从物品里任意取，放进容量为 j 的背包，价值总和最大是多少。\n\n\n递推公式：dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i])（即，要么等于原值，要么等于放入物品的值）\n\n\ndp 数组的初始化：dp[0] = 0。\n\n\n遍历顺序：从后向前遍历。（这里需要注意，因为递推公式内需要上一层的原值，只有倒序遍历，可以获取上一层的原值。）\n\n\n打印 dp 数组（用于 debug）\n\n\n/**   * 一维数组解法   * @param n 背包大小   * @param item 物品及重量及价值   */  public void integerBreak1(int n, int[][] item) &#123;      int[] dp = new int[n + 1];        for (int[] ints : item) &#123;          for (int j = dp.length - 1; j &gt;= ints[0]; j--) &#123;                dp[j] = Math.max(dp[j], dp[j - ints[0]] + ints[1]);          &#125;      &#125;        System.out.println(Arrays.toString(dp));  &#125;\n416 分割等和子集\n解析：(https://programmercarl.com/0416.分割等和子集.html)\n\n\n确定 dp[j] 的含义：从物品里任意取，求总量的最大值，判断是否等于 j 即 sum/2。这题要抽象，设置 i 位置的重量和价值都为 i\n\n\n递推公式：dp[j] = Math.max(dp[j], dp[j - weight[i]] + value[i])（如果 dp[j] == j 说明，集合中的子集总和正好可以凑成总和 j）\n\n\ndp 数组的初始化：因为是正整数数组，所以可以初始化为 0。\n\n\n遍历顺序：从后向前遍历。\n\n\n打印 dp 数组（用于 debug）\n\n\npublic boolean canPartition(int[] nums) &#123;      int sum = Arrays.stream(nums).sum();      if (sum % 2 != 0) &#123;          return false;      &#125;        int[] dp = new int[sum / 2 + 1];        for (int num : nums) &#123;          for (int j = dp.length - 1; j &gt;= num; j--) &#123;                dp[j] = Math.max(dp[j], dp[j - num] + num);          &#125;          if (dp[sum / 2] == sum / 2) &#123;              return true;          &#125;      &#125;      return false;  &#125;\n","categories":["面试","代码随想录"],"tags":["动态规划","01背包"]},{"title":"代码随想录算法训练营第三十五天-1049最后一块石头的重量 II、494目标和、474一和零","url":"/posts/bde30672/","content":"\n\n前言状态：1049 和昨天那题差不多。494、474。。。☠️动规还是先了解解法。后面刷别的题组的时候再说。\n\n\n更新\n\n\n24-06-21 初始记录\n\n初步题解\n1049 最后一块石头的重量 II\n题目链接：(https://leetcode.cn/problems/last-stone-weight-ii)\n本题可以抽象成让石头分成尽量相同的两堆，然后进行相撞。即背包大小为总和除以 2，求能放入的最大价值。\n\n\n确定 dp[i] 的含义：从石头里任取，背包大小为 i，能放入的最大价值。weight[i] = store[i]，value[i] = store[i]。\n\n\n递推公式：dp[i] = Math.max(dp[i], dp[i - weight[j]] + value[j])。\n\n\ndp 数组的初始化：dp[0] = 0。\n\n\n遍历顺序：从后向前遍历。\n\n\n打印 dp 数组（用于 debug）\n\n\npublic int lastStoneWeightII(int[] stones) &#123;      int sum = Arrays.stream(stones).sum();        int[] dp = new int[sum / 2 + 1];        for (int stone : stones) &#123;          for (int j = dp.length - 1; j &gt;= 0; j--) &#123;              if (j &gt;= stone) &#123;  \t\t\t    dp[j] = Math.max(dp[j], dp[j - stone] + stone);  \t\t\t&#125;         &#125;      &#125;        return sum - dp[sum / 2] * 2;  &#125;\n494 目标和\n题目链接：(https://leetcode.cn/problems/target-sum)\n完全没思路\n474 一和零\n题目链接：(https://leetcode.cn/problems/ones-and-zeroes)\n看不懂，题目都看不懂☠️\n看解析\n1049 最后一块石头的重量 II\n解析：(https://programmercarl.com/1049.最后一块石头的重量II.html)\n494 目标和\n解析：(https://programmercarl.com/0494.目标和.html)\n假设正数集合总和是 left，负数集合总和是 right。总和 sum = left + right。目标值 target = left - right。可以得到 left 即正数之和 = (sum + target)/2。\n本题是装满有几种方法。这是一个组合问题，用的解法就和之前不一样。\n\n\n确定 dp[i] 的含义：填满 i（包括 i）这么大容积的包，有 dp[i] 种方法\n\n\n递推公式：dp[j] += dp[j - nums[i]]。\n\n\n\n\n\n已经有一个 1（nums[i]） 的话，有 dp[4] 种方法 凑成 容量为 5 的背包。\n\n\n已经有一个 2（nums[i]） 的话，有 dp[3] 种方法 凑成 容量为 5 的背包。\n\n\n已经有一个 3（nums[i]） 的话，有 dp[2] 种方法 凑成 容量为 5 的背包\n\n\n已经有一个 4（nums[i]） 的话，有 dp[1] 种方法 凑成 容量为 5 的背包\n\n\n已经有一个 5 （nums[i]）的话，有 dp[0] 种方法 凑成 容量为 5 的背包\n\n\n那么凑整 dp[5] 有多少方法呢，也就是把 所有的 dp[j - nums[i]] 累加起来。\n\n\n\ndp 数组的初始化：dp[0] = 1。假设数组个数为 0，获取 dp[0]，就是 1。\n\n\n遍历顺序：从后向前遍历。\n\n\n打印 dp 数组（用于 debug）\n\n\npublic int findTargetSumWays(int[] nums, int target) &#123;      int sum = Arrays.stream(nums).sum();      if ((sum + target) % 2 == 1) &#123;          return 0;      &#125;        if (sum &lt; Math.abs(target)) &#123;          return 0;      &#125;        int left = (sum + target) / 2;      int[] dp = new int[left + 1];      dp[0] = 1;      for (int num : nums) &#123;          for (int j = dp.length - 1; j &gt;= num; j--) &#123;  \t\t    // 这里比较难理解            dp[j] += dp[j - num];          &#125;      &#125;        System.out.println(Arrays.toString(dp));        return dp[left];  &#125;\n474 一和零\n解析：(https://programmercarl.com/0474.一和零.html)\n\n\n确定 dp[i][j] 的含义：最多有 i 个 0 和 j 个 1 的 strs 的最大子集的大小为 dp[i][j]。物品的重量是 0 的个数，1 的个数。价值就是 1。（难点在二维数组。。反正看了解析又感觉懂了，自己写又不会☠️）\n\n\n递推公式：dp[i][j] = Math.max(dp[i][j], dp[i - x][j - y]) + 1。\n\n\ndp 数组的初始化：dp[0][0] = 0。\n\n\n遍历顺序：从后向前遍历。\n\n\n打印 dp 数组（用于 debug）\n\n\npublic int findMaxForm(String[] strs, int m, int n) &#123;      int[][] dp = new int[m + 1][n + 1];        // 这里x计算0的数量， y计算1的数量      int x, y;      for (String str : strs) &#123;          x = 0;          y = 0;          char[] chars = str.toCharArray();          for (char c : chars) &#123;              if (c == &#x27;0&#x27;) &#123;                  x++;              &#125; else &#123;                  y++;              &#125;          &#125;            for (int i = m; i &gt;= 0; i--) &#123;              for (int j = n; j &gt;= 0; j--) &#123;                  if (i &gt;= x &amp;&amp; j &gt;= y) &#123;                      dp[i][j] = Math.max(dp[i][j], dp[i - x][j - y] + 1);                  &#125;              &#125;          &#125;      &#125;      return dp[m][n];  &#125;\n","categories":["面试","代码随想录"],"tags":["动态规划","01背包"]},{"title":"代码随想录算法训练营第三十三天-62不同路径、63不同路径 II、343 整数拆分、96不同的二叉搜索树","url":"/posts/5da9e7f4/","content":"\n\n前言状态：62AC、63AC、343 不会。96 一刷先跳过。\n\n\n更新\n\n\n24-06-19 初始记录\n\n初步题解\n62 不同路径\n题目链接：(https://leetcode.cn/problems/unique-paths)\n\n\n确定 dp[m][n] 的含义：网格大小为 m x n 时的路径数\n\n\n递推公式：dp[m][n] = dp[m][n-1] + dp[m-1][n]\n\n\ndp 数组的初始化：所有纵列横列为 1 的，都是 1。\n\n\n遍历顺序：从前向后遍历。\n\n\n打印 dp 数组（用于 debug）\n\n\npublic static int uniquePaths(int m, int n) &#123;      int[][] dp = new int[m + 1][n + 1];        if (m &lt;= 1 || n &lt;= 1) &#123;          return 1;      &#125;          for (int i = 1; i &lt;= m; i++) &#123;          for (int j = 1; j &lt;= n; j++) &#123;              if (i == 1 || j == 1) &#123;                  dp[i][j] = 1;                  continue;              &#125;                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];          &#125;      &#125;            return dp[m][n];  &#125;\n63 不同路径 II\n题目链接：(https://leetcode.cn/problems/unique-paths-ii)\n这题的五部曲分析应该和上题一样。多了障碍格子，遇到障碍格子时，数计 0 （注意一下边界问题就行）。\npublic int uniquePathsWithObstacles(int[][] obstacleGrid) &#123;      int m = obstacleGrid.length;      int n = obstacleGrid[0].length;      int[][] dp = new int[m][n];        for (int i = 0; i &lt; m; i++) &#123;          for (int j = 0; j &lt; n; j++) &#123;              if (obstacleGrid[i][j] == 1) &#123;                  dp[i][j] = 0;                  continue;              &#125;                if (i == 0 &amp;&amp; j == 0) &#123;                dp[i][j] = 1;              &#125; else if (i == 0) &#123;                  dp[i][j] = dp[i][j - 1];              &#125; else if (j == 0) &#123;                  dp[i][j] = dp[i - 1][j];              &#125; else &#123;                  dp[i][j] = dp[i - 1][j] + dp[i][j - 1];              &#125;          &#125;      &#125;        // System.out.println(&quot;dp = &quot; + Arrays.deepToString(dp));        return dp[m - 1][n - 1];  &#125;\n343 整数拆分\n题目链接：(https://leetcode.cn/problems/integer-break/)\n\n\n确定 dp[i] 的含义：正整数 i 的拆分最大化乘积。\n\n\n递推公式：想不出来。🤕\n\n\ndp 数组的初始化：dp[2] = 1。\n\n\n遍历顺序：从前向后遍历。\n\n\n打印 dp 数组（用于 debug）\n\n\n96 不同的二叉搜索树\n题目链接：(https://leetcode.cn/problems/unique-binary-search-trees)\n看解析\n62 不同路径\n解析：(https://programmercarl.com/0062.不同路径.html)\n有一个状态压缩版本：\nclass Solution &#123;    public int uniquePaths(int m, int n) &#123;        // 在二维dp数组中，当前值的计算只依赖正上方和正左方，因此可以压缩成一维数组。        int[] dp = new int[n];        // 初始化，第一行只能从正左方跳过来，所以只有一条路径。        Arrays.fill(dp, 1);        for (int i = 1; i &lt; m; i ++) &#123;            // 第一列也只有一条路，不用迭代，所以从第二列开始            for (int j = 1; j &lt; n; j ++) &#123;                dp[j] += dp[j - 1]; // dp[j] = dp[j] (正上方)+ dp[j - 1] (正左方)            &#125;        &#125;        return dp[n - 1];    &#125;&#125;\n63 不同路径 II\n解析：(https://programmercarl.com/0063.不同路径II.html)\n343 整数拆分\n解析：(https://programmercarl.com/0343.整数拆分.html)\n不是很懂，一刷先跳过了。\npublic static int integerBreak(int n) &#123;      int[] dp = new int[n + 1];        dp[2] = 1;        for (int i = 3; i &lt;= n; i++) &#123;          for (int j = 1; j &lt;= i - j; j++) &#123;              // 这里的 j 其实最大值为 i-j,再大只不过是重复而已，              // 并且，在本题中，我们分析 dp[0], dp[1]都是无意义的，              // j 最大到 i-j,就不会用到 dp[0]与dp[1]              dp[i] = Math.max(dp[i], Math.max(j * (i - j), j * dp[i - j]));              // j * (i - j) 是单纯的把整数 i 拆分为两个数 也就是 i,i-j ，再相乘              //而j * dp[i - j]是将 i 拆分成两个以及两个以上的个数,再相乘。          &#125;      &#125;      return dp[n];  &#125;\n本题也可以用贪心，每次拆成 n 个 3，如果剩下是 4，则保留 4，然后相乘，但是这个结论需要数学证明其合理性！ 🥴本来想这么写的，但是好像想错了。具体的数学推导：(https://leetcode.cn/problems/integer-break/solutions/29098/343-zheng-shu-chai-fen-tan-xin-by-jyd/)\n96 不同的二叉搜索树\n解析：(https://programmercarl.com/0096.不同的二叉搜索树.html)\n","categories":["面试","代码随想录"],"tags":["动态规划"]},{"title":"代码随想录算法训练营第三十六天-完全背包、518零钱兑换 II、377组合总和 Ⅳ、CM70爬楼梯（进阶）","url":"/posts/b717497e/","content":"\n\n前言状态：看完完全组合的解析之后，完成 518 和 377。CM70就是377。\n\n\n更新\n\n\n24-06-22 初始记录\n\n初步题解\n518 零钱兑换 II\n题目链接：(https://leetcode.cn/problems/coin-change-ii/)\n\n\n确定 dp[i] 的含义：填满 i（包括 i）这么大容积的包，有 dp[i] 种方法\n\n\n递推公式：dp[i] += dp[i - coin]。\n\n\ndp 数组的初始化：dp[0] = 1。假设数组个数为 0，获取 dp[0]，就是 1。\n\n\n遍历顺序：从前向后遍历。\n\n\n打印 dp 数组（用于 debug）\n\n\n/**   * 思路：   * 1. 这是一个完全背包的题目（正序）   * 2. 求的是组合数量 dp[i] += dp[i - coin];   * @param amount 总数   * @param coins 硬币总和   * @return 有几种组合方法   */  public static int change(int amount, int[] coins) &#123;      // 填满 i（包括 i）这么大容积的包，有 `dp[i]` 种方法      int[] dp = new int[amount + 1];        dp[0] = 1;        for (int coin : coins) &#123;          for (int i = coin; i &lt; dp.length; i++) &#123;              dp[i] += dp[i - coin];          &#125;      &#125;        System.out.println(Arrays.toString(dp));        return dp[amount];  &#125;\n377 组合总和 Ⅳ\n题目链接：(https://leetcode.cn/problems/combination-sum-iv)\n如果求组合数就是外层 for 循环遍历物品，内层 for 遍历背包。\n如果求排列数就是外层 for 遍历背包，内层 for 循环遍历物品。\n/**   * 完全背包+排列 *   * @param nums   数组   * @param target 总数   * @return 有几种排列 */  public static int combinationSum4(int[] nums, int target) &#123;      int[] dp = new int[target + 1];        dp[0] = 1;      for (int i = 0; i &lt; dp.length; i++) &#123;          for (int num : nums) &#123;              if (i &gt;= num) &#123;                  dp[i] += dp[i - num];              &#125;          &#125;      &#125;        System.out.println(Arrays.toString(dp));        return dp[target];  &#125;\n70 爬楼梯 （进阶）\n题目链接：(https://kamacoder.com/problempage.php?pid=1067)\n就是完全背包 + 排列，解法和上题一模一样。nums 取值为 1- 每次最多爬的阶梯数量\n看解析\n完全背包\n有 N 件物品和一个最多能背重量为 W 的背包。第 i 件物品的重量是 weight[i]，得到的价值是 value[i] 。每件物品都有无限个（也就是可以放入背包多次），求解将哪些物品装入背包里物品价值总和最大。\n完全背包和 01 背包问题唯一不同的地方就是，每种物品有无限件。\n二维数组：\n\n\n递推公式：dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - item[i][0]] + item[i][1])（即，不重复存放当前物品/重复存放当前物品）\n\n\ndp 数组的初始化：dp[i][0] 均为 0。dp[0][j] 为第一格按背包大小取重复值。\n\n\n遍历顺序：从前向后遍历。\n\n\npublic static void main(String[] args) &#123;      integerBreak(4, new int[][]&#123;&#123;1, 15&#125;, &#123;3, 20&#125;, &#123;4, 30&#125;&#125;);  &#125;    public static void integerBreak(int n, int[][] item) &#123;      int[][] dp = new int[item.length][n + 1];        // 纵列初始化为0（数组定义，不用初始化）        // 横列初始化不一样了      for (int j = 1; j &lt; dp[0].length &amp;&amp; n &gt;= item[0][0]; j++) &#123;          dp[0][j] = j / item[0][0] * item[0][1];      &#125;        for (int i = 1; i &lt; item.length; i++) &#123;          for (int j = 1; j &lt;= n; j++) &#123;              if (j - item[i][0] &lt; 0) &#123;  \t            // 如果当前物品不能放入，背包值 = 当前值的前一列                dp[i][j] = dp[i - 1][j];              &#125; else &#123;  \t            // 如果当前物品可以放入\t\t\t\t// 比较前一列和（范围大小还是[0, i]，如果是 i - 1，范围大小就是[0, i - 1]）\t\t\t\t// 也就是说，包不包含这个数本身（可不可以重复计数）                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - item[i][0]] + item[i][1]);              &#125;          &#125;      &#125;        System.out.println(Arrays.deepToString(dp));  &#125;\n一维数组（状态压缩）：\n\n\n递推公式：dp[i] = Math.max(dp[i], dp[i - item[0]] + item[1]);\n\n\ndp 数组的初始化：dp[0] = 0\n\n\n遍历顺序：从前向后遍历。（而完全背包的物品是可以添加多次的，所以要从小到大去遍历。（😅老实说，看了好几几遍都没懂））\n\n\n这里完全背包一维 dp 数组可以交换遍历顺序：因为 dp[j] 是用到其左边的数据 dp[j - weight[i]] 的，而先遍历背包再遍历物品也是满足的。\n\n\npublic static void integerBreak1(int n, int[][] items) &#123;      int[] dp = new int[n + 1];      for (int[] item : items) &#123;          for (int i = 0; i &lt; dp.length; i++) &#123;              if (i &gt;= item[0]) &#123;                  dp[i] = Math.max(dp[i], dp[i - item[0]] + item[1]);              &#125;          &#125;      &#125;        System.out.println(Arrays.toString(dp));  &#125;\n518 零钱兑换 II\n解析：(https://programmercarl.com/0518.零钱兑换II.html)\n377 组合总和 Ⅳ\n解析：(https://programmercarl.com/0377.组合总和Ⅳ.html)\n70 爬楼梯 （进阶）\n解析：(https://programmercarl.com/0070.爬楼梯完全背包版本.html)\n","categories":["面试","代码随想录"],"tags":["动态规划","完全背包"]},{"title":"代码随想录算法训练营第三十七天-322零钱兑换、279完全平方数、139单词拆分","url":"/posts/f80db845/","content":"\n\n前言状态：322 递推公式看了题解。279 与 322 一样，AC 了。139 用回溯超时。\n\n\n更新\n\n\n24-06-25 初始记录\n\n初步题解\n322 零钱兑换\n题目链接：(https://leetcode.cn/problems/coin-change)\n\n\n确定 dp[i] 的含义：填满 i（包括 i）这么大容积的包，需要的最小个数为 dp[i]\n\n\n递推公式：dp[i] = Math.min(dp[i], dp[i - coin] + 1)。（这里比较难想，背包放这个硬币的计算为不放的结果加一）\n\n\ndp 数组的初始化：dp[0] = 0。背包大小为 0，方法数也为 0。（根据题中给出的示例 3）\n\n\n遍历顺序：从前向后遍历（完全背包）。\n\n\n打印 dp 数组（用于 debug）\n\n\n/**   * 思路：   * 1. 硬币获取可以重复（完全背包）   * @param coins 硬币数组   * @param amount 数量   * @return 结果   */  public static int coinChange(int[] coins, int amount) &#123;      // dp 表示凑成金额所需要的最小个数      int[] dp = new int[amount + 1];      Arrays.fill(dp, amount + 1);        dp[0] = 0;        for (int coin : coins) &#123;          for (int i = coin; i &lt; dp.length; i++) &#123;              if(dp[i - coin] != amount + 1) &#123;                  dp[i] = Math.min(dp[i], dp[i- coin] + 1);              &#125;           &#125;      &#125;        System.out.println(Arrays.toString(dp));        return dp[amount] == amount + 1 ? -1 : dp[amount];  &#125;\n279 完全平方数\n题目链接：(https://leetcode.cn/problems/perfect-squares)\n和上题完全一样，区别只有取值数组的值需要自己计算。\n/**   * 思路：背包大小为n，从1-根号n之间取数   * 1. 数可以重复取值，完全背包   *   * @param n 和为n   * @return 结果   */  public int numSquares(int n) &#123;      // dp[i] 表示和为n的完全平方数的最小数量      int[] dp = new int[n + 1];      Arrays.fill(dp, n + 1);        dp[0] = 0;      int num = (int) Math.sqrt(n);      for (int i = 1; i &lt;= num; i++) &#123;          for (int j = i * i; j &lt; dp.length; j++) &#123;              if (dp[j - i * i] != n + 1) &#123;                  dp[j] = Math.min(dp[j], dp[j - i * i] + 1);              &#125;          &#125;      &#125;        System.out.println(Arrays.toString(dp));        return dp[n];  &#125;\n139 单词拆分\n题目链接：(https://leetcode.cn/problems/word-break)\n// 回溯方法。这样写会超时🤕public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123;      wordDict.sort(Comparator.comparingInt(String::length));      return wordBreakBFS(s, wordDict, new ArrayList&lt;&gt;());  &#125;    public static boolean wordBreakBFS(String s, List&lt;String&gt; wordDict, List&lt;String&gt; word) &#123;      String join = String.join(&quot;&quot;, word);      if (s.length() &lt;= join.length()) &#123;          return s.equals(String.join(&quot;&quot;, word));      &#125; else if (!s.startsWith(join)) &#123;          return false;      &#125;        for (String string : wordDict) &#123;          word.add(string);          boolean b = wordBreakBFS(s, wordDict, word);          if (b) &#123;              return true;          &#125;          word.remove(word.size() - 1);      &#125;        return false;  &#125;\n看解析\n322 零钱兑换\n解析：(https://programmercarl.com/0322.零钱兑换.html)\n279 完全平方数\n解析：(https://programmercarl.com/0279.完全平方数.html)\n139 单词拆分\n解析：(https://programmercarl.com/0139.单词拆分.html)\n\n\n确定 dp[i] 的含义：字符串长度为 i，dp[i] 表示是否可以拆分，可以返回 true。\n\n\n递推公式：如果 dp[j] 为 true，并且字符串下标 j-i 截取的字符在字典内，说明可以拆分。\n\n\ndp 数组的初始化：dp[0] = true。初始值为了保证后续计算不会一直为 false。\n\n\n遍历顺序：从前向后遍历（完全背包）。由于是排列问题，所以先遍历背包大小。\n\n\n打印 dp 数组（用于 debug）\n\n\n// 动态规划public static boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123;      boolean[] dp = new boolean[s.length() + 1];      dp[0] = true;        for (int i = 1; i &lt; dp.length; i++) &#123;          for (String word : wordDict) &#123;              int len = word.length();              if (i &gt;= len &amp;&amp; dp[i - len] &amp;&amp; word.equals(s.substring(i - len, i))) &#123;                  dp[i] = true;                  break;              &#125;          &#125;      &#125;        System.out.println(Arrays.toString(dp));        return dp[s.length()];  &#125;\n// 回溯记忆法class Solution &#123;    private Set&lt;String&gt; set;    private int[] memo;    public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123;        memo = new int[s.length()];        set = new HashSet&lt;&gt;(wordDict);        return backtracking(s, 0);    &#125;    public boolean backtracking(String s, int startIndex) &#123;        // System.out.println(startIndex);        if (startIndex == s.length()) &#123;            return true;        &#125;        if (memo[startIndex] == -1) &#123;            return false;        &#125;        for (int i = startIndex; i &lt; s.length(); i++) &#123;            String sub = s.substring(startIndex, i + 1);\t\t    // 拆分出来的单词无法匹配            if (!set.contains(sub)) &#123;                continue;                            &#125;            boolean res = backtracking(s, i + 1);            if (res) return true;        &#125;        // 这里是关键，找遍了startIndex~s.length()也没能完全匹配，标记从startIndex开始不能找到        memo[startIndex] = -1;        return false;    &#125;&#125;\n","categories":["面试","代码随想录"],"tags":["动态规划","完全背包"]},{"title":"代码随想录算法训练营第三十八天-198打家劫舍、213打家劫舍II、337打家劫舍III","url":"/posts/f5901d56/","content":"\n\n前言\n状态：都是看了解析写出。\n\n\n更新\n\n\n24-06-26 初始记录\n\n初步题解\n198 打家劫舍\n题目链接：(https://leetcode.cn/problems/house-robber)\n\n\n确定 dp[i] 的含义：下标 i 及之前的房间能偷的最大金币数。\n\n\n递推公式：dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i])。（分为两种情况，偷/不偷）\n\n\ndp 数组的初始化：dp[0] = num[0], dp[1] = Math.max(num[0], num[1])。\n\n\n遍历顺序：从前向后遍历。\n\n\n打印 dp 数组（用于 debug）\n\n\npublic int rob(int[] nums) &#123;      int[] dp = new int[nums.length];        dp[0] = nums[0];      if (nums.length &lt;= 1) &#123;          return dp[0];      &#125;      dp[1] = Math.max(nums[0], nums[1]);        for (int i = 2; i &lt; dp.length; i++) &#123;          dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);      &#125;        return dp[nums.length - 1];  &#125;\n213 打家劫舍 II\n题目链接：(https://leetcode.cn/problems/house-robber-ii)\n本题的递推与上一题相同。区别在于要不要统计头尾。思路是去除尾和去除头分别求一次最大值。然后选较大的那个。\npublic class LE213 &#123;      public static void main(String[] args) &#123;          int rob = rob(new int[]&#123;200, 3, 140, 20, 10&#125;);          System.out.println(rob);      &#125;        public static int rob(int[] nums) &#123;          if (nums.length == 1) &#123;              return nums[0];          &#125;          return Math.max(rob1(nums, 0, nums.length - 1), rob1(nums, 1, nums.length));      &#125;            public static int rob(int[] nums, int start, int end) &#123;          int[] dp = new int[end - start];            dp[0] = nums[start];          if (dp.length == 1) &#123;              return dp[0];          &#125;          dp[1] = Math.max(nums[start], nums[start + 1]);            for (int i = 2; i &lt; dp.length; i++) &#123;              dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[start + 2]);              start++;          &#125;            System.out.println(Arrays.toString(dp));            return dp[dp.length - 1];      &#125;        /**       * 方法二：直接交换       */      public static int rob1(int[] nums, int start, int end) &#123;          // x为上上层的最大值，y为上一层的最大值。          int x = 0, y = 0;          for (int i = start; i &lt; end; i++) &#123;              int temp = Math.max(x + nums[i], y);              x = y;              y = temp;          &#125;            return y;      &#125;  &#125;\n337 打家劫舍 III\n题目链接：(https://leetcode.cn/problems/house-robber-iii)\n动态规划其实就是使用状态转移容器来记录状态的变化，这里可以使用一个长度为 2 的数组，记录当前节点偷与不偷所得到的的最大金钱。\n这道题目算是树形 dp 的入门题目，因为是在树上进行状态转移，我们在讲解二叉树的时候说过递归三部曲，那么下面我以递归三部曲为框架，其中融合动规五部曲的内容来进行讲解。\n递归三部曲：\n\n\n确定递归函数的参数和返回值。求一个节点两个状态的金钱值，返回值就是一个长度为 2 的数组。本题 dp 数组就是一个长度为 2 的数组\n\n\n确定终止条件。遇到空节点返回。\n\n\n确定遍历顺序。后序遍历。\n\n\n动规五部曲：\n\n\n确定 dp[i] 的含义：下标 0 表示不偷的最大，下标 1 表示偷的最大。\n\n\n递推公式即单层递归的逻辑：dp[0] = cur-&gt;val + left[0] + right[0]，dp[1] = max(left[0], left[1]) + max(right[0], right[1])。（分为两种情况，偷/不偷：偷当前节点 dp[1]，值为当前节点值 + 不偷左右的节点的值；不偷当前节点 dp[0]，值为左孩子偷/不偷的最大值 + 右孩子偷/不偷的最大值）\n\n\ndp 数组的初始化：dp[0] = 0, dp[1] = 0，这里的初始化与递归的终止条件相。\n\n\n遍历顺序：后序遍历。\n\n\n打印 dp 数组（用于 debug）\n\n\npublic int rob(TreeNode root) &#123;      if (root == null) &#123;          return 0;      &#125;      int[] dp = robDFS(root);      return Math.max(dp[0], dp[1]);  &#125;    private int[] robDFS(TreeNode root) &#123;      if (root == null) &#123;          return new int[2];      &#125;        int[] left = robDFS(root.left);      int[] right = robDFS(root.right);        return new int[]&#123;Math.max(left[0], left[1]) + Math.max(right[0], right[1]), root.val + left[0] + right[0]&#125;;  &#125;\n看解析\n198 打家劫舍\n解析：(https://programmercarl.com/0198.打家劫舍.html)\n213 打家劫舍 II\n解析：(https://programmercarl.com/0213.打家劫舍II.html)\n337 打家劫舍 III\n解析：(https://programmercarl.com/0337.打家劫舍III.html)\n","categories":["面试","代码随想录"],"tags":["动态规划","树形dp"]},{"title":"代码随想录算法训练营第四十天-188买卖股票的最佳时机IV、309最佳买卖股票时机含冷冻期、714买卖股票的最佳时机含手续费","url":"/posts/ab0ba29f/","content":"\n\n前言\n状态：188 根据 123AC 了。309用另一种方法AC了。714AC。\n\n\n更新\n\n\n24-06-28 初始记录\n\n初步题解\n188 买卖股票的最佳时机 IV\n题目链接：(https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv)\npublic int maxProfit(int k, int[] prices) &#123;      int[][] dp = new int[prices.length][2 * k];        // 初始化数据      for (int i = 0; i &lt; k; i++) &#123;          dp[0][i * 2] = -prices[0];      &#125;        for (int i = 1; i &lt; dp.length; i++) &#123;          dp[i][0] = Math.max(dp[i - 1][0], -prices[i]);          for (int j = 1; j &lt; 2 * k; j++) &#123;              if (j % 2 == 0) &#123;                  // 偶数买入                  dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - 1] - prices[i]);              &#125; else &#123;                  // 奇数卖出                  dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - 1] + prices[i]);              &#125;          &#125;      &#125;        System.out.println(Arrays.deepToString(dp));        return dp[prices.length - 1][2 * k - 1];  &#125;\n309 最佳买卖股票时机含冷冻期\n题目链接：(https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown)\n思路：买卖股票 + 打家劫舍结合\npublic int maxProfit(int[] prices) &#123;      // 0 表示持有股票的状态; 1 表示不持有股票的状态      int[][] dp = new int[prices.length][2];        dp[0][0] = -prices[0];        for (int i = 1; i &lt; dp.length; i++) &#123;          if (i == 1) &#123;              dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]);          &#125; else &#123;              // 持有：前一天持有；前一天不持有（不可能）：前两天不持有              dp[i][0] = Math.max(dp[i - 1][0], dp[i - 2][1] - prices[i]);          &#125;          // 不持有：前一天不持有；前一天持有          dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]);      &#125;        System.out.println(Arrays.deepToString(dp));        return dp[prices.length - 1][1];  &#125;\n714 买卖股票的最佳时机含手续费\n题目链接：(https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee)\n// 加上手续费就行public int maxProfit(int[] prices, int fee) &#123;      int[][] dp = new int[prices.length][2];        // 假设买入的时候支付手续费      dp[0][0] = -prices[0] - fee;        for (int i = 1; i &lt; dp.length; i++) &#123;          dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i] - fee);          dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]);      &#125;        System.out.println(Arrays.deepToString(dp));        return dp[prices.length - 1][1];  &#125;\n看解析\n188 买卖股票的最佳时机 IV\n解析：(https://programmercarl.com/0188.买卖股票的最佳时机IV.html)\n309 最佳买卖股票时机含冷冻期\n解析：(https://programmercarl.com/0309.最佳买卖股票时机含冷冻期.html)\n注意这里的每一个状态，例如状态一，是持有股票股票状态并不是说今天一定就买入股票，而是说保持买入股票的状态即：可能是前几天买入的，之后一直没操作，所以保持买入股票的状态。\n达到买入股票状态（状态一）即：dp[i][0]，有两个具体操作：\n\n\n操作一：前一天就是持有股票状态（状态一），dp[i][0] = dp[i - 1][0]\n\n\n操作二：今天买入了，有两种情况\n\n前一天是冷冻期（状态四），dp[i - 1][3] - prices[i]\n前一天是保持卖出股票的状态（状态二），dp[i - 1][1] - prices[i]\n\n\n\n那么 dp[i][0] = max(dp[i - 1][0], dp[i - 1][3] - prices[i], dp[i - 1][1] - prices[i]);\n达到保持卖出股票状态（状态二）即：dp[i][1]，有两个具体操作：\n\n\n操作一：前一天就是状态二\n\n\n操作二：前一天是冷冻期（状态四），dp[i][1] = max(dp[i - 1][1], dp[i - 1][3]);\n\n\n达到今天就卖出股票状态（状态三），即：dp[i][2]，只有一个操作：\n昨天一定是持有股票状态（状态一），今天卖出，即：dp[i][2] = dp[i - 1][0] + prices[i];\n达到冷冻期状态（状态四），即：dp[i][3]，只有一个操作：\n昨天卖出了股票（状态三）， dp[i][3] = dp[i - 1][2];\nclass Solution &#123;    public int maxProfit(int[] prices) &#123;        if (prices == null || prices.length &lt; 2) &#123;            return 0;        &#125;        int[][] dp = new int[prices.length][2];        // bad case        dp[0][0] = 0;        dp[0][1] = -prices[0];        dp[1][0] = Math.max(dp[0][0], dp[0][1] + prices[1]);        dp[1][1] = Math.max(dp[0][1], -prices[1]);        for (int i = 2; i &lt; prices.length; i++) &#123;            // dp公式            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 2][0] - prices[i]);        &#125;        return dp[prices.length - 1][0];    &#125;&#125;\n714 买卖股票的最佳时机含手续费\n解析：(https://programmercarl.com/0714.买卖股票的最佳时机含手续费（动态规划）.html)\n","categories":["面试","代码随想录"],"tags":["动态规划"]},{"title":"代码随想录算法训练营第三十九天-121买卖股票的最佳时机、122买卖股票的最佳时机II、123买卖股票的最佳时机III","url":"/posts/f80b512c/","content":"\n\n前言\n状态：121 直接看的解析。122 可以写出。123 看了部分解析（主要是 dp 的定义那块）。\n\n\n更新\n\n\n24-06-27 初始记录\n\n初步题解\n121 买卖股票的最佳时机\n题目链接：(https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)：可以进行一笔交易\n\n\n确定 dp[i] 的含义：dp[i][0] 表示第 i 天持有股票所得最多现金，dp[i][1] 表示第 i 天不持有股票所得最多现金。\n\n\n递推公式：dp[i][0] = Math.max(dp[i - 1][0], -prices[i]);dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]);。（分为两种情况，当前持有/不持有）\n\n\ndp 数组的初始化：dp[0][0] = -prices[0]; dp[0][1] = 0;。还有一点要注意：不持有股票状态所得金钱一定比持有股票状态得到的多！\n\n\n遍历顺序：从前向后遍历。\n\n\n打印 dp 数组（用于 debug）\n\n\npublic int maxProfit(int[] prices) &#123;      // `dp[i][0]` 表示第 i 天持有股票所得最多现金，`dp[i][1]` 表示第 i 天不持有股票所得最多现金。      int[][] dp = new int[prices.length][2];        // 初始化      dp[0][0] = -prices[0];      dp[0][1] = 0;        for (int i = 1; i &lt; prices.length; i++) &#123;          // 1. 求 dp[i][0]: 前一天也持有就为 dp[i - 1][0]，前一天不持有就为 -prices[i]                dp[i][0] = Math.max(dp[i - 1][0], -prices[i]);          // 2. 求 dp[i][1]: 前一天也不持有就为 dp[i - 1][1]，前一天持有就为 dp[i - 1][0] + prices[i]                dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]);      &#125;        System.out.println(Arrays.deepToString(dp));  \t// 手中不持有股票时，利润才会最大    return dp[prices.length - 1][1];&#125;\n122 买卖股票的最佳时机 II\n题目链接：(https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii)：可以进行多笔交易\n\n\n确定 dp[i] 的含义：dp[i][0] 表示第 i 天持有股票所得最多现金，dp[i][1] 表示第 i 天不持有股票所得最多现金。\n\n\n递推公式：dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]);。（与上一题的唯一区别为 dp[i][0] 的推导公式，由于可以持续买入卖出，当天持有的价格为前一天不持有的价格 - 当天价格）\n\n\ndp 数组的初始化：dp[0][0] = -prices[0]; dp[0][1] = 0;。还有一点要注意：不持有股票状态所得金钱一定比持有股票状态得到的多！\n\n\n遍历顺序：从前向后遍历。\n\n\n打印 dp 数组（用于 debug）\n\n\npublic int maxProfit(int[] prices) &#123;      // `dp[i][0]` 表示第 i 天持有股票所得最多现金，`dp[i][1]` 表示第 i 天不持有股票所得最多现金。      int[][] dp = new int[prices.length][2];        // 初始化      dp[0][0] = -prices[0];      dp[0][1] = 0;        for (int i = 1; i &lt; prices.length; i++) &#123;          // 1. 求 dp[i][0]: 前一天也持有就为 dp[i - 1][0]，前一天不持有就为 dp[i - 1][1] - prices[i]                dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] - prices[i]);          // 2. 求 dp[i][1]: 前一天也不持有就为 dp[i - 1][1]，前一天持有就为 dp[i - 1][0] + prices[i]                dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]);      &#125;        System.out.println(Arrays.deepToString(dp));        return dp[prices.length - 1][1];&#125;\n123 买卖股票的最佳时机 III\n题目链接：(https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)：可以进行两笔交易\n\n\n确定 dp[i] 的含义：当天的状态一共有 5 种：没有操作，不计入。dp[i][0] 表示第 i 天第一次持有股票所得最多现金，dp[i][1] 表示第 i 天第一次不持有股票所得最多现金，dp[i][2] 表示第 i 天第二次持有股票所得最多现金，dp[i][2] 表示第 i 天第二次不持有股票所得最多现金。（这题重点把这个写出来，后面就能做题了）\n\n\n递推公式：dp[i][0] = Math.max(dp[i - 1][0], -prices[i]); dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]); dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] - prices[i]); dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] + prices[i]);。\n\n\ndp 数组的初始化：dp[0][0] = -prices[0]; dp[0][2] = -prices[0];。\n\n\n遍历顺序：从前向后遍历。\n\n\n打印 dp 数组（用于 debug）\n\n\npublic static int maxProfit(int[] prices) &#123;      // `dp[i][0]` 表示第 i 天第一次持有股票所得最多现金，`dp[i][1]` 表示第 i 天第一次不持有股票所得最多现金，`dp[i][2]` 表示第 i 天第二次持有股票所得最多现金，`dp[i][2]` 表示第 i 天第二次不持有股票所得最多现金     int[][] dp = new int[prices.length][4];        // 初始化      dp[0][0] = -prices[0];      dp[0][2] = -prices[0];        for (int i = 1; i &lt; prices.length; i++) &#123;          // 1. 求 dp[i][0]: 前一天也持有就为 dp[i - 1][0]，前一天不持有就为 -prices[i]                dp[i][0] = Math.max(dp[i - 1][0], -prices[i]);          // 2. 求 dp[i][1]: 前一天也不持有就为 dp[i - 1][1]，前一天持有就为 dp[i - 1][0] + prices[i]                dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + prices[i]);          // 3. 求 dp[i][2]: 前一天也持有为 dp[i - 1][2]，前一天不持有就为 dp[i - 1][1] - prices[i]                dp[i][2] = Math.max(dp[i - 1][2], dp[i - 1][1] - prices[i]);          // 4. 求 dp[i][3]: 前一天也不持有为 dp[i - 1][3]，前一天持有就为 dp[i - 1][2] + prices[i]                dp[i][3] = Math.max(dp[i - 1][3], dp[i - 1][2] + prices[i]);      &#125;        System.out.println(Arrays.deepToString(dp));        return dp[prices.length - 1][3];  &#125;\n看解析\n121 买卖股票的最佳时机\n解析：(https://programmercarl.com/0121.买卖股票的最佳时机.html)\n补充贪心算法的思路：如果第 i 天卖出股票，则最大利润为 (该天的股价 - 前面天数中最小的股价)，然后与已知的最大利润比较，如果大于则更新当前最大利润的值。\n/**   * 贪心解法   */  public int maxProfit(int[] prices) &#123;      int minPrice = Integer.MAX_VALUE;      int maxProfit = 0;        for (int price : prices) &#123;          minPrice = Math.min(price, minPrice);          maxProfit = Math.max(maxProfit, price - minPrice);      &#125;        return maxProfit;  &#125;\n122 买卖股票的最佳时机 II\n解析：(https://programmercarl.com/0122.买卖股票的最佳时机II（动态规划）.html)\n123 买卖股票的最佳时机 III\n解析：(https://programmercarl.com/0123.买卖股票的最佳时机III)\n版本二：（不做要求）\npublic int maxProfit(int[] prices) &#123;    int[] dp = new int[4];     // 存储两次交易的状态就行了    // dp[0]代表第一次交易的买入    dp[0] = -prices[0];    // dp[1]代表第一次交易的卖出    dp[1] = 0;    // dp[2]代表第二次交易的买入    dp[2] = -prices[0];    // dp[3]代表第二次交易的卖出    dp[3] = 0;    for(int i = 1; i &lt;= prices.length; i++)&#123;        // 要么保持不变，要么没有就买，有了就卖        dp[0] = Math.max(dp[0], -prices[i-1]);        dp[1] = Math.max(dp[1], dp[0]+prices[i-1]);        // 这已经是第二次交易了，所以得加上前一次交易卖出去的收获        dp[2] = Math.max(dp[2], dp[1]-prices[i-1]);        dp[3] = Math.max(dp[3], dp[2]+ prices[i-1]);    &#125;    return dp[3];&#125;\n","categories":["面试","代码随想录"],"tags":["动态规划"]},{"title":"代码随想录算法训练营第四十一天-300最长递增子序列、674最长连续递增序列、718最长重复子数组","url":"/posts/825964fb/","content":"\n\n前言\n状态：300 看解析，674AC，718看解析\n\n\n更新\n\n\n24-07-01 初始记录\n\n初步题解\n300 最长递增子序列\n题目链接：(https://leetcode.cn/problems/longest-increasing-subsequence)\n\n\n确定 dp[i] 的含义：dp[i] 表示第 i 个下标前的最长递增子序列的长度\n\n\n递推公式：dp[i] = Math.max(dp[i], dp[j] + 1)。\n\n\ndp 数组的初始化：dp 数组所有元素的初始化值都为 1。\n\n\n遍历顺序：从前向后遍历。\n\n\n打印 dp 数组（用于 debug）\n\n\npublic int lengthOfLIS(int[] nums) &#123;      int[] dp = new int[nums.length];        Arrays.fill(dp, 1);        int maxLength = 0;      for (int i = 1; i &lt; dp.length; i++) &#123;          for (int j = 0; j &lt; i; j++) &#123;              if (nums[i] &gt; nums[j]) &#123;                  dp[i] = Math.max(dp[i], dp[j] + 1);              &#125;          &#125;          maxLength = Math.max(maxLength, dp[i]);      &#125;        return maxLength;  &#125;\n674 最长连续递增序列\n题目链接：(https://leetcode.cn/problems/longest-continuous-increasing-subsequence)\n\n\n确定 dp[i] 的含义：dp[i] 表示第 i 个下标前的最长连续递增子序列的长度\n\n\n递推公式：dp[i] = Math.max(dp[i], dp[i - 1] + 1)。\n\n\ndp 数组的初始化：dp 数组所有元素的初始化值都为 1。\n\n\n遍历顺序：从前向后遍历。\n\n\n打印 dp 数组（用于 debug）\n\n\npublic int findLengthOfLCIS(int[] nums) &#123;      int[] dp = new int[nums.length];        Arrays.fill(dp, 1);        int maxLength = 1;      for (int i = 1; i &lt; dp.length; i++) &#123;          if (nums[i] &gt; nums[i - 1]) &#123;              dp[i] = Math.max(dp[i], dp[i - 1] + 1);          &#125;          maxLength = Math.max(maxLength, dp[i]);      &#125;        return maxLength;  &#125;\n718 最长重复子数组\n\n\n确定 dp[i][j] 的含义：num1 到 i - 1；num2 到 j - 1 位置的最长重复数组。\n\n\n递推公式：dp[i][j] = dp[i - 1][j - 1] + 1; 。\n\n\ndp 数组的初始化：dp 数组所有元素的初始化值都为 0。\n\n\n遍历顺序：从前向后遍历。\n\n\n打印 dp 数组（用于 debug）题目链接：(https://leetcode.cn/problems/maximum-length-of-repeated-subarray)\n\n\npublic int findLength(int[] nums1, int[] nums2) &#123;      int[][] dp = new int[nums1.length + 1][nums2.length + 1];        int maxLength = 0;      for (int i = 1; i &lt;= nums1.length; i++) &#123;          for (int j = 1; j &lt;= nums2.length; j++) &#123;              if (nums1[i - 1] == nums2[j - 1]) &#123;                  dp[i][j] = dp[i - 1][j - 1] + 1;              &#125;              maxLength = Math.max(dp[i][j], maxLength);          &#125;      &#125;        return maxLength;  &#125;\n看解析\n300 最长递增子序列\n解析：(https://programmercarl.com/0300.最长上升子序列.html)\n674 最长连续递增序列\n解析：(https://programmercarl.com/0674.最长连续递增序列.html)\n718 最长重复子数组\n解析：(https://programmercarl.com/0718.最长重复子数组.html)\n","categories":["面试","代码随想录"],"tags":["动态规划"]},{"title":"代码随想录算法训练营第四十二天-1143最长公共子序列、1035不相交的线、53最大子序和、392判断子序列","url":"/posts/2b15070f/","content":"\n\n前言\n状态：1143AC（方法不是最简的）、1035AC（和上一题一样）、53AC、392AC（根据 1143）\n\n\n更新\n\n\n24-07-05 初始记录24-07-06 114324-07-07 1143优化、1035、53、392\n\n初步题解\n1143 最长公共子序列\n题目链接：(https://leetcode.cn/problems/longest-common-subsequence/)\n\n\n确定 dp[i][j] 的含义：text1 到 i；text2 到 j 位置的最长重复数组。\n\n\n递推公式：如果当前位置元素相同：dp[i][j] = dp[i - 1][j - 1] + 1; ， 如果当前位置元素不同：dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); 。\n\n\ndp 数组的初始化：针对初始元素是否相同及 i = 0 和 j = 0 的两种情况，都需要分别判断。\n\n\n遍历顺序：从前向后遍历。\n\n\n打印 dp 数组（用于 debug）\n\n\npublic static int longestCommonSubsequence(String text1, String text2) &#123;      int[][] dp = new int[text1.length()][text2.length()];        int maxLength = 0;        for (int i = 0; i &lt; text1.length(); i++) &#123;          for (int j = 0; j &lt; text2.length(); j++) &#123;              // 当前指针位置相同，dp[i][j] = dp[i - 1][j - 1] + 1              if (text1.charAt(i) == text2.charAt(j)) &#123;                  if (i == 0 || j == 0) &#123;                      dp[i][j] = 1;                      maxLength = Math.max(dp[i][j], maxLength);                      continue;                  &#125;                  dp[i][j] = dp[i - 1][j - 1] + 1;              &#125; else &#123;                  if (i == 0 &amp;&amp; j == 0) &#123;                      dp[i][j] = 0;                      continue;                  &#125; else if (i == 0) &#123;                      dp[i][j] = dp[0][j - 1];                      maxLength = Math.max(dp[i][j], maxLength);                      continue;                  &#125; else if (j == 0) &#123;                      dp[i][j] = dp[i - 1][0];                      maxLength = Math.max(dp[i][j], maxLength);                      continue;                  &#125;                  dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);              &#125;              maxLength = Math.max(dp[i][j], maxLength);          &#125;      &#125;        System.out.println(Arrays.deepToString(dp));        return maxLength;  &#125;\n1035 不相交的线\n题目链接：(https://leetcode.cn/problems/uncrossed-lines)\n\n\n确定 dp[i][j] 的含义：text1 到 i - 1；text2 到 j - 1 位置的最长重复数组。\n\n\n递推公式：如果当前位置元素相同：dp[i][j] = dp[i - 1][j - 1] + 1; ， 如果当前位置元素不同：dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); 。\n\n\ndp 数组的初始化：i = 0 或 j = 0 时，dp 值为 0\n\n\n遍历顺序：从前向后遍历。\n\n\n打印 dp 数组（用于 debug）\n\n\npublic int maxUncrossedLines(int[] nums1, int[] nums2) &#123;      int[][] dp = new int[nums1.length + 1][nums2.length + 1];        for (int i = 1; i &lt;= nums1.length; i++) &#123;          for (int j = 1; j &lt;= nums2.length; j++) &#123;              // 当前位置加入计数              if (nums1[i - 1] == nums2[j - 1]) &#123;                  dp[i][j] = dp[i - 1][j - 1] + 1;              &#125; else &#123;                  dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);              &#125;          &#125;      &#125;        // System.out.println(Arrays.deepToString(dp));        return dp[nums1.length][nums2.length];  &#125;\n53 最大子序和\n题目链接：(https://leetcode.cn/problems/maximum-subarray/)\n\n\n确定 dp[i] 的含义：数组长度为 i 时的最大子序和。\n\n\n递推公式：如果当前位置元素相同：dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]); 。\n\n\ndp 数组的初始化：i = 0 时，取 nums[0] 的值\n\n\n遍历顺序：从前向后遍历。\n\n\n打印 dp 数组（用于 debug）\n\n\npublic int maxSubArray(int[] nums) &#123;      int[] dp = new int[nums.length];        dp[0] = nums[0];      int max = dp[0];        for (int i = 1; i &lt; dp.length; i++) &#123;          dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);          max = Math.max(max, dp[i]);      &#125;        System.out.println(Arrays.toString(dp));        return max;  &#125;\n392 判断子序列\n\n\n确定 dp[i][j] 的含义：s 到 i - 1；t 到 j - 1 位置的相同子序列长度。\n\n\n递推公式：如果当前位置元素相同：dp[i][j] = dp[i - 1][j - 1] + 1; ， 如果当前位置元素不同：dp[i][j] = dp[i][j - 1]; 。\n\n\ndp 数组的初始化：i = 0 或 j = 0 时，dp 值为 0\n\n\n遍历顺序：从前向后遍历。\n\n\n打印 dp 数组（用于 debug）\n\n\n题目链接：(https://leetcode.cn/problems/is-subsequence)\npublic boolean isSubsequence(String s, String t) &#123;      int[][] dp = new int[s.length() + 1][t.length() + 1];          for (int i = 1; i &lt;= s.length(); i++) &#123;          for (int j = 1; j &lt;= t.length(); j++) &#123;              // 当前指针位置相同，dp[i][j] = dp[i - 1][j - 1] + 1              if (s.charAt(i - 1) == t.charAt(j - 1)) &#123;                  dp[i][j] = dp[i - 1][j - 1] + 1;              &#125; else &#123;                  dp[i][j] = dp[i][j - 1];              &#125;          &#125;      &#125;        System.out.println(Arrays.deepToString(dp));        return dp[s.length()][t.length()] == s.length();  &#125;\n看解析\n1143 最长公共子序列\n解析：(https://programmercarl.com/1143.最长公共子序列.html)\n\n\n二维数组优化\n\ndp 数组的定义修改为 dp[i][j]：长度为 [0, i - 1] 的字符串 text1 与长度为 [0, j - 1] 的字符串 text2 的最长公共子序列为 dp[i][j]（即多）\n初始化即 i 为 0，j 为 0 时，dp[i][j] 的值也为 0\n\n\n\npublic int longestCommonSubsequence(String text1, String text2) &#123;      int[][] dp = new int[text1.length() + 1][text2.length() + 1];      for (int i = 1; i &lt;= text1.length(); i++) &#123;          for (int j = 1; j &lt;= text2.length(); j++) &#123;              // 当前指针位置相同，dp[i][j] = dp[i - 1][j - 1] + 1              if (text1.charAt(i - 1) == text2.charAt(j - 1)) &#123;                  dp[i][j] = dp[i - 1][j - 1] + 1;              &#125; else &#123;                  dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);              &#125;          &#125;      &#125;    \t// System.out.println(Arrays.deepToString(dp));        return dp[text1.length()][text2.length()];  &#125;\n\n\n一维数组优化\n\n\nclass Solution &#123;    public int longestCommonSubsequence(String text1, String text2) &#123;        int n1 = text1.length();        int n2 = text2.length();                // 多从二维dp数组过程分析          // 关键在于  如果记录  dp[i - 1][j - 1]        // 因为 dp[i - 1][j - 1]  &lt;!=&gt;  dp[j - 1]  &lt;=&gt;  dp[i][j - 1]        int [] dp = new int[n2 + 1];        for(int i = 1; i &lt;= n1; i++)&#123;            // 这里pre相当于 dp[i - 1][j - 1]            int pre = dp[0];            for(int j = 1; j &lt;= n2; j++)&#123;                //用于给pre赋值                int cur = dp[j];                if(text1.charAt(i - 1) == text2.charAt(j - 1))&#123;                    //这里pre相当于dp[i - 1][j - 1]   千万不能用dp[j - 1] !!                    dp[j] = pre + 1;                &#125; else&#123;                    // dp[j]     相当于   dp[i - 1][j]                    // dp[j - 1] 相当于   dp[i][j - 1]                    dp[j] = Math.max(dp[j], dp[j - 1]);                &#125;                //更新dp[i - 1][j - 1], 为下次使用做准备                pre = cur;            &#125;        &#125;        return dp[n2];    &#125;&#125;\n1035 不相交的线\n解析：(https://programmercarl.com/1035.不相交的线.html)\n53 最大子序和\n解析：(https://programmercarl.com/0053.最大子序和（动态规划）.html)\n392 判断子序列\n解析：(https://programmercarl.com/0392.判断子序列.html)\n","categories":["面试","代码随想录"],"tags":["动态规划"]},{"title":"代码随想录算法训练营第四十三天-115不同的子序列、583两个字符串的删除操作、72编辑距离","url":"/posts/ca280c35/","content":"\n\n前言\n状态：115 不会、583 根据 115AC、72 不会\n\n\n更新\n\n\n24-07-08 初始记录\n\n初步题解\n115 不同的子序列\n题目链接：(https://leetcode.cn/problems/distinct-subsequences/)\n583 两个字符串的删除操作\n题目链接：(https://leetcode.cn/problems/delete-operation-for-two-strings/)\n\n\n确定 dp[i][j] 的含义：s 到 i - 1；t 到 j - 1 位置的删除相同需要的最小步数。\n\n\n递推公式：如果当前位置元素相同：dp[i][j] = dp[i - 1][j - 1]; （即不加这个元素时的子序列个数 + 加上这个元素的子序列个数）， 如果当前位置元素不同：dp[i][j] = Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1); （画图即当前位置的上左再去除一个元素并取较小值）。\n\n\ndp 数组的初始化：dp[i][0] 、dp[0][j] 都是与元素个数有关。\n\n\n遍历顺序：从上到下，从左到右。\n\n\n打印 dp 数组（用于 debug）\n\n\npublic int minDistance(String word1, String word2) &#123;      int[][] dp = new int[word1.length() + 1][word2.length() + 1];        for (int i = 0; i &lt; dp.length; i++) &#123;          dp[i][0] = i;      &#125;      for (int i = 0; i &lt; dp[0].length; i++) &#123;          dp[0][i] = i;      &#125;        for (int i = 1; i &lt;= word1.length(); i++) &#123;          for (int j = 1; j &lt;= word2.length(); j++) &#123;              // 当前指针位置相同，dp[i][j] = dp[i - 1][j - 1] + 1              if (word1.charAt(i - 1) == word2.charAt(j - 1)) &#123;                  dp[i][j] = dp[i - 1][j - 1];              &#125; else &#123;                  dp[i][j] = Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1);              &#125;          &#125;      &#125;        System.out.println(Arrays.deepToString(dp));        return dp[word1.length()][word2.length()];  &#125;\n72 编辑距离\n题目链接：(https://leetcode.cn/problems/edit-distance)\n看解析\n115 不同的子序列\n解析：(https://programmercarl.com/0115.不同的子序列.html)\n\n\n确定 dp[i][j] 的含义：s 到 i - 1；t 到 j - 1 位置的子序列个数。\n\n\n递推公式：如果当前位置元素相同：dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]; （即不加这个元素时的子序列个数 + 加上这个元素的子序列个数）， 如果当前位置元素不同：dp[i][j] = dp[i - 1][j];。\n\n\ndp 数组的初始化：dp[i][0] 一定都是 1，因为也就是把以 i-1 为结尾的 s，删除所有元素，出现空字符串的个数就是 1。dp[0][j] 一定都是 0。dp[0][0] 应该是 1。\n\n\n遍历顺序：从上到下，从左到右。\n\n\n打印 dp 数组（用于 debug）\n\n\npublic int numDistinct(String s, String t) &#123;      int[][] dp = new int[s.length() + 1][t.length() + 1];        for (int i = 0; i &lt; dp.length; i++) &#123;          dp[i][0] = 1;      &#125;        for (int i = 1; i &lt;= s.length(); i++) &#123;          for (int j = 1; j &lt;= t.length(); j++) &#123;              // 当前指针位置相同，dp[i][j] = dp[i - 1][j - 1] + 1              if (s.charAt(i - 1) == t.charAt(j - 1)) &#123;                  dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];              &#125; else &#123;                  dp[i][j] = dp[i - 1][j];              &#125;          &#125;      &#125;        System.out.println(Arrays.deepToString(dp));        return dp[s.length()][t.length()];  &#125;\n583 两个字符串的删除操作\n解析：(https://programmercarl.com/0583.两个字符串的删除操作.html)\n72 编辑距离\n解析：(https://programmercarl.com/0072.编辑距离.html)\n\n\n确定 dp[i][j] 的含义：word1 到 i - 1；word2 到 j - 1 位置的最小编辑数。\n\n\n递推公式：需要确认四种情况：word1[i - 1] == word2[j - 1] 时，不操作；word1[i - 1] != word2[j - 1]，增删换。具体公式看代码。\n\n\ndp 数组的初始化：dp[i][0] 、dp[0][j] 都是与元素个数有关，即删除所有元素。\n\n\n遍历顺序：从上到下，从左到右。\n\n\n打印 dp 数组（用于 debug）\n\n\npublic int minDistance(String word1, String word2) &#123;      int[][] dp = new int[word1.length() + 1][word2.length() + 1];        for (int i = 0; i &lt; dp.length; i++) &#123;          dp[i][0] = i;      &#125;      for (int i = 0; i &lt; dp[0].length; i++) &#123;          dp[0][i] = i;      &#125;        for (int i = 1; i &lt;= word1.length(); i++) &#123;          for (int j = 1; j &lt;= word2.length(); j++) &#123;              if (word1.charAt(i - 1) == word2.charAt(j - 1)) &#123;                  dp[i][j] = dp[i - 1][j - 1];              &#125; else &#123;                  // 三数比较                  // word1删除一个元素，那么就是以下标i - 2为结尾的word1 与 j-1为结尾的word2的最近编辑距离 再加上一个操作。                  // word2删除一个元素，那么就是以下标i - 1为结尾的word1 与 j-2为结尾的word2的最近编辑距离 再加上一个操作。                  // 替换元素，word1替换word1[i - 1]，使其与word2[j - 1]相同，此时不用增删加元素。                  dp[i][j] = Math.min(Math.min(dp[i - 1][j - 1], dp[i - 1][j]), Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;              &#125;          &#125;      &#125;        System.out.println(Arrays.deepToString(dp));        return dp[word1.length()][word2.length()];  &#125;\n","categories":["面试","代码随想录"],"tags":["动态规划"]},{"title":"代码随想录算法训练营第四十四天-647回文子串、516最长回文子序列","url":"/posts/aa7c5f5/","content":"\n\n前言\n状态：647 看解析，516 看解析\n\n\n更新\n\n\n24-07-09 初始记录24-07-10 完成\n\n初步题解\n647 回文子串\n题目链接：(https://leetcode.cn/problems/palindromic-substrings)\n516 最长回文子序列\n题目链接：(https://leetcode.cn/problems/longest-palindromic-subsequence)\n\n\n确定 dp[i][j] 的含义：表示区间范围 [i,j] （注意是左闭右闭）的子串的最长回文子串的长度。\n\n\n递推公式：s[i] 与 s[j] 相等，s[i] 与 s[j] 不相等这两种情况：不相等取左右指针向内移动的最大值；相等 dp[i][j] = dp[i + 1][j - 1] + 2;  \n\n\ndp 数组的初始化：相等时，取 1。\n\n\n遍历顺序：从下到上，从左到右遍历\n\n\n打印 dp 数组（用于 debug）\n\n\npublic int longestPalindromeSubseq(String s) &#123;      int[][] dp = new int[s.length()][s.length()];        for (int i = 0; i &lt; s.length(); i++) &#123;          dp[i][i] = 1;      &#125;        int max= 0;      for (int i = s.length() - 1; i &gt;= 0; i--) &#123;          for (int j = i + 1; j &lt; s.length(); j++) &#123;              if (s.charAt(i) == s.charAt(j)) &#123;                  dp[i][j] = dp[i + 1][j - 1] + 2;              &#125; else &#123;                  dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);              &#125;              max = Math.max(dp[i][j], max);          &#125;      &#125;        System.out.println(Arrays.deepToString(dp));        return max;  &#125;\n看解析\n647 回文子串\n解析：(https://programmercarl.com/0647.回文子串.html)\n\n\n确定 dp[i][j] 的含义：表示区间范围 [i,j] （注意是左闭右闭）的子串是否是回文子串，如果是 dp[i][j] 为 true，否则为 false。\n\n\n递推公式：s[i] 与 s[j] 相等，s[i] 与 s[j] 不相等这两种情况：不相等即为 false；相等分为三种情况：下标 i 与 j 相同，同一个字符返回 true；下标 i 与 j 相差为 1，返回 true；i 与 j 相差大于 1 的时候，判断 dp[i + 1][j - 1] 是否为 true\n\n\ndp 数组的初始化：全为 false\n\n\n遍历顺序：从下到上，从左到右遍历\n\n\n打印 dp 数组（用于 debug）\n\n\npublic int countSubstrings(String s) &#123;      boolean[][] dp = new boolean[s.length()][s.length()];        int num = 0;        for (int i = s.length() - 1; i &gt;= 0; i--) &#123;          for (int j = i; j &lt; s.length(); j++) &#123;              if (s.charAt(i) != s.charAt(j)) &#123;                  dp[i][j] = false;              &#125; else &#123;                  if (j - i &lt;= 1) &#123;                      dp[i][j] = true;                  &#125; else &#123;                      dp[i][j] = dp[i + 1][j - 1];                  &#125;              &#125;              if (dp[i][j]) &#123;                  num++;              &#125;          &#125;      &#125;        System.out.println(Arrays.deepToString(dp));        return num;  &#125;\n516 最长回文子序列\n解析：(https://programmercarl.com/0516.最长回文子序列.html)\n","categories":["面试","代码随想录"],"tags":["动态规划"]},{"title":"代码随想录算法训练营第四十五天-739每日温度、496下一个更大元素 I、503下一个更大元素II","url":"/posts/d0198d2/","content":"\n\n前言\n状态：739 看解析。496 看解析。503 根据 739 写出。\n\n\n更新\n\n\n24-07-11 初始记录\n\n初步题解\n739 每日温度\n题目链接：(https://leetcode.cn/problems/daily-temperatures)\n496 下一个更大元素 I\n题目链接：(https://leetcode.cn/problems/next-greater-element-i)\n503 下一个更大元素 II\n题目链接：(https://leetcode.cn/problems/next-greater-element-ii)\npublic static int[] nextGreaterElements(int[] nums) &#123;      int[] result = new int[nums.length];      Arrays.fill(result, -1);        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();      stack.push(0);        for (int i = 0; i &lt; nums.length * 2; i++) &#123;          while (!stack.isEmpty() &amp;&amp; nums[i % nums.length] &gt; nums[stack.peek()]) &#123;              result[stack.peek()] = nums[i % nums.length];              stack.pop();          &#125;          stack.push(i % nums.length);      &#125;        return result;  &#125;\n看解析\n739 每日温度\n解析：(https://programmercarl.com/0739.每日温度.html)\n\n\n情况一：当前遍历的元素 T[i] 小于栈顶元素 T[st.top()] 的情况\n\n\n情况二：当前遍历的元素 T[i] 等于栈顶元素 T[st.top()] 的情况\n\n\n情况三：当前遍历的元素 T[i] 大于栈顶元素 T[st.top()] 的情况\n\n\npublic static int[] dailyTemperatures(int[] temperatures) &#123;      Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;();      int[] result = new int[temperatures.length];        stack.push(0);      for (int i = 1; i &lt; temperatures.length; i++) &#123;\t    // 当前元素小于等于栈顶元素，直接继续放入          if (temperatures[i] &lt;= temperatures[stack.peek()]) &#123;              stack.push(i);          // 当前元素大于栈顶元素，弹出元素，计算result，（直到当前元素不大于栈顶元素），将当前元素加入栈        &#125; else &#123;              while (!stack.isEmpty() &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()]) &#123;                  result[stack.peek()] = i - stack.peek();                  stack.pop();              &#125;              stack.push(i);          &#125;      &#125;      return result;  &#125;// 简化版本public int[] dailyTemperatures(int[] temperatures) &#123;      Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;();      int[] result = new int[temperatures.length];        stack.push(0);      for (int i = 1; i &lt; temperatures.length; i++) &#123;\t    while (!stack.isEmpty() &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()]) &#123;                  result[stack.peek()] = i - stack.peek();                  stack.pop();              &#125;          stack.push(i);        &#125;      return result;  &#125;\n496 下一个更大元素 I\n解析：(https://programmercarl.com/0496.下一个更大元素I.html)\npublic int[] nextGreaterElement(int[] nums1, int[] nums2) &#123;      int[] result = new int[nums1.length];      Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();        Arrays.fill(result, -1);        HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();      for (int i = 0; i &lt; nums1.length; i++) &#123;          map.put(nums1[i], i);      &#125;        stack.push(0);        for (int i = 1; i &lt; nums2.length; i++) &#123;          if (nums2[i] &lt;= nums2[stack.peek()]) &#123;              stack.push(i);          &#125; else &#123;  \t        // 栈中保存了上个需要比较的对象            while (!stack.isEmpty() &amp;&amp; nums2[i] &gt; nums2[stack.peek()]) &#123;                  // num1中包含整这个元素                  if (map.containsKey(nums2[stack.peek()])) &#123;                      // result中的对应下标为这个元素的后一位                      result[map.get(nums2[stack.peek()])] = nums2[i];                  &#125;                  stack.pop();              &#125;              stack.push(i);          &#125;      &#125;      return result;  &#125;\n503 下一个更大元素 II\n解析：(https://programmercarl.com/0503.下一个更大元素II.html)\n","categories":["面试","代码随想录"],"tags":["单调栈"]},{"title":"代码随想录算法训练营第四十六天-42接雨水、84柱状图中最大的矩形","url":"/posts/82b551fe/","content":"\n\n前言\n状态：42 看解析。84 看解析。\n\n\n更新\n\n\n24-07-13 初始记录24-07-16 完成\n\n初步题解\n42 接雨水\n题目链接：(https://leetcode.cn/problems/trapping-rain-water/)\n84 柱状图中最大的矩形\n题目链接：(https://leetcode.cn/problems/largest-rectangle-in-histogram)\n看解析\n42 接雨水\n解析：(https://programmercarl.com/0042.接雨水.html)\n\n\n当前高度小于等于栈顶高度，入栈，指针后移。\n\n\n当前高度大于栈顶高度，出栈，计算出当前墙和栈顶的墙之间水的多少，然后计算当前的高度和新栈的高度的关系，重复第 2 步。直到当前墙的高度不大于栈顶高度或者栈空，然后把当前墙入栈，指针后移。\n\n\npublic int trap(int[] height) &#123;      Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();        int area = 0;        stack.push(0);      for (int i = 1; i &lt; height.length; i++) &#123;          if (height[i] &lt;= height[stack.peek()]) &#123;              stack.push(i);          &#125; else &#123;              // 当前元素小于栈顶元素              if (height[stack.peek()] &gt;= height[i]) &#123;                  stack.push(i);              &#125; else &#123;                  while (!stack.isEmpty() &amp;&amp; height[i] &gt; height[stack.peek()]) &#123;                      // 当前的栈顶                      Integer mid = stack.pop();                      if (!stack.isEmpty()) &#123;                          int h = Math.min(height[stack.peek()], height[i]) - height[mid];                          int w = i - stack.peek() - 1;                          area += h * w;                      &#125;                  &#125;                  stack.push(i);              &#125;          &#125;      &#125;      return area;  &#125;\n84 柱状图中最大的矩形\n解析：(https://programmercarl.com/0084.柱状图中最大的矩形.html)\n本题是要找每个柱子左右两边第一个小于该柱子的柱子，所以从栈头（元素从栈头弹出）到栈底的顺序应该是从大到小的顺序\npublic int largestRectangleArea(int[] heights) &#123;      Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();      // 首末尾加零防止无法进入循环      int[] newHeights = new int[heights.length + 2];      for (int i = 1; i &lt; newHeights.length - 1; i++) &#123;          newHeights[i] = heights[i - 1];      &#125;      newHeights[heights.length + 1] = 0;      newHeights[0] = 0;        int area = 0;      stack.push(0);      for (int i = 0; i &lt; newHeights.length; i++) &#123;          while (!stack.isEmpty() &amp;&amp; newHeights[i] &lt; newHeights[stack.peek()]) &#123;              // 当前元素的前一个元素              Integer mid = stack.pop();              // 右侧数据与左侧数据的差值              int w = i - stack.peek() - 1;              area = Math.max(area, w * newHeights[mid]);          &#125;          stack.push(i);      &#125;        return area;  &#125;\n","categories":["面试","代码随想录"],"tags":["单调栈"]},{"title":"代码随想录算法训练营第八天-28实现 strStr() 、459重复的子字符串","url":"/posts/45e5605f/","content":"\n\n前言状态：28 暴力（应为 KMP）、459 暴力（KMP 不会）\n\n\n更新\n\n\n24-05-29 初始记录\n\n初步题解\n28 实现 strStr()\n题目链接：(https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/)\npublic class LE28 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          String haystack = scanner.nextLine();          String needle = scanner.nextLine();          System.out.println(strStr(haystack, needle));      &#125;        /**       * 思路：一个指针针对haystack遍历，一个指针针对needle遍历       * 当指针指过的路径相等，输出两者的差（即初始相等的指针位置）       * 当指向元素不同，haystack指针指向初始对比的下一个，needle指针重置       */      public static int strStr(String haystack, String needle) &#123;          int j = 0;          for (int i = 0; i &lt; haystack.length(); i++) &#123;              if (haystack.charAt(i) == needle.charAt(j)) &#123;                  if (j == needle.length() - 1) &#123;                      return i - j;                  &#125;                  j++;              &#125; else &#123;                  i = i - j;                  j = 0;              &#125;          &#125;          return  -1;      &#125;  &#125;\n459 重复的子字符串\n题目链接：(https://leetcode.cn/problems/repeated-substring-pattern/description/)\n（虽然讲了 KMP 应该就用 KMP，但是不会）\n// 暴力求解public class LE459 &#123;      public static void main(String[] args) &#123;          Scanner scanner = new Scanner(System.in);          String nextLine = scanner.nextLine();          System.out.println(repeatedSubstringPattern(nextLine));      &#125;        public static boolean repeatedSubstringPattern(String s) &#123;          int n = s.length();          for (int i = 1; i * 2 &lt;= n; i++) &#123;              if (n % i == 0) &#123;                  boolean match = true;                  for (int j = i; j &lt; n; j++) &#123;                      if (s.charAt(j) != s.charAt(j - i)) &#123;                          match = false;                          break;                      &#125;                  &#125;                  if (match) &#123;                      return true;                  &#125;              &#125;          &#125;            return false;      &#125;  &#125;\n看讲解\n28 实现 strStr()\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0028.实现strStr.html)\n本题应该用 KMP 思路，这个算法主要用在字符串匹配上。KMP 的经典思想就是:当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。\n/**   * 思路：使用KMP算法。   * 之前双指针移动，不相等haystack的指针返回到初始匹配位置的下一位（暴力求解）   * 现在使用KMP算法，不相等移动到next表中标记的位置。   * 所以现在的关键就在于next表的计算：   * 1.初始化   * 2.当前后缀不相等时的思路（回退）   * 3.当前后缀相等时的思路（继续后移）   * 内部相当于也进行了KMP */  public static int strStr1(String haystack, String needle) &#123;      // 获取Next表      int[] ints = new int[needle.length()];      int[] next = getNext(ints, needle);        int j = 0;      if (needle.length() == 0) &#123;          return -1;      &#125;      for (int i = 0; i &lt; haystack.length(); i++) &#123;          // 不相等, j回退          while (j != 0 &amp;&amp; haystack.charAt(i) != needle.charAt(j)) &#123;              j = next[j - 1];          &#125;          // 相等          if (haystack.charAt(i) == needle.charAt(j)) &#123;              // 完全匹配，返回下标              if (j == needle.length() - 1) &#123;                  return i - j;              &#125;              j++;          &#125;        &#125;      return  -1;  &#125;    /**   * 获取next表，例：   * a a b a a f   * 0 1 0 1 2 0 * * 1.初始化   * 2.当前后缀不相等时的思路（回退）   * 3.当前后缀相等时的思路（继续后移）   *   * @param next 返回的next数组   * @param s 要求的字符串   * @return next数组   */  private static int[] getNext(int[] next, String s) &#123;      // 初始化 两个指针i和j，j指向前缀末尾位置(同时也是之前最长相等的前后缀长度)，i指向后缀末尾位置(随着字符串长度递增，递增)。      // 刚刚初始化时，字符串为a，所以j = 0      int j = 0;      next[0] = j;        // 这里i从1开始，没有搞懂(因为初始位置一定为0吗)      for (int i = 1; i &lt; s.length(); i++) &#123;          while (j != 0 &amp;&amp; s.charAt(i) != s.charAt(j)) &#123;              j = next[j - 1];          &#125;          if (s.charAt(i) == s.charAt(j)) &#123;              j++;          &#125;          next[i] = j;      &#125;      return next;  &#125;\n459 重复的子字符串\n题目链接/文章讲解/视频讲解：(https://programmercarl.com/0459.重复的子字符串.html)\n/**   * KMP思路   * 如果这个字符串是由重复子串组成的，那么字符串长度-最长相等前后缀就为重复子串的长度   * 反过来说，如果一个字符串的最长相等前后缀与长度的差值（即可能是重复子串长度的这个值）能被字符串长度整除，那么就说明这个字符串是由重复子串组成的   * 但是这个反过来说。需要证明。（虽然画了几种情况都是这样）   *   * KMP复习：   * 1.初始化   * 2.不相等的情况   * 3.相等的情况   */  public static boolean repeatedSubstringPattern1(String s) &#123;      int[] next = getNext(s);      // 这里除了上面说的条件之外，还需要加上next[len - 1] != -1, 这说明字符串有最长相同的前后缀（就是字符串里的前缀子串和后缀子串相同的最长长度）      return next[s.length() - 1] != 0 &amp;&amp; s.length() % (s.length() - next[s.length() - 1]) == 0;  &#125;    private static int[] getNext(String s) &#123;      int j = 0;      int[] next = new int[s.length()];      next[j] = 0;        for (int i = 1; i &lt; s.length(); i++) &#123;          while (j != 0 &amp;&amp; s.charAt(i) != s.charAt(j)) &#123;              j = next[j - 1];          &#125;          if (s.charAt(i) == s.charAt(j)) &#123;              j++;          &#125;          next[i] = j;      &#125;        return next;  &#125;\n","categories":["面试","代码随想录"],"tags":["双指针","字符串","KMP"]},{"title":"Obsidian + Git + Hexo + 图床 = Blog + 个人笔记体系","url":"/posts/121fccfa/","content":"\n\n前言之前有过基于 Hexo 的博客搭建经历，但是由于时间繁忙，加上后续学习了解到的笔记软件，拥有我想要的全局搜索功能，而且比博客的格式、排版更加吸引人，就放弃了之前搭建的博客。但是出来找工作感觉拥有一个自己的技术博客会比较占优势，因此打算在笔记的基础上，加上原来的 Hexo 快速生成，转成技术博客输出。\n\n\n参考文章\n\n\n\n【保姆级】利用Github搭建自己的个人博客，看完就会\nHexo + Obsidian + Git 完美的博客部署与编辑方案\n\n\n\n更新\n\n\n22.12.11 初始记录(修改预计开始日期为元旦)23.02.24 环境部署，个人博客绑定到 Gitee Pages23.02.27 Obsidian 整合 等待Gitee Pages审核ing24.03.28 更新域名绑定等相关问题24.06.17 添加更多功能\n\n环境部署\n安装git\n\n\n访问 git 官方地址，下载对应的安装包，进行安装（简单的点击下一步）。\n\n\n安装好之后，鼠标右键可以看到：Git Bash Here，点击后打开了。\n\n\n输入：git --version\n出现版本号说明安装成功。\n\n\n安装node.js\n\n\n访问 node.js 官方地址，下载对应的安装包，进行安装（简单的点击下一步）。\n\n\n安装好之后，配置环境变量，并在终端里面输入：node -v\n出现版本号说明安装成功。\n\n\n安装 Hexo\n\n\n安装命令：\n\n\nnpm install hexo -g\n测试是否安装成功，命令：hexo -v\n\n出现版本号说明安装成功。\n\n\n安装 hexo 推送 git 拓展依赖，安装命令：\n\n\nnpm install hexo-deployer-git --save\ngit 配置 SSH key\n\n\n先看本地是否配置好 SSH key（命令：cd ~/.ssh）\nSSH key 的保存位置在本地的 C:\\Users\\&#123;你的用户名&#125;\\.ssh 文件下，如果本地已存在 SSH，此步不会有提示，否则出现 No such file or directory。\n如果保存文件下没有文件 id_rsa.pub 或 id_dsa.pub 则也需要重新生成\n\n\n生成 SSH key\n如果没有配置输入生成命令，然后连续回车三次即可：\n\n\nssh-keygen -t rsa -C &quot;邮件地址&quot; #该邮箱地址是绑定github账号的地址\ngithub\n\n\n打开 SSH key 的保存位置，复制 id_rsa.pub 文件里全部内容，接着打开 github 主页，点击个人设置，点击左侧的 SSH and GPG keys，点击 New SSH key\n\n\n\n将 id_rsa.pub 复制的内容粘贴到 key 中，title 随便起一个就行。\n\n\n\n测试是否成功，输入命令：\n\n\nssh -T git@github.com\n出现  You've successfully authenticated, but GitHub does not provide shell access. 说明成功\n\n\n配置账号和密码\n\n\n$ git config --global user.name &quot;liyunchen&quot; #你的github用户名 $ git config --global user.email &quot;xxx@163.com&quot; #填写你的github注册邮箱\ngitee\n\n除了 Github Pages，也可以把博客搭建在 Gitee Pages 上，不翻墙的情况下，连接 github 经常会出现连接不上的情况，所以这次就直接改到 Gitee 上了。又换回来了，gitee 实在太烦了，部署完了还要点确定（24.02.02）\n\n\n\n同样的配置 SSH key，在 Gitee 的个人设置界面添加公钥\n\n\n\n测试是否成功，输入命令：\n\n\nssh -T git@gitee.com\n出现  You've successfully authenticated, but GITEE.COM does not provide shell access. 说明成功\n搭建个人博客\n\n\n新建一个保存博客的存放目录，进入到本地博客存放目录，初始化个人博客，命令：\n\n\nhexo init\n出现不可获取错误说明 github 连接失败，再重新执行一遍命令就可以了\n\n\n\n生成静态网页，命令：\n\n\nhexo g\n\n\n本地预览，命令：\n\n\nhexo s\n访问 localhost:4000\ngithub\n\n\n新建一个 github 仓库，给仓库起个名称，可以为 用户名.github.io，这样这个名称就可以作为你 github 博客的访问地址\n\n\n编辑 _config.yml，此文件在你博客存放目录下，需要编辑的 github 地址填写在最后 deploy 处\n\n\ndeploy: \ttype: git \trepository: #仓库地址\tbranch: main #查看自己仓库是master还是main\n\n\n发布到 github，命令：\n\n\nhexo d\n这样就已经把生成的静态文件推送到 github 仓库去了。\ngitee\n\n\n新建一个 gitee 仓库，给仓库起个名称，这里我直接用 blog 作为名称，这样博客的访问地址就是 用户名.gitee.io/blog\n\n\n编辑 _config.yml，此文件在你博客存放目录下，文件需要\n\n\ndeploy: \ttype: git \trepository: #仓库地址\tbranch: master #查看自己仓库是master还是main\n\n\n发布到 gitee，命令：\n\n\nhexo d\n\n\n在个人仓库界面，开启 Gitee Pages 服务（第一次使用还要手持身份证拍照的实名认证，蛮无语的，终于知道为什么用的人少了。。。）\n\n\n\n博客主题（Keep）\n\n在配置文件里可以看见 Hexo 主题商店 的地址，配置文件中默认的主题为 landscape，不太喜欢打算换掉。原先博客使用的是 Next 主题，也是使用 Hexo 搭建博客用到最多的主题，但是也用腻了。现在发现一个新的主题 Keep，感觉蛮简洁舒适的，所以这次重新搭建也打算直接换上。\n\nKeep 主题的官方配置文档很详细，在演示博客中有一个 使用指南，直接照着配置就行。\nObsidian 整合\nObsidian 知识库创建\n\n\n新建一个仓库或将之前的博客文件作为仓库打开\n\n\n\n忽略多余的文件。我们主要是编辑和管理 Markdown 文件，所以一些多余的文件要忽略掉，这样在知识库里搜索文件、关键字时才不会搜索到多余的，也能有效提高检索效率。打开：设置&gt;文件与链接&gt;Exclude Files\n\n\n\n设置新建笔记的存放位置，内部链接类型~~（关闭 Wiki 链接的使用，因为 hexo 的解析要求为 markdown 格式的文件）~~以及附件默认的存放路径\n\n\n\n在 hexo 项目的 .gitignore 文件中加入如下内容：\n\n\n.obsidian/workspace\n博客文章的管理\n\n新建文件在 hexo 的默认配置中放在 source/_post 目录下，随着文章数量的增多，文章也会变得难以寻找。因此采用以文件夹来分目录的方式，存放写好的文件。但是这样分类后，还需要手动维护文章开始前的定义文字，去修改文件所在的目录，较为麻烦。\n\n为了省去手动维护 categorys 字段的这个问题，我们可以使用 hexo-auto-category 这个插件。这个插件在 Hexo 进行 build 的时候会去自动根据文章目录情况来自动修改文章的 categories 信息，更详细的部分可以看 作者的文章。\n除此之外最好修改一下 _config.yml 中的默认配置：\npermalink: :year/:month/:hash.html\n但是这里有一个问题，就是只有 hexo 在执行 hexo generate 或者 hexo server 时候才会去触发 categories 的生成，那么每次我们创建文章都要重新 hexo generate 以触发插件的自动校正功能，并再次把更新后的变更提交推送 git。\n参考 博客 使用 Husky 完成 git hook 的操作：\n\n\n安装 huksy：npm install husky --save-dev\n\n\n执行 huksy 初始化指令：npx husky install\n\n\n在 package.json 中的 scripts 中写入：&quot;prepare&quot;: &quot;husky install&quot;\n\n\n在生成的 .husky 目录创建 pre-commit 文件（有的话就不用创建），并写入以下内容：\n\n\n#!/usr/bin/env sh. &quot;$(dirname -- &quot;$0&quot;)/_/husky.sh&quot;npx hexo generate &amp;&amp; git add .\n如果提交代码的时候，终端出现类似的构建过程，就说明由 husky 创建的 git hook 生效了。\n\nhexo 博客默认携带的两个文件夹为 categories 和 tags ，这两个标签可以在文章开始前定义，然后 hexo 会自动解析该文章所属的目录和标签。\n\n上面已经通过插件解决了目录的问题，还剩下文章的标题和 tags。Obsidian 是支持创建新文件时插入模板的，这就意味着我们可以不用重复写 Hexo 博客文的 Front-matter 部分。\n\n\n在 source 目录下创建 _obsidian 文件夹，并创建一篇 Post Template 的文章（md 文件），内容为：\n\n\n---title: &#123;&#123;title&#125;&#125;date: &#123;&#123;date&#125;&#125;tags: []---\n\n\n然后进入到 Obsidian 的设置面板，选择核心插件，并启用模板功能。同时点击旁边的配置按钮，进入到模板配置的设置中，设置配置信息\n\n\n\n之后，我们再创建新文章的时候，只需要点击侧边栏的插入模板按钮就可以快速生成 Front-matter 信息：\n\n\n\n博客图片的管理\n\n在 Obsidian 中，可以直接粘贴截图，并设置默认保存位置。相对路径保存的格式如下：![](attachments/xxx.png)，但是这样部署到 hexo 中的图片会显示 404 加载不成功的错误。\n\n原先的办法是将 _config.yml 配置文件中的 post_asset_folder 选项设置为 true 来打开。该功能打开后，Hexo 将会在你每一次通过 hexo new [layout] &lt;title&gt; 命令创建新文章时自动创建一个文件夹。这个资源文件夹名与文章文件名相同。将所有与你的文章有关的资源（如图片）放在这个关联文件夹中之后，通过相对路径来引用它们。\n但是由于本次需要将 Obsidian 与 Hexo 结合，希望生成新文章不依靠于命令行。因此本次直接加入图床保存图片。\n使用的图床为 Keep 主题推荐的图床 PicX。  图片链接规则可能会挂，最后还是换回了阿里云。建议本地依旧备份一份图片，以防万一。\nFile Tree 定位\n\n用 Obsidian 控制文件有一个弊端在于左侧目录为全部文件，而我们编写 hexo 博客，一般只会在 _posts 文件下操作，可以使用 Obsidian 插件 File Tree Alternative Plugin\n\n安装插件后可以看到文件列变为了以下格式\n\n打开选中 _post，右键 Focus on Folder，则菜单栏只显示 _post 文件夹\n\n其他拓展\n更高级的 Markdown 渲染器\n\nHexo 默认的 Markdown 渲染器是 hexo-renderer-marked，但其支持的渲染格式有限，比如重点符号的渲染就是不成功的，因此更换更好用的渲染器 hexo-renderer-markdown-it\n\n\n\n卸载 hexo-renderer-marked\n\n\nnpm un hexo-renderer-marked --save\n\n\n安装 hexo-renderer-markdown-it\n\n\nnpm i hexo-renderer-markdown-it --save\n\n\n将如下文本复制粘贴到 Hexo 的配置文件 _config.yml 的尾部\n\n\nmarkdown:  preset: &quot;default&quot;  render:    html: true    xhtmlOut: false    langPrefix: &quot;language-&quot;    breaks: true    linkify: true    typographer: true    quotes: &quot;“”‘’&quot;  enable_rules:  disable_rules:  plugins:    - markdown-it-abbr    - markdown-it-cjk-breaks    - markdown-it-deflist    - markdown-it-emoji    - markdown-it-footnote    - markdown-it-ins    - markdown-it-mark    - markdown-it-sub    - markdown-it-sup    - markdown-it-checkbox    - markdown-it-imsize    - markdown-it-expandable    - name: markdown-it-container      options: success    - name: markdown-it-container      options: tips    - name: markdown-it-container      options: warning    - name: markdown-it-container      options: danger  anchors:    level: 2    collisionSuffix: &quot;&quot;    permalink: false    permalinkClass: &quot;header-anchor&quot;    permalinkSide: &quot;left&quot;    permalinkSymbol: &quot;¶&quot;    case: 0    separator: &quot;-&quot;\n\n\n分别使用 npm 命令安装以下三个插件，其它插件 hexo-renderer-markdown-it 渲染器已有\n\n\nnpm i markdown-it-checkboxnpm i markdown-it-imsizenpm i markdown-it-expandable\n域名绑定\n\n\n域名的购买\n\n\n在仓库里添加 CNAME 文件并在文件中填写绑定的域名\n\n\n\nping 你的 github 域名得到 IP 地址\n\n\n\n解析域名到对应的地址\n\n\n\n资源文件压缩混淆\n\nhexo-all-minifier 集成了 html-minifier、clean-css、uglify 和 imagemin 等插件，可以对 Hexo 主题资源进行有效压缩，只需安装和简单配置即可使用。\n\n\n\n安装插件\n\n\ncd your-hexonpm install hexo-all-minifier\n\n\n在 Hexo 配置文件 _config.yml 文件中，添加以下配置项\n\n\n# 资源文件压缩混淆all_minifier: true\n设置文章访问密码\n\n借助 hexo-blog-encrypt 插件，可以在 Front-Matter 中，单独为某篇文章设置密码。\n\n\n\n安装插件\n\n\ncd your-hexonpm install hexo-blog-encrypt\n\n\n配置 password 属性\n\n\n---...password: xxx---\nObsidian 的插件使用\n整理了几个常用的 Obsidian 插件。\n\n内链：[[Obsidian 的插件使用]]\n外链：Obsidian 的插件使用\n\n博客评论\n目前使用的评论系统是 Waline，根据教程操作就行。\n\nKeep 评论教程：https://keep-docs.xpoet.cn/basis/configuration-guide/comment.html\nWaline 官方教程：https://waline.js.org/guide/get-started\n\n问题\nHexo 在部署到 Github 后 CNAME 文件会消失或改变\n问题详述：之前已经在 github 上对域名进行了绑定，但是 hexo -d 之后绑定生成的 CNAME 文件被删除。\n解决方式：参考网上博客的说法，把对应的 CNAME 文件放入 source 文件夹下，这样 hexo -g 重新生成 public 文件夹下的内容时，CNAME 文件也会同步生成。再执行 hexo -d 操作后，CNAME 文件被同步发布，页面刷新域名正常不会出现 404 问题。\nHexo 链接地址改变\n处理如下：\n\n内链：[[优化 Hexo 网站的永久链接格式]]\n外链：优化 Hexo 网站的永久链接格式\n\nKeep 主题更新 tools 功能报错 btoa is not defined\n处理如下：\n\n内链：[[Keep 主题更新 tools 功能报错 btoa is not defined]]\n外链：Keep 主题更新 tools 功能报错 btoa is not defined\n\n","categories":["博客"]},{"title":"Spring Data Redis","url":"/posts/feec57d/","content":"\n\n前言\nSpring Data Redis 是 Spring 框架提供的用于操作 Redis 的方式。涵盖 Redis 的安装、Spring Cache 结合 Redis 的使用、Redis 连接池的使用和 RedisTemplate 的使用等内容。\n\n\n参考文章\nSpring Data Redis 最佳实践！\ns\n\n\n更新\n\n\n23.08.29 初始记录\n\nRedis 安装\nLinux\n\n\n下载 Redis5.0 的 Docker 镜像\n\n\ndocker pull redis:5.0\n\n\n使用 Docker 命令启动 Redis 容器\n\n\ndocker run -p 6379:6379 --name redis \\-v /mydata/redis/data:/data \\-d redis:5.0 redis-server --appendonly yes\nWindows\n\n\n下载 Windows 版本的 Redis\n\n\n\n下载后直接解压\n\n\n在当前地址栏输入 cmd 命令，执行对应的 redis 启动命令\n\n\n# 注册服务redis-server --service-install redis.windows.conf# 启动服务redis-server --service-start# 停止服务redis-server --service-stop# 删除服务redis-server --service-uninstall\nSpring Cache 操作 Redis\nSpring Cache 简介\n\n当 Spring Boot 结合 Redis 来作为缓存使用时，最简单的方式就是使用 Spring Cache 了，使用它我们无需知道 Spring 中对 Redis 的各种操作，仅仅通过它提供的@Cacheable 、@CachePut 、@CacheEvict 、@EnableCaching 等注解就可以实现缓存功能。\n\n常用注解\n@EnableCaching\n开启缓存功能，一般放在启动类上。\n@Cacheable\n使用该注解的方法当缓存存在时，会从缓存中获取数据而不执行方法，当缓存不存在时，会执行方法并把返回结果存入缓存中。一般使用在查询方法上，可以设置如下属性：\n\n\nvalue：缓存名称（必填），指定缓存的命名空间；\n\n\nkey：用于设置在命名空间中的缓存 key 值，可以使用 SpEL 表达式定义；\n\n\nunless：条件符合则不缓存；\n\n\ncondition：条件符合则缓存。\n\n\n@CachePut\n使用该注解的方法每次执行时都会把返回结果存入缓存中。一般使用在新增方法上，可以设置如下属性：\n\n\nvalue：缓存名称（必填），指定缓存的命名空间；\n\n\nkey：用于设置在命名空间中的缓存 key 值，可以使用 SpEL 表达式定义；\n\n\nunless：条件符合则不缓存；\n\n\ncondition：条件符合则缓存。\n\n\n@CacheEvict\n使用该注解的方法执行时会清空指定的缓存。一般使用在更新或删除方法上，可以设置如下属性：\n\n\nvalue：缓存名称（必填），指定缓存的命名空间；\n\n\nkey：用于设置在命名空间中的缓存 key 值，可以使用 SpEL 表达式定义；\n\n\ncondition：条件符合则缓存。\n\n\n使用步骤\n基础步骤\n\n\n在 pom.xml 中添加项目依赖：\n\n\n&lt;!--redis依赖配置--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n修改配置文件 application.yml，添加 Redis 的连接配置\n\n\nspring:  redis:    host: 192.168.6.139 # Redis服务器地址    database: 0 # Redis数据库索引（默认为0）    port: 6379 # Redis服务器连接端口    password: # Redis服务器连接密码（默认为空）    timeout: 1000ms # 连接超时时间\n\n\n在启动类上添加@EnableCaching 注解启动缓存功能\n\n\n@EnableCaching@SpringBootApplicationpublic class Application &#123;    public static void main(String[] args) &#123;        SpringApplication.run(Application.class, args);    &#125;&#125;\n\n\n类中实现缓存功能\n\n\n/** * PmsBrandService实现类 * Created by macro on 2019/4/19. */@Servicepublic class PmsBrandServiceImpl implements PmsBrandService &#123;    @Autowired    private PmsBrandMapper brandMapper;    @CacheEvict(value = RedisConfig.REDIS_KEY_DATABASE, key = &quot;&#x27;pms:brand:&#x27;+#id&quot;)    @Override    public int update(Long id, PmsBrand brand) &#123;        brand.setId(id);        return brandMapper.updateByPrimaryKeySelective(brand);    &#125;    @CacheEvict(value = RedisConfig.REDIS_KEY_DATABASE, key = &quot;&#x27;pms:brand:&#x27;+#id&quot;)    @Override    public int delete(Long id) &#123;        return brandMapper.deleteByPrimaryKey(id);    &#125;    @Cacheable(value = RedisConfig.REDIS_KEY_DATABASE, key = &quot;&#x27;pms:brand:&#x27;+#id&quot;, unless = &quot;#result==null&quot;)    @Override    public PmsBrand getItem(Long id) &#123;        return brandMapper.selectByPrimaryKey(id);    &#125;&#125;\n存储 JSON 格式数据\n\n给 RedisTemplate 设置 JSON 格式的序列化器，并通过配置 RedisCacheConfiguration 设置超时时间来实现以上需求，此时还需要去除启动类上的@EnableCaching 注解，具体配置类 RedisConfig 代码如下\n\n/** * Redis配置类 * Created by macro on 2020/3/2. */@EnableCaching@Configurationpublic class RedisConfig extends CachingConfigurerSupport &#123;    /**     * redis数据库自定义key     */    public  static final String REDIS_KEY_DATABASE=&quot;mall&quot;;    @Bean    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;        RedisSerializer&lt;Object&gt; serializer = redisSerializer();        RedisTemplate&lt;String, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;();        redisTemplate.setConnectionFactory(redisConnectionFactory);        redisTemplate.setKeySerializer(new StringRedisSerializer());        redisTemplate.setValueSerializer(serializer);        redisTemplate.setHashKeySerializer(new StringRedisSerializer());        redisTemplate.setHashValueSerializer(serializer);        redisTemplate.afterPropertiesSet();        return redisTemplate;    &#125;    @Bean    public RedisSerializer&lt;Object&gt; redisSerializer() &#123;        //创建JSON序列化器        Jackson2JsonRedisSerializer&lt;Object&gt; serializer = new Jackson2JsonRedisSerializer&lt;&gt;(Object.class);        ObjectMapper objectMapper = new ObjectMapper();        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);        objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);        serializer.setObjectMapper(objectMapper);        return serializer;    &#125;    @Bean    public RedisCacheManager redisCacheManager(RedisConnectionFactory redisConnectionFactory) &#123;        RedisCacheWriter redisCacheWriter = RedisCacheWriter.nonLockingRedisCacheWriter(redisConnectionFactory);        //设置Redis缓存有效期为1天        RedisCacheConfiguration redisCacheConfiguration = RedisCacheConfiguration.defaultCacheConfig()                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer())).entryTtl(Duration.ofDays(1));        return new RedisCacheManager(redisCacheWriter, redisCacheConfiguration);    &#125;&#125;\n使用 Redis 连接池\n\nSpringBoot 1.5.x 版本 Redis 客户端默认是 Jedis 实现的，SpringBoot 2.x 版本中默认客户端是用 Lettuce 实现的，我们先来了解下 Jedis 和 Lettuce 客户端。\n\nJedis vs Lettuce\nJedis 在实现上是直连 Redis 服务，多线程环境下非线程安全，除非使用连接池，为每个 RedisConnection 实例增加物理连接。\nLettuce 是一种可伸缩，线程安全，完全非阻塞的 Redis 客户端，多个线程可以共享一个 RedisConnection，它利用 Netty NIO 框架来高效地管理多个连接，从而提供了异步和同步数据访问方式，用于构建非阻塞的反应性应用程序。\n使用步骤\n\n\n修改 application.yml 添加 Lettuce 连接池配置，用于配置线程数量和阻塞等待时间\n\n\nspring:  redis:    lettuce:      pool:        max-active: 8 # 连接池最大连接数        max-idle: 8 # 连接池最大空闲连接数        min-idle: 0 # 连接池最小空闲连接数        max-wait: -1ms # 连接池最大阻塞等待时间，负值表示没有限制\n\n\n由于 SpringBoot 2.x 中默认并没有使用 Redis 连接池，所以需要在 pom.xml 中添加 commons-pool2 的依赖\n\n\n&lt;dependency&gt;    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;    &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n不添加依赖则报错\n\n\nCaused by: java.lang.NoClassDefFoundError: org/apache/commons/pool2/impl/GenericObjectPoolConfig\tat org.springframework.data.redis.connection.lettuce.LettucePoolingClientConfiguration$LettucePoolingClientConfiguYrRUIQWOPrationBuilder.&lt;init&gt;(LettucePoolingClientConfiguration.java:84) ~[spring-data-redis-2.1.5.RELEASE.jar:2.1.5.RELEASE]\tat org.springframework.data.redis.connection.lettuce.LettucePoolingClientConfiguration.builder(LettucePoolingClientConfiguration.java:48) ~[spring-data-redis-2.1.5.RELEASE.jar:2.1.5.RELEASE]\tat org.springframework.boot.autoconfigure.data.redis.LettuceConnectionConfiguration$PoolBuilderFactory.createBuilder(LettuceConnectionConfiguration.java:149) ~[spring-boot-autoconfigure-2.1.3.RELEASE.jar:2.1.3.RELEASE]\tat org.springframework.boot.autoconfigure.data.redis.LettuceConnectionConfiguration.createBuilder(LettuceConnectionConfiguration.java:107) ~[spring-boot-autoconfigure-2.1.3.RELEASE.jar:2.1.3.RELEASE]\tat org.springframework.boot.autoconfigure.data.redis.LettuceConnectionConfiguration.getLettuceClientConfiguration(LettuceConnectionConfiguration.java:93) ~[spring-boot-autoconfigure-2.1.3.RELEASE.jar:2.1.3.RELEASE]\tat org.springframework.boot.autoconfigure.data.redis.LettuceConnectionConfiguration.redisConnectionFactory(LettuceConnectionConfiguration.java:74) ~[spring-boot-autoconfigure-2.1.3.RELEASE.jar:2.1.3.RELEASE]\tat org.springframework.boot.autoconfigure.data.redis.LettuceConnectionConfiguration$$EnhancerBySpringCGLIB$$5caa7e47.CGLIB$redisConnectionFactory$0(&lt;generated&gt;) ~[spring-boot-autoconfigure-2.1.3.RELEASE.jar:2.1.3.RELEASE]\tat org.springframework.boot.autoconfigure.data.redis.LettuceConnectionConfiguration$$EnhancerBySpringCGLIB$$5caa7e47$$FastClassBySpringCGLIB$$b8ae2813.invoke(&lt;generated&gt;) ~[spring-boot-autoconfigure-2.1.3.RELEASE.jar:2.1.3.RELEASE]\tat org.springframework.cglib.proxy.MethodProxy.invokeSuper(MethodProxy.java:244) ~[spring-core-5.1.5.RELEASE.jar:5.1.5.RELEASE]\tat org.springframework.context.annotation.ConfigurationClassEnhancer$BeanMethodInterceptor.intercept(ConfigurationClassEnhancer.java:363) ~[spring-context-5.1.5.RELEASE.jar:5.1.5.RELEASE]\tat org.springframework.boot.autoconfigure.data.redis.LettuceConnectionConfiguration$$EnhancerBySpringCGLIB$$5caa7e47.redisConnectionFactory(&lt;generated&gt;) ~[spring-boot-autoconfigure-2.1.3.RELEASE.jar:2.1.3.RELEASE]\tat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_91]\tat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_91]\tat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_91]\tat java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_91]\tat org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:154) ~[spring-beans-5.1.5.RELEASE.jar:5.1.5.RELEASE]\t... 111 common frames omitted\n自由操作 Redis\n\n使用 RedisTemplate 自由缓存方法中产生的中间值\n\nRedisService\n/** * redis操作Service * Created by macro on 2020/3/3. */public interface RedisService &#123;    /**     * 保存属性     */    void set(String key, Object value, long time);    /**     * 保存属性     */    void set(String key, Object value);    /**     * 获取属性     */    Object get(String key);    /**     * 删除属性     */    Boolean del(String key);    /**     * 批量删除属性     */    Long del(List&lt;String&gt; keys);    /**     * 设置过期时间     */    Boolean expire(String key, long time);    /**     * 获取过期时间     */    Long getExpire(String key);    /**     * 判断是否有该属性     */    Boolean hasKey(String key);    /**     * 按delta递增     */    Long incr(String key, long delta);    /**     * 按delta递减     */    Long decr(String key, long delta);    /**     * 获取Hash结构中的属性     */    Object hGet(String key, String hashKey);    /**     * 向Hash结构中放入一个属性     */    Boolean hSet(String key, String hashKey, Object value, long time);    /**     * 向Hash结构中放入一个属性     */    void hSet(String key, String hashKey, Object value);    /**     * 直接获取整个Hash结构     */    Map&lt;Object, Object&gt; hGetAll(String key);    /**     * 直接设置整个Hash结构     */    Boolean hSetAll(String key, Map&lt;String, Object&gt; map, long time);    /**     * 直接设置整个Hash结构     */    void hSetAll(String key, Map&lt;String, Object&gt; map);    /**     * 删除Hash结构中的属性     */    void hDel(String key, Object... hashKey);    /**     * 判断Hash结构中是否有该属性     */    Boolean hHasKey(String key, String hashKey);    /**     * Hash结构中属性递增     */    Long hIncr(String key, String hashKey, Long delta);    /**     * Hash结构中属性递减     */    Long hDecr(String key, String hashKey, Long delta);    /**     * 获取Set结构     */    Set&lt;Object&gt; sMembers(String key);    /**     * 向Set结构中添加属性     */    Long sAdd(String key, Object... values);    /**     * 向Set结构中添加属性     */    Long sAdd(String key, long time, Object... values);    /**     * 是否为Set中的属性     */    Boolean sIsMember(String key, Object value);    /**     * 获取Set结构的长度     */    Long sSize(String key);    /**     * 删除Set结构中的属性     */    Long sRemove(String key, Object... values);    /**     * 获取List结构中的属性     */    List&lt;Object&gt; lRange(String key, long start, long end);    /**     * 获取List结构的长度     */    Long lSize(String key);    /**     * 根据索引获取List中的属性     */    Object lIndex(String key, long index);    /**     * 向List结构中添加属性     */    Long lPush(String key, Object value);    /**     * 向List结构中添加属性     */    Long lPush(String key, Object value, long time);    /**     * 向List结构中批量添加属性     */    Long lPushAll(String key, Object... values);    /**     * 向List结构中批量添加属性     */    Long lPushAll(String key, Long time, Object... values);    /**     * 从List结构中移除属性     */    Long lRemove(String key, long count, Object value);&#125;\nRedisServiceImpl\n/** * redis操作实现类 * Created by macro on 2020/3/3. */@Servicepublic class RedisServiceImpl implements RedisService &#123;    @Autowired    private RedisTemplate&lt;String, Object&gt; redisTemplate;    @Override    public void set(String key, Object value, long time) &#123;        redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);    &#125;    @Override    public void set(String key, Object value) &#123;        redisTemplate.opsForValue().set(key, value);    &#125;    @Override    public Object get(String key) &#123;        return redisTemplate.opsForValue().get(key);    &#125;    @Override    public Boolean del(String key) &#123;        return redisTemplate.delete(key);    &#125;    @Override    public Long del(List&lt;String&gt; keys) &#123;        return redisTemplate.delete(keys);    &#125;    @Override    public Boolean expire(String key, long time) &#123;        return redisTemplate.expire(key, time, TimeUnit.SECONDS);    &#125;    @Override    public Long getExpire(String key) &#123;        return redisTemplate.getExpire(key, TimeUnit.SECONDS);    &#125;    @Override    public Boolean hasKey(String key) &#123;        return redisTemplate.hasKey(key);    &#125;    @Override    public Long incr(String key, long delta) &#123;        return redisTemplate.opsForValue().increment(key, delta);    &#125;    @Override    public Long decr(String key, long delta) &#123;        return redisTemplate.opsForValue().increment(key, -delta);    &#125;    @Override    public Object hGet(String key, String hashKey) &#123;        return redisTemplate.opsForHash().get(key, hashKey);    &#125;    @Override    public Boolean hSet(String key, String hashKey, Object value, long time) &#123;        redisTemplate.opsForHash().put(key, hashKey, value);        return expire(key, time);    &#125;    @Override    public void hSet(String key, String hashKey, Object value) &#123;        redisTemplate.opsForHash().put(key, hashKey, value);    &#125;    @Override    public Map&lt;Object, Object&gt; hGetAll(String key) &#123;        return redisTemplate.opsForHash().entries(key);    &#125;    @Override    public Boolean hSetAll(String key, Map&lt;String, Object&gt; map, long time) &#123;        redisTemplate.opsForHash().putAll(key, map);        return expire(key, time);    &#125;    @Override    public void hSetAll(String key, Map&lt;String, Object&gt; map) &#123;        redisTemplate.opsForHash().putAll(key, map);    &#125;    @Override    public void hDel(String key, Object... hashKey) &#123;        redisTemplate.opsForHash().delete(key, hashKey);    &#125;    @Override    public Boolean hHasKey(String key, String hashKey) &#123;        return redisTemplate.opsForHash().hasKey(key, hashKey);    &#125;    @Override    public Long hIncr(String key, String hashKey, Long delta) &#123;        return redisTemplate.opsForHash().increment(key, hashKey, delta);    &#125;    @Override    public Long hDecr(String key, String hashKey, Long delta) &#123;        return redisTemplate.opsForHash().increment(key, hashKey, -delta);    &#125;    @Override    public Set&lt;Object&gt; sMembers(String key) &#123;        return redisTemplate.opsForSet().members(key);    &#125;    @Override    public Long sAdd(String key, Object... values) &#123;        return redisTemplate.opsForSet().add(key, values);    &#125;    @Override    public Long sAdd(String key, long time, Object... values) &#123;        Long count = redisTemplate.opsForSet().add(key, values);        expire(key, time);        return count;    &#125;    @Override    public Boolean sIsMember(String key, Object value) &#123;        return redisTemplate.opsForSet().isMember(key, value);    &#125;    @Override    public Long sSize(String key) &#123;        return redisTemplate.opsForSet().size(key);    &#125;    @Override    public Long sRemove(String key, Object... values) &#123;        return redisTemplate.opsForSet().remove(key, values);    &#125;    @Override    public List&lt;Object&gt; lRange(String key, long start, long end) &#123;        return redisTemplate.opsForList().range(key, start, end);    &#125;    @Override    public Long lSize(String key) &#123;        return redisTemplate.opsForList().size(key);    &#125;    @Override    public Object lIndex(String key, long index) &#123;        return redisTemplate.opsForList().index(key, index);    &#125;    @Override    public Long lPush(String key, Object value) &#123;        return redisTemplate.opsForList().rightPush(key, value);    &#125;    @Override    public Long lPush(String key, Object value, long time) &#123;        Long index = redisTemplate.opsForList().rightPush(key, value);        expire(key, time);        return index;    &#125;    @Override    public Long lPushAll(String key, Object... values) &#123;        return redisTemplate.opsForList().rightPushAll(key, values);    &#125;    @Override    public Long lPushAll(String key, Long time, Object... values) &#123;        Long count = redisTemplate.opsForList().rightPushAll(key, values);        expire(key, time);        return count;    &#125;    @Override    public Long lRemove(String key, long count, Object value) &#123;        return redisTemplate.opsForList().remove(key, count, value);    &#125;&#125;\nRedisController\n\n简单测试在 Controller 中进行操作\n\n/** * Redis测试Controller * Created by macro on 2020/3/3. */@Api(tags = &quot;RedisController&quot;, description = &quot;Redis测试&quot;)@Controller@RequestMapping(&quot;/redis&quot;)public class RedisController &#123;    @Autowired    private RedisService redisService;    @Autowired    private PmsBrandService brandService;    @ApiOperation(&quot;测试简单缓存&quot;)    @RequestMapping(value = &quot;/simpleTest&quot;, method = RequestMethod.GET)    @ResponseBody    public CommonResult&lt;PmsBrand&gt; simpleTest() &#123;        List&lt;PmsBrand&gt; brandList = brandService.list(1, 5);        PmsBrand brand = brandList.get(0);        String key = &quot;redis:simple:&quot; + brand.getId();        redisService.set(key, brand);        PmsBrand cacheBrand = (PmsBrand) redisService.get(key);        return CommonResult.success(cacheBrand);    &#125;    @ApiOperation(&quot;测试Hash结构的缓存&quot;)    @RequestMapping(value = &quot;/hashTest&quot;, method = RequestMethod.GET)    @ResponseBody    public CommonResult&lt;PmsBrand&gt; hashTest() &#123;        List&lt;PmsBrand&gt; brandList = brandService.list(1, 5);        PmsBrand brand = brandList.get(0);        String key = &quot;redis:hash:&quot; + brand.getId();        Map&lt;String, Object&gt; value = BeanUtil.beanToMap(brand);        redisService.hSetAll(key, value);        Map&lt;Object, Object&gt; cacheValue = redisService.hGetAll(key);        PmsBrand cacheBrand = BeanUtil.mapToBean(cacheValue, PmsBrand.class, true);        return CommonResult.success(cacheBrand);    &#125;    @ApiOperation(&quot;测试Set结构的缓存&quot;)    @RequestMapping(value = &quot;/setTest&quot;, method = RequestMethod.GET)    @ResponseBody    public CommonResult&lt;Set&lt;Object&gt;&gt; setTest() &#123;        List&lt;PmsBrand&gt; brandList = brandService.list(1, 5);        String key = &quot;redis:set:all&quot;;        redisService.sAdd(key, (Object[]) ArrayUtil.toArray(brandList, PmsBrand.class));        redisService.sRemove(key, brandList.get(0));        Set&lt;Object&gt; cachedBrandList = redisService.sMembers(key);        return CommonResult.success(cachedBrandList);    &#125;    @ApiOperation(&quot;测试List结构的缓存&quot;)    @RequestMapping(value = &quot;/listTest&quot;, method = RequestMethod.GET)    @ResponseBody    public CommonResult&lt;List&lt;Object&gt;&gt; listTest() &#123;        List&lt;PmsBrand&gt; brandList = brandService.list(1, 5);        String key = &quot;redis:list:all&quot;;        redisService.lPushAll(key, (Object[]) ArrayUtil.toArray(brandList, PmsBrand.class));        redisService.lRemove(key, 1, brandList.get(0));        List&lt;Object&gt; cachedBrandList = redisService.lRange(key, 0, 3);        return CommonResult.success(cachedBrandList);    &#125;&#125;\n","categories":["后端项目","准备工作"],"tags":["Redis","Spring"]},{"title":"【代码模板】文件存储","url":"/posts/159a80d0/","content":"\n\n前言项目中常用到文件上传的功能。\n\n\n更新\n\n\n24.05.30 初始记录（Minio，阿里云OSS）\n\n文件上传\n\n\n校验\n\n文件是否为空\n文件的格式\n文件的大小\n\n\n\n文件重命名\n\n\n文件目录分离\n\n使用目录分离算法 (Hash 把 hash 值作为目录名称)\n按照日期分目录 (每天创建一个新的目录)\n按照用户名分目录\n\n\n\n图片保存地点\n\nweb 服务器（项目所运行在的电脑）\n云存储服务商\n自己搭建文件服务器（FastDFS Minio）\n\n\n\n通用部分代码\n/**   * 文件上传   *   * @param file 文件   * @return Boolean   */@RestController@RequestMapping(&quot;common&quot;)public class CommonController &#123;    @PostMapping(&quot;upload&quot;)    public R uploadPic(MultipartFile file) throws IOException &#123;        // 校验        // 校验文件是否为空        if (ObjectUtil.isNull(file)) return R.error(&quot;上传文件不能为空&quot;);        // 校验文件的格式        if (!StrUtil.containsAnyIgnoreCase(FileUtil.getSuffix(file.getOriginalFilename()), &quot;jpg&quot;, &quot;png&quot;)) &#123;            return R.error(&quot;上传文件格式错误&quot;);        &#125;        // 校验文件的大小        if (file.getSize() / 1024 / 1024 &gt; 2) return R.error(&quot;文件过大，限制在2MB以内&quot;);                // 给文件进行重命名        String fileName = UUID.fastUUID().toString() + &quot;.&quot; + FileUtil.getSuffix(file.getOriginalFilename());        // 给文件目录分离                // 图片保存地点（不同保存地点实现方式不同）        .....        return R.success(fileName);    &#125;&#125;\n不同的保存地点\nweb 服务器（项目所运行在的电脑）\n\n\n文件上传部分代码\n\n\n// 这种情况下，文件存储路径为服务器上的路径名称file.transferTo(new File(&quot;D:\\\\images\\\\&quot; + fileName));\n\n\n下载\n\n\n\n\n前端直接访问服务器域名 + 存储地址\n\n\n// 这种情况下，代码中需要添加访问资源映射地址// 在拦截器中配置@Configuration  public class WebMvcConfig implements WebMvcConfigurer &#123;      @Autowired      private AuthInterceptor authInterceptor;          private static final String DWG = &quot;file:&quot; + &quot;D:/images/&quot;;      @Override      public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;    // 添加访问资源的地址        registry.addResourceHandler(&quot;/virtual/**&quot;).addResourceLocations(DWG);      &#125;        @Override      public void addInterceptors(InterceptorRegistry registry) &#123;          registry.addInterceptor(authInterceptor)                  .addPathPatterns(&quot;/**&quot;)                  .excludePathPatterns(&quot;/**/login/**&quot;, &quot;/**/*.html&quot;, &quot;/**/*.js&quot;, &quot;/**/*.css&quot;, &quot;/doc.*&quot;,                          &quot;/swagger-ui.*&quot;,                          &quot;/swagger-resources&quot;,                          &quot;/webjars/**&quot;,                          &quot;/v2/api-docs/**&quot;,                          &quot;/virtual/**&quot;                  );      &#125;  &#125;\n\n\n前端通过接口下载文件\n\n\n@GetMapping(&quot;download&quot;)public void downloadPic(String name, HttpServletResponse response) throws IOException &#123;    FileInputStream fileInputStream = new FileInputStream(&quot;D:\\\\images\\\\&quot; + name);    ServletOutputStream outputStream = response.getOutputStream();    byte[] bytes = new byte[1024];    int len = 0;    while ((len = fileInputStream.read(bytes)) != -1) &#123;        outputStream.write(bytes, 0, len);    &#125;    fileInputStream.close();    outputStream.close();&#125;\n云存储服务商\n通过开通云存储服务商的 OSS 服务，调用提供的 API，实现文件存储。一般后面两种情况会直接编写 Util 类方便多处调用。\n阿里云\nMaven 依赖\n&lt;dependency&gt;      &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt;      &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt;      &lt;version&gt;3.4.2&lt;/version&gt;  &lt;/dependency&gt;\n配置文件\naliyun:    oss:      endpoint: oss-cn-hangzhou.aliyuncs.com      accessKeyId: xxxxxxxxxxxxxxxx      accessKeySecret: xxxxxxxxxxxxxxxx      bucket:  xxxxxxxxxxxxxxxx    userFolder: user/      managerFolder: manager/\n代码\n\n\nOssAutoConfiguration.java\n\n\n@Configuration  @ConditionalOnClass(&#123;OSSClient.class&#125;)  @EnableConfigurationProperties(OssProperties.class)  public class OssAutoConfiguration &#123;        private final OssProperties ossProperties;        public OssAutoConfiguration(final OssProperties ossProperties) &#123;          this.ossProperties = ossProperties;      &#125;        @Bean      public OssClientFactoryBean ossClientFactoryBean() &#123;          final OssClientFactoryBean factoryBean = new OssClientFactoryBean();          factoryBean.setEndpoint(this.ossProperties.getEndpoint());          factoryBean.setAccessKeyId(this.ossProperties.getAccessKeyId());          factoryBean.setAccessKeySecret(this.ossProperties.getAccessKeySecret());          return factoryBean;      &#125;  &#125;\n\n\nOssClientFactoryBean.class\n\n\npublic class OssClientFactoryBean implements FactoryBean&lt;OSSClient&gt;, InitializingBean, DisposableBean &#123;        private OSSClient ossClient;      private String endpoint;      private String accessKeyId;      private String accessKeySecret;        @Override      public OSSClient getObject() throws Exception &#123;          return this.ossClient;      &#125;        @Override      public Class&lt;?&gt; getObjectType() &#123;          return OSSClient.class;      &#125;        @Override      public boolean isSingleton() &#123;          return true;      &#125;        @Override      public void destroy() throws Exception &#123;          if (this.ossClient != null) &#123;              this.ossClient.shutdown();          &#125;      &#125;        @Override      public void afterPropertiesSet() throws Exception &#123;          Assert.notNull(this.endpoint, &quot;&#x27;aliyun.oss.endpoint&#x27; must be not null&quot;);          Assert.notNull(this.accessKeyId, &quot;&#x27;aliyun.oss.accessKeyId&#x27; must be not null&quot;);          Assert.notNull(this.accessKeySecret, &quot;&#x27;aliyun.oss.accessKeySecret&#x27; must be not null&quot;);          this.ossClient = new OSSClient(this.endpoint, this.accessKeyId, this.accessKeySecret);      &#125;        public void setEndpoint(final String endpoint) &#123;          this.endpoint = endpoint;      &#125;        public void setAccessKeyId(final String accessKeyId) &#123;          this.accessKeyId = accessKeyId;      &#125;        public void setAccessKeySecret(final String accessKeySecret) &#123;          this.accessKeySecret = accessKeySecret;      &#125;  &#125;\n\n\nOssProperties.java\n\n\n@Getter  @Setter  @ConfigurationProperties(prefix = &quot;aliyun.oss&quot;)  public class OssProperties &#123;      private String endpoint;      private String accessKeyId;      private String accessKeySecret;      private String bucket;      private String userFolder;      private String managerFolder;  &#125;\n\n\nOssUtil.class\n\n\n@Slf4j  @Component  public class OssUtil &#123;      @Autowired      private OSSClient ossClient;        @Autowired      private OssProperties ossProperties;        /**       * 上传文件       * @param folder &quot;需要加/ 如&quot;xxx/&quot;&quot;       * @return 文件地址       */      public String upload(MultipartFile file, String folder) &#123;          String bucketName = ossProperties.getBucket();            // 判断Bucket的存在          if (!ossClient.doesBucketExist(bucketName)) &#123;              // 创建存储空间              Bucket bucket = ossClient.createBucket(bucketName);              bucketName = bucket.getName();          &#125;            String objectName = &quot;&quot;;          try &#123;              // 以输入流的形式上传文件              InputStream is = file.getInputStream();              // 文件名              String originalFilename = file.getOriginalFilename();              if (ObjectUtil.isNull(originalFilename)) &#123;                  throw new LogicException(&quot;文件名称获取失败&quot;);              &#125;              val suffix = originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;));              String fileName = UUID.fastUUID().toString() + suffix.toLowerCase();              objectName = folder + DateUtil.format(new Date(), &quot;yy-MM/dd&quot;) + &quot;/&quot; + fileName;                // 文件大小              long fileSize = file.getSize();                // 创建上传Object的Metadata              ObjectMetadata metadata = new ObjectMetadata();              // 上传的文件的长度              metadata.setContentLength(is.available());              // 指定该Object被下载时的网页的缓存行为              metadata.setCacheControl(&quot;no-cache&quot;);              // 指定该Object下设置Header              metadata.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);              // 指定该Object被下载时的内容编码格式              metadata.setContentEncoding(&quot;utf-8&quot;);              // 文件的MIME，定义文件的类型及网页编码，决定浏览器将以什么形式、什么编码读取文件。如果用户没有指定则根据Key或文件名的扩展名生成，              // 如果没有扩展名则填默认值application/octet-stream              metadata.setContentType(AliyunOssFileTypeEnum.getText(suffix.toLowerCase()));              // 指定该Object被下载时的名称（指示MINME用户代理如何显示附加的文件，打开或下载，及文件名称）              metadata.setContentDisposition(&quot;filename/filesize=&quot; + originalFilename + &quot;/&quot; + fileSize + &quot;Byte.&quot;);              // 上传文件 (上传文件流的形式)              PutObjectResult putResult = ossClient.putObject(bucketName, objectName, is, metadata);              // 解析结果              String resultStr = putResult.getETag();              log.info(&quot;唯一MD5数字签名:&quot; + resultStr);          &#125; catch (OSSException oe) &#123;              // oe.printStackTrace();              log.error(&quot;上传阿里云OSS服务器异常.&quot; + oe.getMessage(), oe);          &#125; catch (ClientException ce) &#123;              // ce.printStackTrace();              log.error(&quot;阿里云OSS服务连接异常.&quot; + ce.getMessage(), ce);          &#125; catch (IOException e) &#123;              // e.printStackTrace();              log.error(&quot;文件流异常.&quot; + e.getMessage(), e);          &#125;          return &quot;https://&quot; + ossProperties.getBucket() + &quot;.&quot; + ossProperties.getEndpoint() + &quot;/&quot; + objectName;      &#125;        /**       * 上传文件 byte ()       * @param folder &quot;需要加/ 如&quot;xxx/&quot;&quot;       * @return 文件地址       */      public String imgUploadByByte(byte[] bytes, String folder) &#123;          String bucketName = ossProperties.getBucket();            // 判断Bucket的存在          if (!ossClient.doesBucketExist(bucketName)) &#123;              // 创建存储空间              Bucket bucket = ossClient.createBucket(bucketName);              bucketName = bucket.getName();          &#125;            String objectName = &quot;&quot;;          try &#123;              InputStream inputStream = new ByteArrayInputStream(bytes);                val suffix = &quot;jpg&quot;;              String fileName = UUID.fastUUID().toString() +suffix;              objectName = folder + DateUtil.format(new Date(), &quot;yy-MM/dd&quot;) + &quot;/&quot; + fileName;                // 创建上传Object的Metadata              ObjectMetadata metadata = new ObjectMetadata();              // 上传的文件的长度              metadata.setContentLength(inputStream.available());              // 指定该Object被下载时的网页的缓存行为              metadata.setCacheControl(&quot;no-cache&quot;);              // 指定该Object下设置Header              metadata.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;);              // 指定该Object被下载时的内容编码格式              metadata.setContentEncoding(&quot;utf-8&quot;);              // 文件的MIME，定义文件的类型及网页编码，决定浏览器将以什么形式、什么编码读取文件。如果用户没有指定则根据Key或文件名的扩展名生成，              // 如果没有扩展名则填默认值application/octet-stream              metadata.setContentType(AliyunOssFileTypeEnum.getText(suffix));              // 上传文件 (上传文件流的形式)              PutObjectResult putResult = ossClient.putObject(bucketName, objectName, inputStream, metadata);              // 解析结果              String resultStr = putResult.getETag();              log.info(&quot;唯一MD5数字签名:&quot; + resultStr);          &#125; catch (OSSException oe) &#123;              // oe.printStackTrace();              log.error(&quot;上传阿里云OSS服务器异常.&quot; + oe.getMessage(), oe);          &#125; catch (ClientException ce) &#123;              // ce.printStackTrace();              log.error(&quot;阿里云OSS服务连接异常.&quot; + ce.getMessage(), ce);          &#125; catch (IOException e) &#123;              // e.printStackTrace();              log.error(&quot;文件流异常.&quot; + e.getMessage(), e);          &#125;          return &quot;https://&quot; + ossProperties.getBucket() + &quot;.&quot; + ossProperties.getEndpoint() + &quot;/&quot; + objectName;      &#125;        /**       * 根据objectName删除OSS服务器上的文件       *       * @param objectName     模拟文件夹名 如&quot;qj_nanjing/&quot; + Bucket下的文件的路径名+文件名 如：&quot;upload/cake.jpg&quot;       */       public Boolean deleteFile(String objectName) &#123;          String bucketName = ossProperties.getBucket();          ossClient.deleteObject(bucketName, objectName);          log.info(&quot;删除&quot; + bucketName + &quot;下的文件&quot; + objectName + &quot;成功&quot;);          return true;      &#125;        /**       * 根据url获取objectName       *     * @param url url       */    public String getObjectNameByUrl(String url) &#123;  //        url = url.replace(&quot;https://&quot; + ossProperties.getBucket() + &quot;.&quot; + ossProperties.getEndpoint() + &quot;/&quot;, &quot;&quot;);          int firstIndex = url.indexOf(&quot;/&quot;);          int secondIndex = url.indexOf(&quot;/&quot;, firstIndex + 1);          int thirdIndex = url.indexOf(&quot;/&quot;, secondIndex + 1);          int suffix = url.lastIndexOf(&quot;?&quot;) &gt; 0 ? url.lastIndexOf(&quot;?&quot;) : url.length();          url = url.substring(thirdIndex + 1, suffix);          return url;      &#125;        /**       * 获取上传文件url (非公共读写时)       *     * @param objectName 模拟文件夹名 如&quot;qj_nanjing/&quot; + Bucket下的文件的路径名+文件名 如：&quot;upload/cake.jpg&quot;       * @return url       */    public String getUrl(String objectName) &#123;          //设置URl过期时间为99年：3600L*1000*24*365*99          Date expiration = new Date(new Date().getTime() + 3600L * 1000 * 24 * 365 * 99);          GeneratePresignedUrlRequest generatePresignedUrlRequest = new GeneratePresignedUrlRequest(ossProperties.getBucket(), objectName);          generatePresignedUrlRequest.setExpiration(expiration);          URL url = ossClient.generatePresignedUrl(generatePresignedUrlRequest);          return url.toString();      &#125;&#125;\nMinio\n服务启动\n\n\nwindows 启动\n\n\nC:\\Develop\\minio\\bin&gt;minio.exe server C:\\Develop\\minio\\data --address 127.0.0.1:9005\nMaven 依赖\n&lt;dependencies&gt;      &lt;dependency&gt;          &lt;groupId&gt;io.minio&lt;/groupId&gt;          &lt;artifactId&gt;minio&lt;/artifactId&gt;          &lt;version&gt;7.1.0&lt;/version&gt;      &lt;/dependency&gt;\t&lt;!--SPI--&gt;    &lt;dependency&gt;          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;          &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;          &lt;optional&gt;true&lt;/optional&gt;      &lt;/dependency&gt;      &lt;dependency&gt;          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;          &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;      &lt;/dependency&gt;  &lt;/dependencies&gt;\n配置文件\nminio:    endpoint: xxxxxxxxxxxxxxxxxxxxxx #MinIO服务所在地址    bucketName: xxxxxxxxxxx #存储桶名称    accessKey: xxxxxxxxxxxxxxxx #访问的key    secretKey: xxxxxxxxxxxxxxxxxxx #访问的秘钥\n代码\n\n\nMinioProp.java\n\n\n@ConfigurationProperties(prefix = &quot;minio&quot;)  public class MinioProp &#123;      private String endpoint;      private String accessKey;      private String secretKey;      private String bucketName;        public String getEndpoint() &#123;          return endpoint;      &#125;        public void setEndpoint(String endpoint) &#123;          this.endpoint = endpoint;      &#125;        public String getAccessKey() &#123;          return accessKey;      &#125;        public void setAccessKey(String accessKey) &#123;          this.accessKey = accessKey;      &#125;        public String getSecretKey() &#123;          return secretKey;      &#125;        public void setSecretKey(String secretKey) &#123;          this.secretKey = secretKey;      &#125;        public String getBucketName() &#123;          return bucketName;      &#125;        public void setBucketName(String bucket) &#123;          this.bucketName = bucket;      &#125;  &#125;\n\n\nOSSFile.java\n\n\n@Data  public class OSSFile &#123;      /**       * 文件名       */      private String fileName;      /**       * 文件存储地址       */      private String url;      /**       * 文件ObjectName       */        private String objectName;  &#125;\n\n\nMinioUtil.java\n\n\n@Component  @Slf4j  @EnableConfigurationProperties(MinioProp.class)  public class MinioUtil &#123;      @Resource      private MinioProp prop;        private MinioClient minioClient;        /**       * 创建minioClient       */    @PostConstruct      public void createMinioClient() &#123;          try &#123;              if (null == minioClient) &#123;                  log.info(&quot;minioClient create start&quot;);                  minioClient = MinioClient.builder().endpoint(prop.getEndpoint())                          .credentials(prop.getAccessKey(), prop.getSecretKey())                          .build();                  createBucket();                  log.info(&quot;minioClient create end&quot;);              &#125;          &#125; catch (Exception e) &#123;              log.error(&quot;连接MinIO服务器异常：&quot; + e);          &#125;      &#125;        /**       * 初始化Bucket       *     * @throws Exception 异常       */      private void createBucket()              throws IOException, InvalidKeyException, InvalidResponseException, InsufficientDataException, NoSuchAlgorithmException, ServerException, InternalException, XmlParserException, InvalidBucketNameException, ErrorResponseException, RegionConflictException &#123;          if (!minioClient.bucketExists(BucketExistsArgs.builder().bucket(prop.getBucketName()).build())) &#123;              minioClient.makeBucket(MakeBucketArgs.builder().bucket(prop.getBucketName()).build());          &#125;      &#125;        /**       * 查看存储bucket是否存在       * @return boolean       */    public Boolean bucketExists(String bucketName) &#123;          Boolean found;          try &#123;              found = minioClient.bucketExists(BucketExistsArgs.builder().bucket(bucketName).build());          &#125; catch (Exception e) &#123;              e.printStackTrace();              return false;          &#125;          return found;      &#125;        /**       * 创建存储bucket       * @return Boolean       */        public Boolean makeBucket(String bucketName) &#123;          try &#123;              if (!bucketExists(bucketName)) &#123;                  minioClient.makeBucket(MakeBucketArgs.builder()                          .bucket(bucketName)                          .build());                  String policyJson = &quot;&#123;\\n&quot; +                          &quot;\\t\\&quot;Version\\&quot;: \\&quot;&quot;+new SimpleDateFormat(&quot;yyyy-mm-dd&quot;).format(System.currentTimeMillis())+&quot;\\&quot;,\\n&quot; +                          &quot;\\t\\&quot;Statement\\&quot;: [&#123;\\n&quot; +                          &quot;\\t\\t\\&quot;Effect\\&quot;: \\&quot;Allow\\&quot;,\\n&quot; +                          &quot;\\t\\t\\&quot;Principal\\&quot;: &#123;\\n&quot; +                          &quot;\\t\\t\\t\\&quot;AWS\\&quot;: [\\&quot;*\\&quot;]\\n&quot; +                          &quot;\\t\\t&#125;,\\n&quot; +                          &quot;\\t\\t\\&quot;Action\\&quot;: [\\&quot;s3:GetBucketLocation\\&quot;, \\&quot;s3:ListBucket\\&quot;, \\&quot;s3:ListBucketMultipartUploads\\&quot;],\\n&quot; +                          &quot;\\t\\t\\&quot;Resource\\&quot;: [\\&quot;arn:aws:s3:::&quot; + bucketName + &quot;\\&quot;]\\n&quot; +                          &quot;\\t&#125;, &#123;\\n&quot; +                          &quot;\\t\\t\\&quot;Effect\\&quot;: \\&quot;Allow\\&quot;,\\n&quot; +                          &quot;\\t\\t\\&quot;Principal\\&quot;: &#123;\\n&quot; +                          &quot;\\t\\t\\t\\&quot;AWS\\&quot;: [\\&quot;*\\&quot;]\\n&quot; +                          &quot;\\t\\t&#125;,\\n&quot; +                          &quot;\\t\\t\\&quot;Action\\&quot;: [\\&quot;s3:AbortMultipartUpload\\&quot;, \\&quot;s3:DeleteObject\\&quot;, \\&quot;s3:GetObject\\&quot;, \\&quot;s3:ListMultipartUploadParts\\&quot;, \\&quot;s3:PutObject\\&quot;],\\n&quot; +                          &quot;\\t\\t\\&quot;Resource\\&quot;: [\\&quot;arn:aws:s3:::&quot; + bucketName + &quot;/*\\&quot;]\\n&quot; +                          &quot;\\t&#125;]\\n&quot; +                          &quot;&#125;\\n&quot;;                  minioClient.setBucketPolicy(SetBucketPolicyArgs.builder().bucket(bucketName).config(policyJson).build());                  log.info(&quot;buckets：【&#123;&#125;】,创建[readwrite]策略成功！&quot;, bucketName);              &#125; else &#123;                  log.info(&quot;minio bucket-&gt;&gt;&gt;【&#123;&#125;】already exists&quot;, bucketName);              &#125;          &#125; catch (Exception e) &#123;              e.printStackTrace();              return false;          &#125;          return true;      &#125;      /**       * 删除存储bucket       * @return Boolean       */        public Boolean removeBucket(String bucketName) &#123;          try &#123;              minioClient.removeBucket(RemoveBucketArgs.builder()                      .bucket(bucketName)                      .build());          &#125; catch (Exception e) &#123;              e.printStackTrace();              return false;          &#125;          return true;      &#125;      /**       * 获取全部bucket       */        public List&lt;Bucket&gt; getAllBuckets() &#123;          try &#123;              List&lt;Bucket&gt; buckets = minioClient.listBuckets();              return buckets;          &#125; catch (Exception e) &#123;              e.printStackTrace();          &#125;          return null;      &#125;      /**       * 文件上传       *       * @param file 文件       * @return Boolean       */        public OSSFile upload(MultipartFile file) &#123;          String originalFilename = file.getOriginalFilename();          if (StrUtil.isBlank(originalFilename))&#123;              throw new RuntimeException();          &#125;          // 重命名          String fileName = UUID.fastUUID() + originalFilename.substring(originalFilename.lastIndexOf(&quot;.&quot;));          String objectName = DateUtil.format(new Date(), &quot;yy-MM/dd&quot;) + &quot;/&quot; + fileName;          try &#123;              PutObjectArgs objectArgs = PutObjectArgs.builder().bucket(prop.getBucketName()).object(objectName)                      .stream(file.getInputStream(), file.getSize(), -1).contentType(file.getContentType()).build();              //文件名称相同会覆盖              minioClient.putObject(objectArgs);          &#125; catch (Exception e) &#123;              e.printStackTrace();              return null;          &#125;            OSSFile ossFile = new OSSFile();          ossFile.setFileName(originalFilename);          ossFile.setObjectName(objectName);          ossFile.setUrl(prop.getEndpoint() + &quot;/&quot; + prop.getBucketName() + &quot;/&quot; + objectName);          return ossFile;      &#125;        /**       * 预览图片       * @param fileName       * @return       */      public String preview(String fileName)&#123;          // 查看文件地址          GetPresignedObjectUrlArgs build = new GetPresignedObjectUrlArgs().builder().bucket(prop.getBucketName()).object(fileName).method(Method.GET).build();          try &#123;              String url = minioClient.getPresignedObjectUrl(build);              return url;          &#125; catch (Exception e) &#123;              e.printStackTrace();          &#125;          return null;      &#125;        /**       * 文件下载       * @param fileName 文件名称       * @param res response       * @return Boolean       */        public void download(String fileName, HttpServletResponse res) &#123;          GetObjectArgs objectArgs = GetObjectArgs.builder().bucket(prop.getBucketName())                  .object(fileName).build();          try (InputStream response = minioClient.getObject(objectArgs))&#123;              byte[] buf = new byte[1024];              int len;              try (FastByteArrayOutputStream os = new FastByteArrayOutputStream())&#123;                  while ((len=response.read(buf))!=-1)&#123;                      os.write(buf,0,len);                  &#125;                  os.flush();                  byte[] bytes = os.toByteArray();                  res.setCharacterEncoding(&quot;utf-8&quot;);                  // 设置强制下载不打开                  // res.setContentType(&quot;application/force-download&quot;);                  res.addHeader(&quot;Content-Disposition&quot;, &quot;attachment;fileName=&quot; + fileName);                  try (ServletOutputStream stream = res.getOutputStream())&#123;                      stream.write(bytes);                      stream.flush();                  &#125;              &#125;          &#125; catch (Exception e) &#123;              e.printStackTrace();          &#125;      &#125;        /**       * 查看文件对象       * @return 存储bucket内文件对象信息       */      public List&lt;Item&gt; listObjects() &#123;          Iterable&lt;Result&lt;Item&gt;&gt; results = minioClient.listObjects(                  ListObjectsArgs.builder().bucket(prop.getBucketName()).build());          List&lt;Item&gt; items = new ArrayList&lt;&gt;();          try &#123;              for (Result&lt;Item&gt; result : results) &#123;                  items.add(result.get());              &#125;          &#125; catch (Exception e) &#123;              e.printStackTrace();              return null;          &#125;          return items;      &#125;        /**       * 删除       * @param fileName       * @return       * @throws Exception       */      public boolean remove(String fileName)&#123;          try &#123;              minioClient.removeObject( RemoveObjectArgs.builder().bucket(prop.getBucketName()).object(fileName).build());          &#125;catch (Exception e)&#123;              return false;          &#125;          return true;      &#125;  &#125;\n拓展\nMinio 这个被写成了 SPI 加载到别的服务中，这边再加一下关于 SPI 的知识。\n\n如图 resources 文件夹下的 META-INF 文件夹下的 spring.factories 文件。\n如果要把 MinioUtil 这个方法加载到别的项目中，可以这么写。\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=com.hzjzxx.minio.utils.MinioUtil\n关于 SPI 的知识：\n\n内链：[[面试-SPI]]\n外链：SPI相关\n\n","categories":["后端项目","准备工作"],"tags":["Minio","Oss"]},{"title":"面试-Spring、Spring MVC、Spring Boot","url":"/posts/dcaead99/","content":"\n\n前言\n❗表示必掌握，❔表示基本不会问\n\n\n更新\n\n\n24-06-10 初始记录24-06-12 继续24-06-13 继续24-06-14 补充剩下的知识点。Spring这块的知识后续需要看书、看源码。\n\nSpring\n说说 Spring 常用的几个注解？\n\n\n\n注解\n使用\n\n\n\n\n@Component\n取代.xml 中的；用于三层架构类之外。\n\n\n@Controller\n衍生注解；用于 Controller 层\n\n\n@Service\n衍生注解；用于 Service 层\n\n\n@Repository\n衍生注解；用于 Dao 层\n\n\n@Bean\n取代.xml 中工厂创建 bean 对象,方法的返回值成为 bean 对象。\n\n\n@Autowired\n取代.xml 中中的 ref 注入，底层是 CGLIB 动态代理。这个是本地注入。\n\n\n@Aspect\n定义在类上；设置当前类为切面类\n\n\n@Before\n定义在方法上；标注当前方法作为前置通知\n\n\n\n谈谈你对 Spring 的理解？\nSpring 是一个完整的生态，不单单是一个技术框架。\n❗Spring 框架中都用到了哪些设计模式？\n工厂模式：BeanFactory 就是简单工厂模式的体现，用来创建对象的实例；\n单例模式：Bean 默认为单例模式。\n代理模式：Spring 的 AOP 功能用到了 JDK 的动态代理和 CGLIB 字节码生成技术；\n模板方法：用来解决代码重复的问题。比如：RestTemplate，JmsTemplate，JpaTemplate。\n观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如 Spring 中 listener 的实现–ApplicationListener。\nSpring 两大核心思想是什么？\nIOC：解耦，使代码复用，可维护性大幅提升。\nAOP：提供切面编程，同样增强生产力。\n❗说一说你对 IOC 的理解？\n❗大白话：最原始的 tomcat+servlet 的编码原理。使用的时候 Myservice myservie = new MyserviceImpl()。耦合度很高，修改一个类要修改很多文件。然后我们引入 Spring 这个框架。会去由框架 Spring 容器创建实例 Bean，对象间就会直接引用（依赖注入）。然后 Spring MVC(核心 Servlet Filter 去处理请求)。IOC 底层就是反射（+ 工厂模式）、通过类去创建对象。\nIoC（Inversion Of Control）控制反转，其实是一种思想，用于解决程序间的耦合问题。【解耦】\n原本我们创建对象是直接在类中，通过 new 的方式创建，控制权在于程序员自己，现在我们把 new 对象的工作交给 spring 完成，我们只需要通过配置文件进行配置即可。反转的是对象的创建权力。【便捷】\nioc 容器，可以简单理解为一个工厂，但是他的功能比普通工厂要强大很多，内部帮助我们完成了对象的创建和整个过程管理，同时提供了很多扩展机会。【可扩展】\n❗说一说你对 AOP 的理解？\n他有几个概念，可以做一个切面。在一些类的方法中，都先织入一些代码处理类似的逻辑（日志、权限认证、事务）。Spring 在运行的时候，会有一个动态代理的技术。他会动态生成一个类，把我们的类注入，实现织入的那些代码。\nSpring AOP 里面的几个名词\n（1）切面（Aspect）：切面是通知和切点的结合。通知和切点共同定义了切面的全部内容。 在 Spring AOP 中，切面可以使用通用类（基于模式的风格） 或者在普通类中以 @AspectJ 注解来实现。\n（2）连接点（Join point）：指方法，在 Spring AOP 中，一个连接点总是代表一个方法的执行。 应用可能有数以千计的时机应用通知。这些时机被称为连接点。连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。\n（3）通知（Advice）：在 AOP 术语中，切面的工作被称为通知。\n（4）切入点（Pointcut）：切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表达式定义所匹配的类和方法名称来指定这些切点。\n（5）引入（Introduction）：引入允许我们向现有类添加新方法或属性。\n（6）目标对象（Target Object）： 被一个或者多个切面（aspect）所通知（advise）的对象。它通常是一个代理对象。也有人把它叫做被通知（adviced） 对象。 既然 Spring AOP 是通过运行时代理实现的，这个对象永远是一个 被代理（proxied） 对象。\n（7）织入（Weaving）：织入是把切面应用到目标对象并创建新的代理对象的过程。\nSpring 通知有哪些类型？\n在 AOP 术语中，切面的工作被称为通知，实际上是程序执行时要通过 SpringAOP 框架触发的代码段。\nSpring 切面可以应用 5 种类型的通知：\n\n\n前置通知（Before）：在目标方法被调用之前调用通知功能；\n\n\n后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；\n\n\n返回通知（After-returning ）：在目标方法成功执行之后调用通知；\n\n\n异常通知（After-throwing）：在目标方法抛出异常后调用通知；\n\n\n环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。\n\n\n❗cglib 动态代理和 jdk 动态代理的区别\n动态代理，其实就是动态的创建一个类出来，创建这个类的实例对象，在这个里面引用你真正自己写的类，所有方法的调用，都先走代理类对象，做一些代码上的增强。\n如果类实现了某个接口，Spring AOP 会使用 jdk 动态代理。如果某个类没有实现接口，Spring AOP 会使用 cglib 动态代理。cglib 是生成类的一个子类，可以动态生成字节码，覆盖一些方法，进行方法增强。\nBean 对象的创建方式有哪几种？\n\n\n通过 IoC 直接创建 bean 对象\n\n\n通过 IoC 创建 bean 工厂，再通过 bean 工厂的方法创建 bean 对象\n\n\n通过 IoC 创建 bean 工厂，再通过 bean 工厂的静态方法创建 bean 对象\n\n\n❗Spring 中的 Bean 是不是线程安全的？\n❔bean 的作用域可以分为 5 个范围：\n\n\nsingleton（单例）：默认每个容器中只有一个实例对象\n\n\nprototype：每次创建一个新的\n\n\nrequest\n\n\nsession\n\n\nglobal-session\n\n\n不是，Spring 框架中的单例 bean 不是线程安全的。\nSpring 中的 bean 默认是单例模式，Spring 框架并没有对单例 bean 进行多线程的封装处理。\n实际上大部分时候 Spring Bean 无状态的（比如 dao 类），所以某种程度上来说 bean 也是安全的，但如果 bean 有状态的话（比如 view model 对象），那就要开发者自己去保证线程安全了，最简单的就是改变 bean 的作用域，把“singleton”（单例）变更为“prototype”（多例），这样请求 bean 相当于 new Bean() 了，所以就可以保证线程安全了。\n有状态：就是有数据存储功能。\n无状态：就是不会保存数据。\n❗Spring Bean 的生命周期\n\n\n首先，我们知道 bean 对象的创建不是由我们自己创建的，而是由 Spring 来给我们创建的，而我们需要做的是告诉 Spring 我们需要创建哪些 Bean 对象。我们可以通过 xml、注解等方式来提供创建 Bean 对象所以需要的信息，而 Spring 要创建 bean 对象，就首先得有一个 BeanFactory 工厂来创建 Bean 对象，如果这个 Bean 对象已经存在，则销毁清空 Bean 工厂的内容，如果不存在，就会通过 DefaultListableBeanFactory 方法先创建一个 Bean 对象工厂（即 BeanFactory）。\n\n\nBeanFactory 要创建 Bean 对象，就需要 Bean 对象的相关信息，这些信息就是通过 xml 或注解方式获得，所以第二步是需要读取这些 bean 的相关信息，通过 LoadBeanDefinition 来加载配置文件，并将相关信息加载成一个个 BeanDefinition 对象（Bean 与 BeanDefinition 的关系就像类与字节码文件之间的关系）。\n\n\nBeanDefinitions 生成后，会通过 invokeBeanFactoryPostProcessors 方法对所有的 BeanDefinitions 以及 BeanFactory 进行后置处理执行：\n\n拿到当前应用上下文 beanFactoryPostProcessors 变量中的值，默认情况返回为空。\n实例化并调用所有已注册的 BeanFactoryPostProcessor 信息，也就是 Bean 的相关定义。\n\n\n\nBeanFactory 工厂的相关增强处理结束后，BanFactory 就会正式开始实 Bean 对象的实例化，由 InstantiateSingletons 方法通过反射创建 Bean 对象，其中会判断该对象是否是单例或者懒加载：如果不是单例或者不是懒加载，就采用 FactoryBean 单独构创建对象；如果是单例对象或懒加载，就由 BeanFactory 工厂直接反射创建对象。\n\n\nBeanFactory 将对象实例化之后，Spring 会通过 BeanPostProcessor（bean 对象后置处理器）对 Bean 对象的初始化的前后进行后置处理，填充 Bean 对象的属性，完成初始化。\n\n\n通过 Map 数据类型放这些 Bean 对象存放在 IOC 容器中。\n\n\nbean 销毁：注册销毁的回调方法，当对象销毁时，会执行 destory-method 方法。\n\n\n下面可以不看，感觉这块视频讲的乱七八糟的。\n大白话：再注解里定义 bean，Spring 容器根据配置创建、管理 bean 之间的依赖关系等。生命周期：创建 -&gt;使用 -&gt;销毁。从 (1) 实例化 bean，(2) 设置依赖属性（依赖注入），过程中可能会进行动态代理的处理。(3) 处理 Aware 接口，如果 Bean 实现了 ApplicationContextAware 接口，Spring 容器会调用 setApplicationContext(ApplicationContext) 方法，传入 Spring 上下文。把容器注入给 Bean。(4) 如果要对 Bean 进行一些自定义的处理，可以让 Bean 实现 BeanPostProcessors 接口。(5) 如果 Bean 配置了 init-method，会根据配置进行初始化。(6) 清理阶段，如果 Bean 实现了 DisposableBean 这个接口，会调用其实现的 destroy() 方法。(7) 如果 Bean 的 Spring 配置中配置了 destory-method 属性，会在销毁时，进行调用。\nSpring 为什么启动时要实例化几乎所有的 Bean，这样启动不是很消耗资源吗?\n主要的好处有两个：性能、提前暴露问题。\n启动时花费几十秒初始化好所有的 bean，处理好所有的依赖注入，在运行时就可以免去初始化这步了，首次访问响应速度自然更好。\n提前暴露问题就是在启动时初始化 bean，可以检查循环依赖、bean 重复、bean 不存在等等一系列的问题，有问题直接报错启动失败，那你在部署的时候就能直接发现问题，而不是等线上运行一段时间后突然反馈有问题又得跑到服务器上看日志。\nSpring 里面的 bean 为什么要注册，作用是什么？\n注册就是把信息存起来，内部是基于集合实现的，注册方便之后对于信息的调取。\nBeanFactory 和 FactoryBean 的区别是什么？\nBeanFactory：由 Bean 工厂统一生成对象，相当于一个模子克隆出来。\nFactoryBean：单独构造复杂对象，在 Spring 中 BeanFactory 进行实例化时，判断该对象不是单例或者不是懒加载形式，就改由 FactoryBean 来单独创建对象。\nSpring 有哪些依赖注入法？\n\n\nSet 方法注入：注入最简单，最常用的注入方式，支持注解 +xml。\n\n\n构造器注入：是指带有参数的构造函数注入，支持注解 +xml\n\n\n静态工厂的方式注入：通过调用静态工厂的方法来获取自己需要的对象，只支持 xml。\n\n\n实例工厂的方式注入：获取对象实例的方法不是静态的，所以需要 new 一个工厂类，再调用普通的实例方法，只支持 xml。有两种实现方式：(1) 注解（@Autowired,@Resource,@Required）(2) 配置文件（xml）\n\n\n❗Spring 的循环依赖是什么？\n\n\n使用 context.getBean(A.class)，旨在获取容器内的单例 A(若 A 不存在，就会走 A 这个 Bean 的创建流程)，显然初次获取 A 是不存在的，因此走 A 的创建之路~\n\n\n实例化 A（注意此处仅仅是实例化），并将它放进缓存（此时 A 已经实例化完成，已经可以被引用了）\n\n\n初始化 A：@Autowired 依赖注入 B（此时需要去容器内获取 B）\n\n\n为了完成依赖注入 B，会通过 getBean(B) 去容器内找 B。但此时 B 在容器内不存在，就走向 B 的创建之路~\n\n\n实例化 B，并将其放入缓存。（此时 B 也能够被引用了）\n\n\n初始化 B，@Autowired 依赖注入 A（此时需要去容器内获取 A）\n\n\n此处重要：初始化 B 时会调用 getBean(A) 去容器内找到 A，上面我们已经说过了此时候因为 A 已经实例化完成了并且放进了缓存里，所以这个时候去看缓存里是已经存在 A 的引用了的，所以 getBean(A) 能够正常返回\n\n\nB 初始化成功（此时已经注入 A 成功了，已成功持有 A 的引用了），return（注意此处 return 相当于是返回最上面的 getBean(B) 这句代码，回到了初始化 A 的流程中~）。\n\n\n因为 B 实例已经成功返回了，因此最终 A 也初始化成功\n\n\n到此，B 持有的已经是初始化完成的 A，A 持有的也是初始化完成的 B，完美~\n\n\n使用@Autowired 注解自动装配的过程是怎样的？\n使用@Autowired 注解来自动装配指定的 bean。在使用@Autowired 注解之前需要在 Spring 配置文件进行配置，&lt;context:annotation-config /&gt;。\n在启动 Spring IoC 时，容器自动装载了一个 AutowiredAnnotationBeanPostProcessor 后置处理器，当容器扫描到@Autowied、@Resource 或@Inject 时，就会在 IoC 容器自动查找需要的 bean，并装配给该对象的属性。在使用@Autowired 时，首先在容器中查询对应类型的 bean：\n\n\n如果查询结果刚好为一个，就将该 bean 装配给@Autowired 指定的数据；\n\n\n如果查询的结果不止一个，那么@Autowired 会根据名称来查找；\n\n\n如果上述查找的结果为空，那么会抛出异常。解决方法时，使用 required=false。\n\n\n❗Spring 的事务实现原理，对于事物传播机制的理解\n原理：@Transactional + AOP\n\n\n【常用】【默认】PROPAGATION_REQUIRED：如果当前没有事务，那就创建一个新事务，如果当前存在事务，那就加入该事务。\n\n\n【常用】PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，那就以非事务执行。\n\n\nPROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛异常。\n\n\n【场景】PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。\n\n\nPROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。\n\n\nPROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，就抛异常。\n\n\n【场景】PROPAGATION_NESTED：如果当前存在事务，就嵌套事务内执行，如果没有事务，就按 REQUIRED 属性执行。外层代码回滚，内层代码一起回滚；内层代码回滚，外层代码不一起回滚。\n\n\n说一下 Spring 的事务隔离？\nSpring 有五大隔离级别，默认值为 ISOLATION_DEFAULT（使用数据库的设置），其他四个隔离级别和数据库的隔离级别一致：\n\n\nISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；\n\n\nISOLATION_READ_UNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）；\n\n\nISOLATION_READ_COMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL server 的默认级别；\n\n\nISOLATION_REPEATABLE_READ：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；\n\n\nISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。\n\n\n\n\n脏读 ：表示一个事务能够读取另一个事务中还未提交的数据。比如，某个事务尝试插入记录 A，此时该事务还未提交，然后另一个事务尝试读取到了记录 A。\n\n\n不可重复读 ：是指在一个事务内，多次读同一数据。\n\n\n幻读 ：指同一个事务内多次查询返回的结果集不一样。比如同一个事务 A 第一次查询时候有 n 条记录，但是第二次同等条件下查询却有 n+1 条记录，这就好像产生了幻觉。发生幻读的原因也是另外一个事务新增或者删除或者修改了第一个事务结果集里面的数据，同一个记录的数据内容被修改了，所以数据行的记录就变多或者变少了。\n\n\n画一张图说 Spring 的核心架构\n// todo\n没有从源码层面讲解，这块需要后面补充。\nSpring MVC\n看了一下别的问题都是比较古老的问题。应该不会问到，暂时不记录。\n❗请描述 Spring MVC 的工作流程？描述一下 DispatcherServlet 的工作流程？\n\n\n用户发送请求至前端控制器 DispatcherServlet；\n\n\nDispatcherServlet 收到请求后，调用 HandlerMapping 处理器映射器，请求获取 Handle；\n\n\n处理器映射器根据请求 url 找到具体的处理器，生成处理器对象及处理器拦截器 (如果有则生成) 一并返回给 DispatcherServlet；\n\n\nDispatcherServlet 调用 HandlerAdapter 处理器适配器；\n\n\nHandlerAdapter 经过适配调用具体处理器 (Handler，也叫后端控制器)；\n\n\nHandler 执行完成返回 ModelAndView；\n\n\nHandlerAdapter 将 Handler 执行结果 ModelAndView 返回给 DispatcherServlet；\n\n\nDispatcherServlet 将 ModelAndView 传给 ViewResolver 视图解析器进行解析；\n\n\nViewResolver 解析后返回具体 View；\n\n\nDispatcherServlet 对 View 进行渲染视图（即将模型数据填充至视图中）\n\n\nDispatcherServlet 响应用户。\n\n\nSpring Boot\n❗SringBoot 的核心注解是哪个？它主要由哪几个注解组成？\n启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：\n\n\n@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。\n\n\n@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能： @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。\n\n\n@ComponentScan：Spring 组件扫描。\n\n\n❗SpringBoot 的工作原理/自动配置/SPI 机制是怎么样子的？\nSpringBoot 使用的@SpringApplication 注解，然后使用@EnableAutoConfiguration 以及@ComponentScan 自动装配，注解@EnableAutoConfiguration 使用了@Import 加载，使用@Import 导入的类会被 Spring 加载到 IOC 容器中，最后使用了 SpringFactoriesLoader 反射出 maven 中 META-INF 下 spring.factories，将反射的 bean 对象加载到 Spring 容器中（也就是 SpringBoot 的 SPI 机制）。\nSpring Boot 是否可以使用 XML 配置 ?\nSpring Boot 推荐使用 Java 配置而非 XML 配置，但是 Spring Boot 中也可以使用 XML 配置，通过 @ImportResource 注解可以引入一个 XML 配置。\nSpring boot 核心配置文件是什么？bootstrap.properties 和 application.properties 有何区别 ?\n单纯做 Spring Boot 开发，可能不太容易遇到 bootstrap.properties 配置文件，但是在结合 Spring Cloud 时，这个配置就会经常遇到了，特别是在需要加载一些远程配置文件的时侯。\nSpring boot 核心的两个配置文件：\n\n\nbootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，配置在应用程序上下文的引导阶段生效。一般来说我们在 Spring Cloud Config 或者 Nacos 中会用到它。且 bootstrap 里面的属性不能被覆盖；\n\n\napplication (. yml 或者 . properties)： 由 ApplicatonContext 加载，用于 spring boot 项目的自动化配置。\n\n\nSpring Boot 的配置文件分类有哪几种？它们的优先级如何？\nSpringBoot 是基于约定的，所以很多配置都有默认值，但如果想使用自己的配置替换默认配置的话，就可以使用 application.properties 或者 application.yml（application.yaml）进行配置。\n默认配置文件名称：application\n在同一级目录下优先级为：properties&gt;yml &gt; yaml\nSpring Boot 打成的 jar 和普通的 jar 有什么区别 ?\nSpring Boot 项目最终打包成的 jar 是可执行 jar ，这种 jar 可以直接通过 java -jar xxx.jar 命令来运行，这种 jar 不可以作为普通的 jar 被其他项目依赖，即使依赖了也无法使用其中的类。\nSpring Boot 的 jar 无法被其他项目依赖，主要还是他和普通 jar 的结构不同。普通的 jar 包，解压后直接就是包名，包里就是我们的代码，而 Spring Boot 打包成的可执行 jar 解压后，在 \\BOOT-INF\\classes 目录下才是我们的代码，因此无法被直接引用。如果非要引用，可以在 pom.xml 文件中增加配置，将 Spring Boot 项目打包成两个 jar ，一个可执行，一个可引用。\nSpring Boot 中如何实现定时任务 ?\n定时任务也是一个常见的需求，Spring Boot 中对于定时任务的支持主要还是来自 Spring 框架。\n在 Spring Boot 中使用定时任务主要有两种不同的方式，一个就是使用 Spring 中的 @Scheduled 注解，另一个则是使用第三方框架 Quartz（/kwɔːts/）。\n使用 Spring 中的 @Scheduled  （/'ʃedjuːld/）的方式主要通过 @Scheduled 注解来实现。\n使用 Quartz ，则按照 Quartz 的方式，定义 Job 和 Trigger 即可。\n如果是分布式定时任务，可以采用 XXL-Job。\n❗画一张图说 Spring Boot 的核心架构\nSpring Boot 本身是 Spring 项目发展到一定阶段后的产物。一开始是 Spring 框架，MyBatis，Spring MVC（SSM）做一些开发，打包部署到线上的 tomcat。tomcat 启动，接收 http 请求，转发给 Spring MVC 框架。\n开发的时候还会去整合其他的一些框架（Redis、Elasticsearch、RabbitMQ…）等东西。使用 Spring Boot 可以简化之前的开发流程，之前框架的整合流程比较繁琐。\nSpring Boot 内嵌的 web 服务器（比如 tomcat）可以直接把写好的代码运行（减少部署 tomcat）。\nSpring Boot 比较重要的一个是自动装配，引入 stater 的依赖，会一定程度上自动完成相应的配置和定义（原先需要手工配置 xml 配置文件，定义一些 bean，写 sql 文件…）。\n内链：[[SpringBoot启动流程.excalidraw]]\n外链：\n","categories":["面试","八股文"],"tags":["面试","八股文","Spring"]},{"title":"面试-反射、GC、JVM优化","url":"/posts/6f2f510a/","content":"\n\n前言\n❗表示必掌握，❔表示基本不会问\n\n\n更新\n\n\n24-06-14 初始记录 这JVM的图居然是我以前画的，一点都不记得了。24-06-16 补充JVM，部分问题没有深入，需要看新的视频。24-06-18 补充剩下的内容\n\n类加载器与反射\n简述 java 类加载机制？\n虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验，解析和初始化，最终形成可以被虚拟机直接使用的 java 类型。\n描述一下 JVM 加载 Class 文件的原理机制？\nJava 中的所有类，都需要由类加载器装载到 JVM 中才能运行。类加载器本身也是一个类，而它的工作就是把 class 文件从硬盘读取到内存中。在写程序的时候，我们几乎不需要关心类的加载，因为这些都是隐式装载的，除非我们有特殊的用法，像是反射，就需要显式的加载所需要的类。\n类装载方式，有两种 ：\n\n\n隐式装载， 程序在运行过程中当碰到通过 new 等方式生成对象时，隐式调用类装载器加载对应的类到 jvm 中\n\n\n显式装载， 通过 class.forname() 等方法，显式加载需要的类\n\n\nJava 类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类 (像是基类) 完全加载到 jvm 中，至于其他类，则在需要的时候才加载。这当然就是为了节省内存开销。\n说一下类装载的执行过程？\n类装载分为以下 5 个步骤：\n\n\n加载：根据查找路径找到相应的 class 文件然后导入；\n\n\n验证：检查加载的 class 文件的正确性；\n\n\n准备：给类中的静态变量分配内存空间；\n\n\n解析：虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用就理解为一个标示，而在直接引用直接指向内存中的地址；\n\n\n初始化：对静态变量和静态代码块执行初始化工作。\n\n\n什么是类加载器，类加载器有哪些?\n宏观来看只有两种类加载器：启动类加载器（c++ 实现）和其他所有的类加载器（java 语言）。\n主要有一下四种类加载器:\n\n\n启动类加载器 (Bootstrap ClassLoader)：用来加载 java 核心类库，无法被 java 程序直接引用。\n\n\n平台/扩展类加载器 (extensions class loader)：它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。（JDK9 之后，扩展类加载器被重命名为平台类加载器）。\n\n\n系统类加载器（system class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader() 来获取它。\n\n\n用户自定义类加载器，通过继承 java.lang.ClassLoader 类的方式实现。\n\n\n什么是反射机制？\nJAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。\n什么是静态编译，什么是动态编译？\n静态编译：在编译时确定类型，绑定对象\n动态编译：运行时确定类型，绑定对象\n反射机制的优缺点有哪些？\n优点： 运行期类型的判断，动态加载类，提高代码灵活度。\n缺点： 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，过程比直接的 java 代码要多了一步委托的过程，反射需要类加载器通过双亲委派模型实现动态编译，效率较低。\n什么是双亲委派机制？\n首先，JVM 中有三大类加载器：启动类加载器（最顶层），平台类加载器（中层），系统类加载器（下层）。\n双亲委派模型就是指一个类加载器收到了类加载请求，它不会直接自己先加载，而把请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，就再往上委托，赴到最顶层的类加载器，如果父类加载器可以完成类加载任务，就成功返回，若不能，就向下传递，让子加载器去加载，这就是双亲委派模式。\n双亲委派模型主要是用来保证同一个类只能被一个类加载器加载。\n怎么破坏双亲委派机制？\n一般在自定义类加载器中，我们不希望通过双亲委派机制一层层向上再下来，而是希望直接通过自己定义的类加载器直接实现类加载，来提升加载性能，比如 Tomcat 中的 web 容器类加载器就是破坏了双亲委托模式的，里面的 WebApplicationClassLoader 除了核心类库外，都是优先加载自己路径下的 Class。\n要打破双亲委派机制，只要在重写 loadclass 的过程中，不遵从 JVM 规范就行了，也就是不盲目优先向 Parednt 的 ClassLoader 查找即可。\n你在哪些场景下用过反射？\n反射在框架中有频繁的被使用，比如 JDK 动态代理，Spring 中的注入属性，调用方法等。\n反射更多是为了灵活舍弃一部分性能，自己使用一般用在工具类中，比如频繁通过参数名来调用指定的方法时，可以用通过反射去匹配指定的方法名，然后实现功能。\nJava 中获取反射的三种方法是什么？\n\n\n类名.class 属性\n\n\n对象名.getClass() 方法\n\n\nClass.forName(全类名) 方法\n\n\n反射可以获取私有方法或构造函数吗或私有成员变量吗？\n可以。有专门反射私有构造函数的方法 clazz.getDeclaredConstructor(int.class); 来读取私有的构造函数，私有成员变量和私有方法也一样，但用这个方法读取完还需要设置一下暴力反射才行：c.setAccessible(true)。\nJVM\n内链：[[JVM.excalidraw]]\n外链：\nJVM 包含两个子系统和两个组件，两个子系统为 Class loader(类装载)、Execution engine(执行引擎)；两个组件为 Runtime data area(运行时数据区)、Native Interface(本地接口)。\nClass loader(类装载)：根据给定的全限定名类名 (如：java.lang.Object) 来装载 class 文件到 Runtime data area 中的 method area。\nExecution engine(执行引擎)：执行 classes 中的指令。\nNative Interface(本地接口)：与 native libraries 交互，是其它编程语言交互的接口。\nRuntime data area(运行时数据区域)：这就是我们常说的 JVM 的内存。\n顺序 ：\n\n\n首先通过编译器把 Java 代码转换成字节码，类加载器（ClassLoader）再把字节码加载到内存中，将其放在运行时数据区（Runtime data area）的方法区内。\n\n\n而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令。\n\n\n再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。\n\n\n❗JVM 中有哪几块内存区域？Java 8 之后对内存分代做了什么改进？\n\n首先：一般来说：Spring boot 会内置一个 tomcat，tomcat 自己是基于 java 来开发的。我们启动的其实是 tomcat（一个 JVM 进程），我们写的代码，会被 tomcat 加载到 JVM 中。\ntomcat 去负责接收请求，执行我们写好的代码（基于 Spring 框架的一堆代码）\n\n\n\n程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，个人感觉的他就是为多线程准备的，程序计数器是每个线程独有的，所以是线程安全的。它主要用于记录每个线程的执行情况。\n\n\nJava 虚拟机栈（Java Virtual Machine Stacks）：线程私有，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。\n\n\n本地方法栈（Native Method Stack）：线程私有，与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的（Native 方法是 JVM 底层的 C 语言对其它系统或硬件进行交互）。\n\n\nJava 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；Java 堆也叫 GC 堆，是垃圾收集器管理的主要区域，堆中可以细分为：新生代、老年代；再细致一点，新生代中又分为：Eden Space(伊甸园)、Survivor 空间，Survivor 空间又分为 From 区和 to 区。\n\n\n方法区（Methed Area）：1.8 之后方法区用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。\n\n\n\n\n方法区补充点：\n\n在 JDK1.7 以前 HotSpot 虚拟机使用永久代来实现方法区，永久代的大小在启动 JVM 时可以设置一个固定值（-XX:MaxPermSize），不可变。\n在 JDK1.7 中 存储在永久代的部分数据就已经转移到 Java Heap（堆）或者 Native memory。譬如符号引用 (Symbols) 转移到了 native memory，原本存放在永久代的字符常量池移出。但永久代仍存在于 JDK 1.7 中，并没有完全移除。\nJDK1.8 中进行了较大改动：\n\n移除了永久代（PermGen），替换为元空间（Metaspace）；\n永久代中的 class metadata 转移到了 native memory（本地内存，而不是虚拟机）；\n永久代中的 interned Strings 和 class static variables 转移到了 Java heap（堆）；\n永久代参数 （PermSize MaxPermSize） -&gt; 元空间参数（MetaspaceSize MaxMetaspaceSize）\n\n\n\n\n\n永久代（元空间）\n\n在 Java8 中，永久代已经被移除，被一个称为“元数据区”（元空间，Metaspace）的区域所取代。\n值得注意的是：元空间并不在虚拟机中，而是使用本地内存（之前，永久代是在 jvm 中）。\n这样，解决了以前永久代的 OOM 问题，元数据和 class 对象存在永久代中，容易出现性能问题和内存溢出，毕竟是和老年代共享堆空间。java8 后，永久代升级为元空间独立后，也降低了老年代 GC 的复杂度。\n\n\n\n❔你知道 JVM 是如何运行起来的吗？我们的对象是如何分配的\n\n大白话：比如说我们有一个类里面包含了 main 方法，你去执行这个 main 方法，此时会启动一个 JVM 的进程。默认会有一个 main 线程，这个 main 线程就负责执行这个 main 方法的代码，进而创建各种对象。\ntomcat 也是一样的，类加载到 JVM 里面，Spring 将我们的类实例化成各种 Bean 容器。会有工作线程来执行我们 bean 实例对象里的方法和代码，进而也会创建其他的各种对象，实现业务逻辑。\n\n例子：Spring 容器中的 JVM。\n\n\n类加载器把我们写的类加载到元空间\n\n\nSpring 容器通过反射技术，获取元空间中的类，创建 bean 实例对象对象存入堆内存。\n\n\ntomcat 线程执行请求会在栈内存通过栈帧存放局部变量，引用堆内存中的实例变量\n\n\n❗JVM 在哪些情况下会触发垃圾回收\n\n在 JVM 内存里必然有一个内存的分代模型。比如说一个 4 核 8G 的机器，堆内存可能也就 4G 左右（其他例如栈内存、元空间区域存放类信息也需要空间）。\n堆内存内部再分，比如给年轻代 2GB、给老年代 2GB，默认情况下 Eden 和 s1、s2 的比例是：8:1:1。\n\n如果 Eden 满了，必然会触发垃圾回收（young GC）。回收的对象就是没有人引用的对象：方法执行过程中的局部变量引用对象、类中的静态变量引用的对象这两类对象不会被回收，其他对象基本上都可以被回收。\n什么是 Full GC？什么情况下会触发？\nFull GC 是指清理整个堆空间——包括年轻代和老年代。\n什么时候触发：\n\n\n调用 System.gc\n\n\n方法区空间不足\n\n\n老年代空间不足，包括：\n\n新创建的对象都会被分配到 Eden 区，如果该对象占用内存非常大，则直接分配到老年代区，此时老年代空间不足。\n做 minor gc 操作前，发现要移动的空间（Eden 区、From 区向 To 区复制时，To 区的内存空间不足）比老年代剩余空间要大，则触发 full gc，而不是 minor gc。\n\n\n\n❗JVM 年轻代的回收算法\n\n垃圾回收的时候有一个概念：stop the world。停止 jvm 内的工作线程的运行，然后扫描所有的对象，判断哪些可以回收，哪些不可以回收。\n年轻代内大部分都是垃圾对象。\n\n垃圾回收：复制算法。\n\n\n把年轻代内的存活对象复制到 s1，触发 young GC 把 Eden 清空。\n\n\n第二次满，把年轻代内的存活对象和 s1 内存活的对象，复制到 s2。然后把 Eden 和 s1 清空\n\n\nEden 又满，把年轻代内的存活对象和 s2 内存活的对象，复制到 s1。然后把 Eden 和 s2 清空\n\n\n❗对象什么时候会转移到老年代中\n\n\n有的对象在年轻代里熬过了很多次垃圾回收（默认是 15 次，可以设置），就会被认为是长期存活的对象，会从年轻代转移到老年代。（例如：Spring 容器内的一些 Bean 对象）\n\n\nEden 垃圾回收时，发现存活对象的大小，比 Suivivor 区还要大，就会直接放入老年代。\n\n\n很大的对象，会直接存入老年代。\n\n\n❗JVM 老年代的回收算法\n\n老年代内的对象，很多都是长期被引用的，不能用复制算法，效率比较低。\n\n老年代使用的算法是标记清除（回收）算法或者标记压缩算法。\n标记清除（回收）：\n\n\n首先会从 GC root 进行遍历，把可达对象（存过的对象）打标记\n\n\n再从 GC root 二次遍历，将没有被打上标记的对象清除掉。优点：老年代对象一般是比较稳定的，相比复制算法，不需要复制大量对象。之所以将所有对象扫描 2 次，看似比较消耗时间，其实不然，是节省了时间。举个栗子，数组 1,2,3,4,5,6。删除 2,3,4，如果每次删除一个数字，那么 5,6 要移动 3 次，如果删除 1 次，那么 5,6 只需移动 1 次。\n\n\n缺点：这种方式需要中断其他线程（STW），相比复制算法，可能产生内存碎片。\n标记压缩：和标记清除算法基本相同，不同的就是，在清除完成之后，会把存活的对象向内存的一边进行压缩，这样就可以解决内存碎片问题。\n当老年代也满了装不下的时候，就会抛出 OOM（Out of Memory）异常。\n怎么判断对象是否可以被回收？\n垃圾收集器在做垃圾回收的时候，首先需要判定的就是哪些内存是需要被回收的，哪些对象是「存活」的，是不可以被回收的；哪些对象已经「死掉」了，需要被回收。\n一般有两种方法来判断：\n\n\n引用计数器法：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；\n\n\n可达性分析算法：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。\n\n\n❗常用的垃圾回收器\n\n\nparnew+cms 的组合（jdk8 以及 8 以前）\nparnew 是新生代回收器，多线程。cms 是老年代垃圾回收（比较慢，一般比年轻代慢 10 倍以上），cms 的垃圾回收算法，刚开始用标记清理，然后整理。会产生几个阶段，尽可能并发进行\n\n\nG1(Garbage First)（从 jdk9 往后主推）回收整个堆。\n\n\n❗生产环境中的 Tomcat 如何设置 JVM 参数。如何检查 JVM 运行情况\n\nJava Web 系统，在 tomcat 的一个配置脚本，catalina 脚本里找一下。\n\n核心了解点：\n\n\n内存区域大小的分配，每个线程的栈大小，metaspace 大小，堆内存的大小，年轻代和老年代分别的大小，eden 和 survivor 区域的大小。（没有设置，会有默认值，可以通过命令行查看）\n\n\n垃圾回收器用了什么，每种垃圾回收器是否有对应的一些特殊的参数设置，那些特殊的参数分别用来干什么的。\n\n\n❗为什么要这么设置？当前系统运行的时候，jvm 的表现如何？\n// todo 额，这部分都在打广告，打算看了另一个视频再补充。\n❗实际项目中是否做过 JVM GC 优化，怎么做的？\n\n没做过，直接单机压测，然后调优。\n\n// todo\n❗发生 OOM 之后，应该如何排查和处理线上系统的 OOM 问题？\n解决的一个思路：在 JVM 里可以设置几个参数，如果一旦 JVM 发生了 OOM 之后，就会导出一份内存的快照。可以用类似 MAT 这样的工具去分析（找出当时的内存占用最大的对象是谁，找出那些对象是在哪些地方创建出来的，一般来说是对内存去做一个调优）。\n// todo 这里要结合业务去思考，结合项目（模拟）\nJava 会存在内存泄漏吗？请简单描述\n内存泄漏是指不再被使用的对象或者变量一直被占据在内存中。理论上来说，Java 是有 GC 垃圾回收机制的，也就是说，不再被使用的对象，会被 GC 自动回收掉，自动从内存中清除。\n但是，即使这样，Java 也还是存在着内存泄漏的情况，java 导致内存泄露的原因很明确：长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是 java 中内存泄露的发生场景。\n有遇到过栈溢出吗？一般是什么问题导致？\n栈溢出（StackOverflowError）是指栈内容全部被占用，而数据还要往里放。一般是递归错误或者出现死循环导致。\n","categories":["面试","八股文"],"tags":["面试","八股文"]},{"title":"面试 MySQL","url":"/posts/1f8a8b53/","content":"\n\n前言\n❗表示必掌握，❔表示基本不会问\n\n\n更新\n\n\n24-06-19 初始记录\n\n引擎\n❗MySQL 有哪些常用的存储引擎？它们的区别是什么？怎么选择？\n常见的存储引擎有：InnoDB（最常用），MyISAM（次常用），MEMORY（最次）。\nInnoDB：是最常用的存储引擎，采用 B+Tree 索引，最适用于需要增删改的表，支持事务，支持并发控制（MVCC），InnoDB 是现在 MySQL 默认的存储引擎。分库分表、读写分离、主备切换（技术方案很成熟）\nMyISAM：是 5.5 版本之前默认的存储引擎，采用 B-Tree 索引，访问速度快，但不支持事务和外键，所以只适用于查询需求的表。\n\n\n基于 MyISAM 的报表系统，hadoop 前一天把报表数据查询然后保存到 MySQL，后面只要查询。MySQL 的单表建议控制数据量在几百万，一般是 500w。后面这种报表数据量会很大，sql 也很复杂，不适合用 MySQL。\nMEMORY：基于内存存储，采用的是哈希索引，速度快，但存储量受内存大小限制，而且安全性低，一但断电，内存就会清空，一般不使用这种存储引擎。\n\n\n为什么 MyISAM 访问查询速度快？\nMyISAM 相比于 InnoDB，不需要添加隐藏值来实现 MVCC 保证高并发，也不需要事务锁，MyISAM 通过舍弃并发控制和事务保证来提升查询速度。\n此外 MyISAM 是非聚集索引，且叶节点始终是地址直接指向数据文件，而 InnoDB 可能出现回表的情况，所以相对来说，MyISAM 的访问速度比 InnoDB 快。\n❗MyISAM 的底层数据结构是什么？\nMyIsam 则是非聚集型索引，底层是 BTree 数据结构，myisam 存储会有三个文件，一个是表文件，一个是索引文件，另外一个是数据文件 ，无论是否是主键索引，索引文件最终都是以地址指向数据文件中的表数据。\n❗InnoDB 的数据结构又是什么？\n要求必须要有主键，默认内置根据主键建立一个索引，叫聚簇索引。如果对于某个非主键的字段创建索引，最后那个叶子节点的值就是主键的值。可以用主键的值到聚簇索引里根据主键值再次找到数据。\nInnoDB 的数据“类型”是 BTree，底层数据“结构”是 B+Tree，B+Tree 是 BTree 数据结构的变种，是绝对平衡树，所有叶节点在同一高度。\nB+Tree 是一个多路平衡二叉树，也就是说它不只有左右两个分支，而是可以一个节点下有很多分支。\nB+Tree 除叶子节点外，都只存储 key 值，所有的数据都存储在叶子节点上，且所有的叶子节点间都连有指针，使所有数据成为有序序列，可以用来做全表顺序描扫或范围查询。\nB+Tree 的数据检索规则为左闭合区间，这样可以实现向右添加。\n为什么使用 B+Tree 而不使用普通的 Tree？\n普通的 tree 最多只能有 2 路，而 B+Tree 则是多路数据结构，而且在数据量庞大的情况下，Tree 可能高度会很高，增加 IO 次数，降低了性能，而 B+Tree，一页大小为 16KB，单纯用来存索引的话，假设索引为 int 类型，即 4 个字节，不考虑子节点引用的情况下，每个节点可以存 2000 个关键字，即 2000 路，能够搜索的关键字个数远远的大于普通的二叉树（有只两路）。\n为什么使用 B+Tree 而不使用 B-Tree？\n数据库在查询数据时，以页的方式将磁盘数据加载到数据建库内存，默认每页数据大小是 16kb，为了提升查询效率，需要减少磁盘的 IO 次数。\nB-Tree 数据结构，每个节点中直接保存数据，这样的话 16kb 的页包含的节点数量就会比较少，所以在查询时，需要加载更多的页。\nB+Tree 数据结构，只有叶子节点包含数据，其他非叶子节点只包含索引列的值，16kb 的页能包含的节点数量就大增，相对于 B-Tree 而言，能够更少的加载页。\n为什么不用 Hash 或者红黑数？\n业务查询一般可能不是查询一条，而是查询多条。\nhash 索引查询单条确实比较快，但是他是无序的，查询多条或者排序的话性能就比较低了，并且在内存资源紧张的情况下，树索引可以分批装入内存进行计算。\n红黑树因为大数据存储下，树的高度很高，每个节点都有数，这样可能会导致多次 IO，查询效率比较低，红黑树并不适合庞大数据搜索。\n而 B+ 树可以一次性装入更多的叶子节点到内存，并且树的高度可以控制到很低，叶子节点存储数据并且形成链表可以避免跨层查询，这种“矮胖”的数据结构更适合于庞大数据搜索。\nB+Tree 叶子节点中的数据怎么有序？\n索引是表数据之外的一种数据结构，数据结构即是存储方式，也就是在表数据之外还会生成一张专门搜索而用的表，新加入的数据会找到对应子节点所在的范围，按照升序从小到大排列。\n所以 InnoDB 的批量插入效率是较低的，如果需要批量插入，就需要进行一定的数据库优化。\n怎么优化数据库来提升数据批量插入的效率呢？\n\n\n尽量保持数据有序。减少数据插入时对索引的维护成本。\n\n\n一次插入多条数据 (不宜过多)。减少日志，降低日志刷新磁盘的频率。减少 sql 解析次数。\n\n\n尽量保证主键足够小，且表上没有多余的索引。\n\n\n如果允许，考虑临时关闭二进制日志。\n\n\n确保 innodb_buffer_pool_size，innodb_log_buffer_size，max_allowed_packet 足够大。注：\n\n\n\n\ninnodb_buffer_pool_size：InnoDB 最重要的参数，缓存 innodb 表的素引、数据和插入数据的缓冲。\n\n\ninnodb_log_buffer_size：日志缓冲区，大量事务时可以将默认 3M 设为 16M。\n\n\nmax_allowed_packet：网络包大小，避免出现较大的网络包错误。\n\n\n为什么 InnoDB 能支持事务特性？\nredo log 重做日志用来保证事务的持久性：当 commit 时，必须先将事务的所有日志写到重做日志文件进行持久化，直到 commit 结束日志才算完成。\nundo log 回滚日志保证事务的原子性：事务完成前，操作并没有真正执行，而记录在日志中，undo log 会记录之前事务对应的行数据，回滚时，会根据日志进行反向操作，对中间记录的每一步操作进行逻辑删除，从而保证原子性。\nundo log + redo log 保证事务的一致性：操作过程中由 redo log 保证持久化，一但过程中出错，就由 undo log 回滚。\n锁（共享、排他）用来保证事务的隔离性：事务的隔离性的实现原理就是锁，InnoDB 主要有 2 种锁，行级锁跟意向锁。（具体见 MySQL 锁回答）\n什么是 InnoDB 回表？\n即第一次 B+tree 的叶节点上没能直接获取数据，还需要通过叶节点上的数据做为新的索引在另一张表上进行第二次 B+tree 的扫描，直到获取最终想要的数据。\n那有没有好的解决办法？\n覆盖索引（就是联合索引）。解决回表问题，只需要在一棵索引树上就能获取 SQL 所需的所有数据，无需回表，速度更快。\n覆盖索引的实现方法是，将需要查询的数据与主键共同设为索引，即联合索引，索引扫描遵循最左匹配原则，通过一次扫描 B+tree 即可查询到相应的结果，实现覆盖索引。\n所以创建索引的时候，尽可能创建“覆盖索引”，减少回表操作，提升搜索性能。\n❗什么是最左匹配原则？\n联合索引进扫 B+tree 扫描时，会以最左边的索引条件起点优先，任何连续的索引都能匹配的上。比如有一个联合索引为（name, price, address），那么它的匹配索引有三个，按照优先级分别是：name、name+price、name+price+address（注：必须是从最左开始，且连续）\n\n\n全列匹配，可以使用\n\n\n最左前缀匹配。最左边，一列、两列、三列匹配都行\n\n\n最左匹配原则，但是中间某个值没匹配。会匹配的部分走索引，然后后面的值根据过滤出来的值，再匹配。（线上常用，效果还好）\n\n\n没有最左前缀匹配。比如直接从 price 开始匹配，就不会走索引\n\n\n前缀匹配。like 操作只有 XX% 才会进行匹配\n\n\n范围列表查询。只有范围字段可以查询。\n\n\n包含函数。使用函数的字段不会用上索引。\n\n\n那是不是覆盖索引越多越好？\n不是。在 B+Tree 数据类型在保证树的平衡的过程中，每次关键字的变化，都会导致结构发生很大的变化，这个过程是特别浪费时间的，所以创建索引一定要创建合适的索引，而不是把所有的字段都创建索引，创建冗余索引只会在对数据进行新增，删除，修改时增加性能消耗。\n百万级别或以上的数据如何删除？\n索引文件是单独存在的文件，对存储表的操作都会连带到索引文件上，为了提高删除速度，可以优先删除索引（百万级约 3 分钟），然后优先删除无用数据，最后对需要保留的数据重新创建索引。这样就算需要回滚，也比全部回滚速度更快。\n事务\n❗你能说说事务的几个特性是啥？有哪几种隔离级别？\n——ACID（只有 InnoDB 才支持事务）。\n\n\n原子性（undo log 回滚保证事务的原子性）：指同一对的事务操作，要么全成功，要么全失败，操作失败不能对数据库有影响。\n\n\n一致性（undo log+redo log 保证事务一致性）：事务操作之后，数据库内的数据总量保持一致。（能量守恒）\n\n\n隔离性（锁保证事务隔离性）：相同的表，不同事务之间不能互相干扰。\n\n\n持久性（redo log 重做日志用来保证事务持久性）：事务一旦被提交，就需要在数据永久化存储，即便故障也不会丢失提交事务的操作。\n\n\n4 种。\n\n\n读未提交（RU：read uncommitted）：读到了别的事务没有提交的数据。可能存在【脏读 + 不可重复读 + 幻读】的问题。\n\n\n读已提交（RC：read committed）：可能存在【不可重复读 + 幻读】问题。\n\n\n可重复读（RR：repeatable read）：可能存在【幻读】问题。【MySQL 默认】\n\n\n串行化（serializable）：无以上问题，但效率低，一般在分布式事务的情况下用该级别。\n\n\n❗什么是脏读？幻读？不可重复读？\n脏读 (Drity Read)：是指在一个事务处理过程中读取了另一个未提交的事务中的数据 , 导致两次查询结果不一致。\n可重复读 (Non-repeatable read)：事务开启后关闭前，多次读取同一条记录，结果却不能保证一致，所以叫不可重复读。主要问题不在同一个数据库的问题，而在不同的服务器，不同数据库时会出现的问题，因为两台电脑之间要保证数据相同，是需要时间进行复制的，从表在复制主表的过程中，很可能因为修改数据过快而导致复制到错误数据。\n幻读 (Phantom Read)：select 某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入。或不存在执行 delete 删除，却发现删除成功。\n❗事务的隔离级别是怎么解决以上三种问题的？\n解决脏读：修改时加排他锁（写锁），直到事务提交后才释放，读取时加共享锁（读锁），其他事务只能读取，不能再有更新操作。防止脏读。\n解决不可重复读：innodb 引擎采用了 MVCC（多版本并发控制）来解决不可重复读问题。mvcc 是利用在每条数据后面加了隐藏的两列（创建版本号和删除版本号）。当执行查询的时，当前查询版本号&gt;= 创建版本号 并且 &gt;删除版本号，MVCC 可以在大多数情况下代替行级锁，使用 MVCC，能降低其系统开销。\n解决幻读：采用 next-key 锁解决幻读问题，next-key 锁包含两部分：记录锁（行锁）+ 间隙锁，就是在索引和索引之间上面加锁。\n❗InnoDB 是怎么做到并发控制的？MVCC\n\n事务 id，在 mysql 内部是全局唯一递增的。\n当一个事务内查询的时候，mysql 只会查询创建事务 id &lt;= 当前事务 id 的数据且当前事务 id &lt; 删除事务 id。\n\n通过多版本并发控制（MVCC）实现。\n指的是一种提高并发的技术。最早的数据库系统，只有读读之间可以并发，读写，写读，写写都要阻塞。引入多版本之后，只有写写之间相互阻塞，其他三种操作都可以并行，这样大幅度提高了 InnoDB 的并发度。\n在内部实现中，InnoDB 通过 undo log 保存每条数据的多个版本，并且能够找回数据历史版本提供给用户读，每个事务读到的数据版本可能是不一样的。在同一个事务中，用户只能看到该事务创建快照之前已经提交的修改和该事务本身做的修改。\nMVCC 在 Read Committed 和 Repeatable Read 两个隔离级别下工作。\nMySQL 的 InnoDB 存储引擎默认事务隔离级别是 RR(可重复读)，是通过 &quot; 行级锁 +MVCC&quot; 一起实现的，正常读的时候不加锁，写的时候加锁。而 MVCC 的实现依赖：隐藏字段、Read View、Undo log。\n隐藏字段是 InnoDb 存储引擎在每行数据的后面自动加上的字段，包括事务 id 字段（最重要，每次新增或修改会修改 id 号，删除的话是逻辑删除，当做更新处理，会多一个更新记录）和回滚指针字段（指向 undo log 的上一次事务对应的数据）。\nReadView 就是快照，主要是用来做可见性判断的，保证其它事务对该事务不可见，里面包括该事务的最大事务 ID，最小事务 ID 以及未提交的事务 ID 等。\nUndo log 中存储的是老版本数据，用于回滚。如当一个事务需要读取记录行时，如果当前记录行不可见，可以顺着 undo log 链找到满足其可见性条件的记录行版本。\n锁\nMySQL 数据库锁的实现原理\n在关系型数据库中，可以按照锁的粒度把数据库锁分为行级锁 (INNODB 引擎)、表级锁 (MYISAM 引擎) 和页级锁 (BDB 引擎 )。\nMyISAM 和 InnoDB 存储引擎使用的锁：\n\n\nMyISAM 采用表级锁。（一个例子：hadoop 处理数据出了问题，上午 10 点还在插入大量数据，导致锁表。页面报错 504）\n\n\nInnoDB 支持行级锁和表级锁，默认为行级锁。（innoDB 在执行增删改时会自动给行加排他锁）\n\n\n行级锁：行级锁是 MySQL 中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁（读锁） 和 排他锁（写锁）。\n共享锁和排他锁\n共享锁: 又叫做读锁。 当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。\n排他锁: 又叫做写锁。 当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。\n悲观锁和乐观锁\n数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。\n悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制。\n乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过 version 的方式来进行锁定。实现方式：乐观锁一般会使用版本号机制或 CAS 算法实现。\n两种锁的使用场景（❗线上少用悲观锁）\n从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。\n但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行 retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。\n❗如果死锁了咋办？\n死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。\n表级锁不会产生死锁，行级锁和页级锁会产生死锁。\n常见的解决死锁的方法：一般是看死锁的相关 log，然后解决出问题的 sql\n\n\n如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。\n\n\n在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；\n\n\n对于非常容易产生死锁的业务部分，可以尝试使用升级锁的颗粒度，通过表级锁定来减少死锁产生的概率；\n\n\n如果业务处理不好可以用分布式事务锁或者使用乐观锁。\n数据库优化\n优化数据库\n\n\n提升硬盘配置，换 SSD 固态硬盘，硬件直接决定了磁盘读写的快慢。\n\n\n设计索引的时候，尽量保证主键足够小。\n\n\n对数据库结构优化，索引可以适当冗余，可以减少多表联查。\n\n\n尽量保证数据的有序性，提升批量插入的性能。\n\n\n分库分表。\n\n\n模糊查询和海量数据查询使用 ES：倒排索引，近实时查询。\n\n\n数据迁移使用 XXL-Job：只保留当天数据，庞大的历史数据放到历史表。\n\n\nSQL 语句的选用：比如固定长度用 char 更快，比如用 not exist(子查询仍然可以用索引查找是否存在) 替代 not in（索引失效，因为需要遍历判断）性能更好。\n\n\n❗SQL 优化\n\n\n通过慢 SQL 日志查询\n\n\n\n\n需要手动开启慢日志开关：\n\n\n-- 查看慢日志是否开启show variables like &#x27;slow_query_log&#x27;;-- 开启MySQL慢日志查询开关set global slow_query_log = 1;-- 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志set global long_query_time = 2;\n\n\n查看慢日志记录的 sql\n\n\nshow global status like &#x27;slow_queries&#x27;; -- 查看有多少慢查询 show variables like &#x27;%slow_query%&#x27;; -- 获取慢日志目录\n\n\n使用explain命令来查看语句的执行计划，它可以显示数据库引擎对于 SQL 语句的执行的详细情况，包含是否使用索引，使用什么索引，使用的索引的相关信息等，具体的判断参数如下：\n\n\n\n\n\nid\nselect_type\ntable\ntype\npossible_keys\nkey\nkey_len\nref\nrows\nExtra\n\n\n\nid ：表示查询中各个子查询的执行顺序，id 值越大，优先级越高，越先被执行。\nSelect_type：每个子查询的查询类型。\n\n\nSIMPLE：不包含任何子查询或 union（全链接）等查询。\n\n\nPRIMARY：包含子查询的最外层查询显示为 PRIMARY。\n\n\nSUBQUERY：在 select 或 where 字句中包含的查询。\n\n\nDERIVED：from 字句中包含的查询。\n\n\nUNION：出现在 union 后的查询语句中。\n\n\nUNION RESULT：从 UNION 中获取结果集。\n\n\ntable：显示具体对应的表。\ntype（很重要）：查看有没有走索引，及访问类型。\n\n\nALL 扫描全表数据\n\n\nindex 遍历索引\n\n\nrange 索引范围查找\n\n\nindex_subquery 在子查询中使用 ref\n\n\nunique_subquery 在子查询中使用 eq_ref\n\n\nref_or_null 对 Null 进行索引的优化的 ref\n\n\nfulltext 使用全文索引\n\n\nref 使用非唯一索引查找数据\n\n\neq_ref 在 join 查询中使用 PRIMARY KEY or UNIQUE NOT NULL 索引关联。\n\n\npossible_keys ：可能使用的索引，注意不一定会使用。查询涉及到的字段上若存在索引，则该索引将被列出来。当该列为 NULL 时就要考虑当前的 SQL 是否需要优化了。\nkey ：显示 MySQL 在查询中实际使用的索引，若没有使用索引，显示为 NULL。\n\n\nTIPS：查询中若使用了覆盖索引 (覆盖索引：索引的数据覆盖了需要查询的所有数据)，则该索引仅出现在 key 列表中。\n\n\nkey_length：索引长度\nref：表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值\nrows：返回估算的结果集数目，并不是一个准确的值。\n场景题\n如果在实际工作中发现 MySQL 数据库 CPU 飙升到 500%，该怎么处理？\n\n\n先用操作系统命令 top 命令查看情况；\n\n\n如果是 mysql 造成的，就用 show processlist 语句看一下 MySQL 实例的连接情况，其中 state 列可以显示使用当前连接的 SQL 语句的状态，time 显示这个状态持续的时间，info 显示正在执行的语句；\n\n\n找到可能有问题的 SQL 语句后，再通过 explain 执行计划看看它的索引情况。\n\n\n针对具体情况做相应的优化。\n\n\n❗在一个千万级的数据库查寻中，如何提高查询效率？分别说出在数据库设计、SQL 语句、java 等层面的解决方案。(一共三个方面  数据库设计方面，Sql 语句方面，java 方面)\n\n\n数据库设计方面：\n\n对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。\n应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如： select id from t where num is null 可以在 num 上设置默认值 0，确保表中 num 列没有 null 值，然后这样查询： select id from t where num=0\n并不是所有索引对查询都有效，SQL 是根据表中数据来进行查询优化的，当索引列有大量数据重复时，查询可能不会去利用索引，如一表中有字段 sex，male、female 几乎各一半，那么即使在 sex 上建了索引也对查询效率起不了作用。\n索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过 6 个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。\n应尽可能的避免更新索引数据列，因为索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新索引数据列，那么需要考虑是否应将该索引建为索引。\n尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。 这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。\n尽可能的使用 varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。\n尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。\n避免频繁创建和删除临时表，以减少系统表资源的消耗。\n临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。\n在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log，以提高速度；如果数据量不大，为了缓和系统表的资源，应先 create table，然后 insert。\n如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。\n\n\n\nSQL 语句方面：\n\n应尽量避免在 where 子句中使用 != 或 &lt;&gt; 操作符，否则将引擎放弃使用索引而进行全表扫描。\n应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，select id from t where num=10 or num=20 可以这样查询： select id from t where num=10 union all select id from t where num=20\nin 和 not in 也要慎用，否则会导致全表扫描，如： select id from t where num in(1,2,3) 对于连续的数值，能用 between 就不要用 in 了： select id from t where num between 1 and 3\n下面的查询也将导致全表扫描： select id from t where name like ‘%abc%’\n如果在 where 子句中使用参数，也会导致全表扫描。因为 SQL 只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描： select id from t where num=@num。可以改为强制查询使用索引： select id from t with(index(索引名)) where num=@num\n应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。select id from t where num/2=100 应改为: select id from t where num=100*2\n应尽量避免在 where 子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如： select id from t where substring(name,1,3)=’abc’–name 以 abc 开头的 id select id from t where datediff(day,createdate,’2005-11-30′)=0–‘2005-11-30’ 生成的 id 应改为: select id from t where name like ‘abc%’ select id from t where createdate&gt;=’2005-11-30′ and createdate&lt;’2005-12-1′\n不要在 where 子句中的 = 左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。\n很多时候用 exists 代替 in 是一个好的选择： select num from a where num in(select num from b)。 用下面的语句替换： select num from a where exists(select 1 from b where num=a.num)\n任何地方都不要使用 select * from t ，用具体的字段列表代替 *，不要返回用不到的任何字段。\n尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过 1 万行，那么就应该考虑改写。\n尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。\n尽量避免大事务操作，提高系统并发能力。\n\n\n\njava 方面：\n\n尽可能的少造对象。\n合理摆正系统设计的位置。大量数据操作，和少量数据操作一定是分开的。大量的数据操作，肯定不是 ORM 框架搞定的。\n使用 JDBC 链接数据库操作数据\n控制好内存，让数据流起来，而不是全部读到内存再处理，而是边读取边处理；\n合理利用内存，有的数据要缓存\n\n\n\n","categories":["面试","八股文"],"tags":["面试","八股文"]},{"title":"面试 MQ","url":"/posts/a872196e/","content":"\n\n前言\n❗表示必掌握，❔表示基本不会问\n\n\n更新\n\n\n24-08-22 初始记录\n\n你知道目前市面上使用的 MQ 有哪些吗？\nRabbitMQ、RocketMQ、Kafka。\n你使用的是哪种 MQ？为什么选择这类 MQ(qps)？\n我们选用的是 RabbitMQ，它并发能力强，性能好，延时低，管理界面也很丰富，只是吞吐量较低，但对于不是特别依赖大数据的项目来说，选用 RabbitMQ 已经足够用了。\nRocketMQ 是阿里开源项目，吞吐量是最高的（10 万次级），但免费版的 MQ 是阉割版的，容易出问题。\nKafka 吞吐量很大（10 万次级），但它不是真正的 MQ，只是类似 MQ 的产品，它只支持主要 MQ 功能，比如它不具有消息确认机制。\n什么是 RabbitMQ？\nRabbitMQ 是一款开源的，Erlang 编写的，基于 AMQP 协议的消息中间件。\n什么是 AMQP 协议？\nAMQP 一个提供统一消息服务的应用层标准高级消息队列的链接协议，RabbitMQ 是主要根据 AMQP 协议进行数据通信和传输的。有点类似于 HTTP 协议。\nAMPQ 与 JMS 有什么区别知道吗？\nJMS 是定义了统一的接口（API），来对消息操作进行统一；AMQP 是通过规定协议来统一数据交互的格式。\nJMS 限定了必须使用 Java 语言；AMQP 只是协议，不规定实现方式，因此是跨语言的。\nJMS 规定了两种消息模式；而 AMQP 的消息模式更加丰富。\n你使用的是 SpringCloud，Feign 可以进行远程调用，为什么还要中间加一个 MQ 呢？\n为了解耦，如果没有中间件进行处理，那两个系统之间的关系过于紧密，一方改动，另一方也必须改动。\nMQ 有哪些优势？\n\n\n应用解耦（核心）：降低系统的耦合性，提升可维护性。\n场景：服务调用之间都可以考虑 MQ。\n\n\n异步提速：提升用户体验和系统吞吐量。\n场景：发送订单消息、发送短信消息等。\n\n\n削峰填谷：减少高峰时期对服务器的压力。\n场景：秒杀活动、限时定购等。\n\n\nRabbitMQ 有什么缺点？\n\n\n系统可用性降低\n本来系统运行好好的，现在你非要加入个消息队列进去，那消息队列挂了，你的系统不是呵呵了。因此，系统可用性会降低。\n\n\n系统复杂度提高\n加入了消息队列，要多考虑很多方面的问题，比如：一致性问题、如何保证消息不被重复消费、如何保证消息可靠性传输等。因此，需要考虑的东西更多，复杂性增大。\n\n\n一致性问题\nA 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致了。\n\n\n消息顺序问题\n如果有 A、B 两个消息，B 消息被消费者消费的前提是 A 消息已被执行，这时候就不能先执行 B，得先执行 A 才行。\n\n\n那怎么解决以上缺点呢？\n\n\n系统可用性降低：集群模式保证高可用。\n镜像集群模式：这种模式，才是所谓的 RabbitMQ 的高可用模式。跟普通集群模式不一样的是，在镜像集群模式下，你创建的 queue，无论元数据还是 queue 里的消息都会存在于多个实例上，就是说，每个 RabbitMQ 节点都有这个 queue 的一个完整镜像，包含 queue 的全部数据的意思。然后每次你写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上。RabbitMQ 有很好的管理控制台，就是在后台新增一个策略，这个策略是镜像集群模式的策略，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。这样的话，好处在于，你任何一个机器宕机了，没事儿，其它机器（节点）还包含了这个 queue 的完整数据，别的 consumer 都可以到其它节点上去消费数据。坏处在于，第一，这个性能开销也太大了吧，消息需要同步到所有机器上，导致网络带宽压力和消耗很重！RabbitMQ 一个 queue 的数据都是放在一个节点里的，镜像集群下，也是每个节点都放这个 queue 的完整数据。\n\n\n系统复杂度提高\n加入 Rabbit 确实会增加系统复杂度，但 MQ 的解耦、提速、削峰这些方面的收益超过管理 MQ 的成本，所以该用还得用。\n\n\n一致性问题\nRabbitMQ 分布式消息是最终一致性的，即使可能因为消息失败而导致前后消息不一致，但分布式系统是在不同服务器上的，不能像简单的本地回滚一样，所以它通过发送延迟消息和定时消息来进行消息补偿，保证最终消息是一致性的，即是一个完整的事务。\nRabbitMQ 本身是有事务的功能的，但是分布式的事务处理效率太低，且发生问题的可能性不高，所以多是选择放弃强一致性，而采用最终一致性。\n\n\n消息顺序问题\n在 MQ 中将有顺序要求的 AB 两个消息分别用两个队列与两个消费端手工 ack 接收，并且在消息上需要有对应的同组编号信息，以及发送次数，如果 B 执行的前提是已经消费了 A，那需要在消费端判断 A 消息是否已经正确接收（也就是查询成功的消息库）。如果 A 已经消费成功，则消费 B，如果 A 消费失败，或者 A 还没有消费，则 B 消息也直接返回为消息失败，并且不重回队列。并且让消息提供方重新发送 AB 消息，如果连续三次发送消息仍然消费失败，则 AB 两个消息第四次处理时就扔入死信队列中，等待人工处理。\n\n\nRabbitMQ 事务是怎么实现的？\n事务的实现主要是对信道（Channel）的设置，主要的方法有三个：\n\n\nchannel.txSelect() 声明启动事务模式；\n\n\nchannel.txComment() 提交事务；\n\n\nchannel.txRollback() 回滚事务；\n\n\nRabbitMQ 的实现原理是怎么样子的？\n首先，消息提供方会和 RabbitMQ 之间建立起 TCP 连接（Connection），每个连接中会有多个通信的信道（channel）来提连通信效率，不同的信道之间通过信道 id 来实现信息隔离。\n而在 RabbitMQ 中，消息提供者发出的消息会先到 RabbitMQ 中的交换机中，由交换机根据分发规则，通过队列的形式分发消息。\n消息接收方与 RabbitMQ 之间也一样是通过 TCP 连接和信道建立连接和通信。\n此外，在 RabbitMQ 中，交换机与队列之间不同的边接方式，也产生了不同的工作模式。\nRabbitMQ 有哪些工作模式？\n\n\n简单模式：就是不通过交换机，消息直接通过队列，一对一收发。\n\n\n工作队列模式：也是不通过交换机，消息直接通过队列，只是一个发送方可以有多个接收端。\n\n\n发布订阅模式：由交换机分发消息到不同队列，每个消费者只监听自己的队列。\n\n\n路由模式：由交换机分发消息，但是发送方需要指定路由 key，交换机会根据不同的 routing key 分发给不同的队列，消费方对应自己需要的队列。\n\n\n通配符模式：和路由模式有些相近，只是通配符模式可以在绑定 routing key 时使用通配符。\n\n\nRPC 模式：RPC 远程调用模式，严格来说不太算是 MQ。\n\n\n为什么 RPC 严格来说不能算是 MQ？\nRPC，远程过程调用，实际上是一种技术思想，而一种规范或协议，一般来说 RPC 远程调用是同步通信的，且 RPC 模式是没有队列的，多用在立即等待返回处理结果的场景，比如使用基于 RPC 思想的 Dubbo。而 MQ 是用来异步提速的，所以严格来说，RPC 模式不能算是 MQ。\n消息怎么路由？\n\n\n消息提供方 -&gt;路由 -&gt;一至多个队列消息发布到交换器时，消息将拥有一个路由键（routing key），在消息创建时设定。通过队列路由键，可以把队列绑定到交换器上。消息到达交换器后，RabbitMQ 会将消息的路由键与队列的路由键进行匹配（针对不同的交换器有不同的路由规则）；\n\n\n常用的交换器主要分为一下三种：\n\nfanout：如果交换器收到消息，将会广播到所有绑定的队列上。\ndirect：如果路由键完全匹配，消息就被投递到相应的队列。\ntopic：可以使来自不同源头的消息能够到达同一个队列。 使用 topic 交换器时，可以使用通配符。\n\n\n\n消息基于什么传输？\n由于 TCP 连接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈。RabbitMQ 使用信道的方式来传输数据。信道是建立在真实的 TCP 连接内的虚拟连接，且每条 TCP 连接上的信道数量没有限制。\nRabbitMQ 中的交换机可以储存消息吗？\n不可以。交换机只负责转发消息，不具备存储消息的能力。\n如何防止消息丢失呢？\n\n\n在生产者丢失——confirm 确认模式\n\n使用 RabbitMQ 事务机制，但它是同步的，且很耗性能。\n开启 confirm 确认模式，确认消息是否从“生产者”发送到“交换机”，成功回传 ack 消息，失败可以重试或抛异常。且 confirm 模式是异步回调接口通知 MQ 是否接收到消息。一般都采用这种方式。\n\n\n\n在 MQ 中丢失——持久化\n\n开启 RabbitMQ 持久化，防止 RabbitMQ 自己弄丢数据。除非极小概率还没来得及持久化，MQ 就先挂了，即使这样，也只会丢失极少的数据量。\n所以，持久化可以跟生产者那边的 confirm 机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者 ack 了，所以哪怕是在持久化到磁盘之前，RabbitMQ 挂了，数据丢了，生产者收不到 ack，你也是可以自己重发的。\n但持久化的过程也是很耗性能的。\n\n\n\n在消费者丢失——ack 机制\n\n用 RabbitMQ 提供的 ack 机制，简单来说，就是你必须关闭 RabbitMQ 的自动 ack，可以通过一个 api 来调用就行，然后每次你自己代码里确保处理完的时候，再在程序里 ack 一把。这样的话，如果你还没处理完，不就没有 ack 了？那 RabbitMQ 就认为你还没处理完，这个时候 RabbitMQ 会把这个消费分配给别的 consumer 去处理，消息是不会丢的。以上三种方式，只是防止丢失，但具体补消息，还需要靠消息的补偿机制（也就是消息的可靠性保证）。\n\n\n\n❗RabbitMQ 如何保证消息的可靠性呢？\n消息补偿。（延迟消息 + 定时扫描）\n\n\n由生产者发送消息给 MQ，MQ 会将消息给到消费者，消息者收到消息后，会返回一个消息确认，这个“消息确认”会被 MQ 放到“回调检查服务”中，“回调检查服务”会将收到的消息给到定时检查的 MDB。\n\n\n但在这个过程中，如果出现异常或者网络波动，就会导致消息到不了回调检查服务，所以为了保证能够消息可靠性，会由生产者延迟一段时间后，再发送一个相同的消息给 MQ，这个消息会直接被 MQ 发送到回调检查服务。\n\n\n回调检查服务会将延迟发送的消息和 MDB 中的消息对比，如果 MDB 中没有该消息，就会调用生产者，让生产者重新发送消息。\n\n\n但在以上过程，还可能出现“延迟发送消息”也出问题，为了更深层保证消息的可靠性，还需要一个定时检查服务，每隔一段固定时间，定时检查服务会将 MDB 里的消息和 DB 中的消息进行匹配（检查某个时间段的表，而不是全表扫描），如果有 MDB 缺失的消息，就会调用生产者重新发送消息。\n\n\n什么是 TTL？什么是死信队列，消息成为死信有哪几种情况？什么是延迟队列？\n\n\nTTL：全称 Time To Live（存活时间/过期时间）\n\n如果给消息设置过期时间，即使到了过期时间，消息也不会立马被清除，只有等消息到了队列的头上，才会被判断是否过期清除。\n如果给整个队列设置过期时间，即每一个进入队列的消息，都会各自被设置为了相同的过期时间。而非整个队列定时隔一段时间清除。\n如果单独消息和整个队列两则都设置了过期时间，以时间短的为准。\n\n\n\n死信队列：英文缩写：DLX  。Dead Letter Exchange（死信交换机）\n\n消息成为死信的三种情况：\n\n队列消息长度到达限制；\n消费者拒接消费消息，basicNack/basicReject,并且不把消息重新放入原目标队列，requeue=false；\n原队列存在消息过期设置，消息到达超时时间未被消费；\n\n\n\n\n\n延迟队列：即消息进入队列后不会立即被消费，只有到到达指定时间后，才会被消费。\n\nRabbitMQ 中并未提供延迟队列功能，采用【TTL】+【死信队列】 组合实现延迟队列的效果。\n\n\n\n有几百万消息持续积压几小时，说说怎么解决？\n消息积压处理办法：临时紧急扩容：\n先修复 consumer 的问题，确保其恢复消费速度，然后将现有 consumer 都停掉。\n临时建立好原先 10 倍的 queue 数量。\n然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue。\n接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。\n等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息。\n消息队列满了以后该怎么处理\n没办法了，说明紧急扩容也来不及了，只能“丢弃 + 批量重导”了，写程序快速消费，然后重导。\nRabbitMQ 如何保证消息的不重复消费呢？【重要】\n一条数据重复出现两次，数据库里就只有一条数据，这就是保证了系统的幂等性。\n保障了消息的幂等性，同一条消息被重复消费也就不影响了，因为不影响最终执行结果。\n\n\n方法一：采用乐观锁机制保证消息幂等性。在数据库中会增加一个版本字段，执行时也会匹配版本，如果版本不一致，SQL 语句的匹配就不成立，就不会执行。\n\n\n方法二：你拿到这个消息做数据库的 insert 操作，那就容易了，给这个消息做一个唯一的主键，那么就算出现重复消费的情况，就会导致主键冲突，避免数据库出现脏数据。\n\n\n方法三：你拿到这个消息做 redis 的 set 的操作，那就容易了，不用解决，因为你无论 set 几次结果都是一样的，set 操作本来就算幂等操作。\n\n\n方法四：如果上面两种情况还不行，上大招。准备一个第三方介质，来做消费记录。以 redis 为例，给消息分配一个全局 id，只要消费过该消息，将 &lt;id,message&gt; 以 K-V 形式写入 redis。那消费者开始消费前，先去 redis 中查询有没有消费记录即可，先根据这个 id 去比如 redis 里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个 id 写 redis。如果消费过了，那你就别处理了，保证别重复处理相同的消息即可。\n\n\n如何解决消息队列的延时以及过期失效问题？\n假设你用的是 RabbitMQ，RabbtiMQ 是可以设置过期时间的，也就是 TTL。如果消息在 queue 中积压超过一定的时间就会被 RabbitMQ 给清理掉，这个数据就没了。这就不是说数据会大量积压在 mq 里，而是大量的数据会直接搞丢。\n我们可以采取一个方案，就是批量重导，这个我们之前线上也有类似的场景干过。就是大量积压的时候，我们当时就直接丢弃数据了，然后等过了高峰期以后，比如大家一起喝咖啡熬夜到晚上 12 点以后，用户都睡觉了。这个时候我们就开始写程序，将丢失的那批数据（发送的数据库和确认接收的数据库匹配），写个临时程序，一点一点的查出来，然后重新灌入 mq 里面去，把白天丢的数据给他补回来。也只能是这样了。\n假设 1 万个订单积压在 mq 里面，没有处理，其中 1000 个订单都丢了，你只能手动写程序把那 1000 个订单给查出来，手动发到 mq 里去再补一次。\n如果要你自己设计一个 MQ，你会怎么设计？\n\n\n重启起一个服务器来（使用 Redis）充当 RabbitMQ，实现 MQ 的解耦功能。\n\n\n这个服务器需要可以存储和转发消息，存储是为了实现永久化，防止服务器出问题，消息丢失；转发消息则是可以通过不同队列来实现指定消费端，实现异步提速功能和削峰填谷的功能。\n\n\n建立消息补尝机制，防止消息丢失。\n\n\n怎么使用 Redis 实现 MQ 功能呢？\n\n\n使用 list 类型保存数据信息，rpush 生产消息，lpop 消费消息，当 lpop 没有消息时，可以 sleep 一段时间，然后再检查有没有信息，如果不想 sleep 的话，可以使用 blpop, 在没有信息的时候，会一直阻塞，直到信息的到来。redis 可以通过 pub/sub 主题订阅模式实现一个生产者，多个消费者，当然也存在一定的缺点，当消费者下线时，生产的消息会丢失。\n\n\n使用 sortedset，使用时间戳做 score, 消息内容作为 key，调用 zadd 来生产消息，消费者使用 zrangbyscore 获取 n 秒之前的数据做轮询处理。\n\n\n","categories":["面试","八股文"],"tags":["面试","八股文"]},{"title":"【面试记录】一年半 Java","url":"/posts/a862a019/","content":"\n\n前言还是裸辞了，大概休息了 3 个月，现在继续准备面试。很多八股文都忘记了。合并了之前华为 OD 的刷题记录，算是第一次跳槽的面试记录总结。一共面了三家，过了两个，推了外包。闲鱼上咨询了一下，意思是让我继续面，但是不想面了，而且这边offer已经接了，暂时就先这样吧。\n\n\n更新\n\n\n24.03.28 华为 OD 刷题记录24.08.21 合肥英泽信息科技（外包中华保险）面试记录24.08.22 中吾科技、网新恒天（外派道富）面试记录24.09.05 网新恒天（外派道富）二面记录及总结\n\n华为 OD\n刷题记录\n为块术（不是），其实一直觉得二本毕业去这边也蛮好的，但是一直没有动力刷题。今天去面试，啥也没准备，就看了一天早已忘记的八股文，果然挂了。但是 Boss 上收到华为 OD 的 Hr 的消息（好像是最近突然加了岗位？），总之约了两周后机考（怎么敢的，真的一点都没准备过）\n240328\n\n\nHJ1 字符串最后一个单词的长度\n\n\n思路居然是遍历，遇0清空计数，真的没想到。显得我的方法很笨。\n\n\nHJ2 计算某字符出现次数\n\n\nHJ3 明明的随机数\n\n\n语法糖就语法糖吧，我放弃了\n\n\nHJ4 字符串分隔\n\n\nHJ5 进制转换\n\n\n240330\n\n\nHJ6 质数因子\n\n\n240402\n\n\nHJ7 取近似值\n\n\n用了API\n\n\nHJ8 取近似值\n\n\nHJ9 提取不重复的整数\n\n\nHJ10 字符个数统计\n\n\nHJ11 数字颠倒\n\n\n240404（牛客华为机试题库）\n\n\nHJ12 字符串反转\n\n\nHJ13 句子逆序\n\n\n// 忘了这个APIString.join(&quot; &quot;, strings)\n\n\nHJ14 字符串排序\n\n\nHJ15 求 int 型正整数在内存中存储时 1 的个数\n\n\n华为 OD 机试真题 - 寻找身高相近的小朋友（C 卷）\n\n\n240406（华为 OD 机试 2024 年最新题库 -C 卷）\n\n\n华为 OD 机试真题 - 围棋的气（C 卷）\n\n\n华为 OD 机试真题 - 用连续自然数之和来表达整数（C 卷）\n\n\n本题用滑动窗口进行求解。之前都不会这个。标记一下需要二刷。\n\n\n华为 OD 机试真题 - 开源项目热榜（C 卷）\n\n\n华为 OD 机试真题 -API 集群负载统计（C 卷）\n\n\n华为 OD 机试真题 - 整数对最小和（C 卷）\n\n\n华为 OD 机试真题 - 素数之积（C 卷）\n\n\n华为 OD 机试真题 -CPU 算力分配（C 卷）\n\n\n华为 OD 机试真题 - 最大坐标值（C 卷）\n\n\n华为 OD 机试真题 - 寻找最富裕的小家庭（C 卷）\n\n\n240407（华为 OD 机试 2024 年最新题库 -C 卷）\n\n\n华为 OD 机试真题 - 分月饼（C 卷）\n\n\n不会，没有思路，先跳过。\n240408（华为 OD 机试 2024 年最新题库 -C 卷）\n\n\n华为 OD 机试真题 - 找城市（C 卷）\n\n\n没有思路，200分题打算周末再刷了，先看看有没有类似的题解。\n\n\n华为 OD 机试真题 - 查找接口成功率最优时间段（C 卷）\n\n\n严重超时，不知道是不是因为一边上班一边做的原因思路都是乱的\n240409（华为 OD 机试 2024 年最新题库 -C 卷）\n\n\n华为 OD 机试真题 - 分割均衡字符串（C 卷）\n\n\n华为 OD 机试真题 - 虚拟游戏理财（C 卷）\n\n\n华为 OD 机试真题 - 靠谱的车（C 卷）\n\n\n华为 OD 机试真题 - 执行时长（C 卷）\n\n\n华为 OD 机试真题 - 万能字符单词拼写（C 卷）\n\n\n240410（华为 OD 机试 2024 年最新题库 -C 卷）\n\n\n华为 OD 机试真题 - 来自异国的客人（C 卷）\n\n\n华为 OD 机试真题 - 求最多可以派出多少支团队（C 卷）\n\n\n华为 OD 机试真题 - 最长子字符串的长度（C 卷）\n\n\n华为 OD 机试真题 - 机场航班调度程序（C 卷）\n\n\n华为 OD 机试真题 - 数的分解（C 卷）\n\n\n240411（华为 OD 机试 2024 年最新题库 -C 卷）\n\n\n华为 OD 机试真题 - 智能成绩表（C 卷）\n\n\n华为 OD 机试真题 - 提取字符串中的最长数学表达式并计算（C 卷）\n\n\n不希望考到这题。怎么还有正则正则实在不太熟，这题硬记((+-)?(\\\\d+[+-*])*\\\\d)判断出最长正则式子之后的思路为：1、记录初始加减号2、如果是+，记录数乘1；如果是-，记录数乘-1；如果是乘，获取前一个数并乘并记录乘积\n机试（240417）\n没过。。。293 但是要 300 分。算了。本来也没报多大希望。\n还是多刷点题再投简历。现阶段，辞不辞职都无所谓了（最好明天就把我裁了！！！大晚上 10 点群里@人是不是有病啊，又不是 bug？？？？谁 tm 理你？？？！！！）\n1 年多的 Java 现在真的狗都嫌，打算实在没有去处，6 个月之后再考一次，反正本次刷题感觉还行，不是特别难。\n后续\n打算先刷点算法 + 八股了。实在不行啃点存款，反正还没辞职。。。\n合肥英泽信息科技（外包中华保险）\n\n没意外应该一面挂了。\n\n一面\n面试官人很好，但是基本上问的都是关于项目的场景题，这次关于项目的题目一点都没有准备，感觉在乱答（那种分不清问题重点的乱答）。八股文只问了线程池的运行过程，会，但是马上就问后序的使用，基本上没有用过的技术我都说没有（包括线程池，微服务的治理等。实在不行这块写代码跑通了编一下看看）。\n面试题和回答点\n\n\n先问线程池运行顺序，背出来了。然后问线程池在项目中的使用。\n在想定这个项目中，用 AOP 切面进行了日志的记录，在日志记录的时候用到了线程池。使用的是常用的线程池中的ScheduledThreadPoolExecutor（定时/延时执行任务）。好处是可以将日志记录操作放入单独的线程中执行，从而释放主线程的资源，使其能够更快地处理其他任务。反正就围绕这个把线程池八股文都说一遍，包括核心线程数啥的。\n\n\n讲一下微服务体系。\n说了注册中心 Nacos，网关 Gateway，远程调用 Feign，微服务治理（服务限流 Sentinal、分布式事务 Seata）\n\n\n然后问项目中是否用了分布式事务 Seata。\n没有。不知道是不是也要去研究一下\n\n\n问为什么要进行微服务拆分。\n首先这是个工厂项目，没有高并发。（这里需要按点回答！！！！）\n\n模块化。通过拆分成微服务，每个服务都可以独立开发、部署和扩展，有助于团队聚焦于特定的业务功能或领域。\n灵活性和弹性。服务可以独立扩展，只针对需要更多资源的特定服务进行扩展，而不必扩展整个应用，这样可以更有效地利用资源。\n故障隔离：如果一个服务失败，其他服务仍然可以继续运行，这有助于提高系统的整体稳定性。\n边界清晰：微服务之间的边界清晰，有助于明确接口定义和服务职责。\n可重用性：微服务可以独立部署和运行，易于被其他服务或应用重用。（说一下注册和认证还有 activiti 这块调出来使用了）\n\n\n\nNacoa 作为注册中心，怎么考虑高可用的问题。\n用集群（这段建议背一下 Nacos 集群的相关问题），只能回答说，目前用的是单体启动，然后运维也是我负责，所以出问题也是我解决。。。\n\n\n关于微服务远程调用造成的数据不一致问题，Feign 调用失败数据不一致？\n回答说没有遇到过，服务调用失败就是配置了一个 FallbackFactory。应该还是要问分布式事务管理的问题，太难了实在不会。\n\n\nGateway 的作用。（前三个是答出来的、后面的真的没有用到过。后续面试时看情况吧）\n\n请求路由：API 网关作为系统的单一入口点，负责将外部请求路由到正确的微服务实例上。它可以基于 URL 路径、请求参数、报头等信息进行路由决策。\n跨域处理：API 网关可以处理跨域资源共享（CORS）问题，使得前端应用程序能够安全地与后端微服务进行通信。\n认证与授权：API 网关负责对请求进行认证和授权，确保只有合法的请求能够访问后端的微服务。\n协议转换：不同微服务可能使用不同的通信协议，API 网关可以将外部使用的协议（如 HTTP/HTTPS）转换为内部服务使用的协议（如 Thrift、gRPC 等）。\n聚合服务：当一个请求需要多个微服务协作才能完成时，API 网关可以聚合多个服务的结果，减少客户端与多个微服务的直接通信。\n限流与熔断：为了保护后端服务，API 网关可以实现限流（限制请求的频率）和熔断（在服务不可用时防止系统雪崩）。\n监控与日志：API 网关可以记录所有进入系统的请求，并监控这些请求的处理时间和状态，这对于故障排查和性能分析非常有用。\n缓存：对于某些不经常变更的数据，API 网关可以实现缓存机制，减少对后端服务的调用，提高响应速度。\n静态资源服务：API 网关可以用来服务静态资源，如 HTML、CSS、JavaScript 文件等。\n\n\n\n既然说到了跨域，说一下跨域的原因。（😭忘记准备了，这个应该是必须要会的，需要总结）\n\n\n\n内链：[[跨域产生的原因及解决方案]]\n外链：跨域产生的原因及解决方案\n\n\n\n说一下 Gateway 怎么解决跨域问题（这个直接背一下，说出来了，但是还是要问原因）\n\n\nspring:  cloud:\tgateway:  \t  globalcors:  \t    cors-configurations:  \t      &#x27;[/**]&#x27;: # 匹配所有请求  \t        allowedHeaders: &quot;*&quot;  \t        allowedOrigins: &quot;*&quot; #跨域处理 允许所有的域  \t        allowedMethods: # 支持的方法  \t          - GET  \t          - POST  \t          - PUT  \t          - DELETE  \t          - OPTIONS\n\n\nGateway 认证，用了什么（考虑要不要加上一些复杂的框架知识）\n说了 JWT。继续问 token 能不能被伪造。（这里要背之前的回答❗❗❗太久了有点忘记了）\n\n\n想定远程调用的图生图，是什么。\n这个没什么好说的，就说是别人部署的。\n\n\n问了这个项目主要负责哪一块。关于商城的上架支付等一系列功能是不是都实现了。\n额我说都是我负责的，其实下一步应该要问具体的业务逻辑讲一下。我说是的，然后包括 H5，Android ，后台，但是都是前端打包。（好像能讲的比较少，只有支付的 MQ 可以讲一下，但是一开始就问了这个。问题是 RabbitMQ 在哪个部分用到，就说了这边支付延时的问题）\n\n\nRabbitMQ 继续问还有哪里可以用到\n回答了异步，随便举了一个支付成功发邮件的例子。\n\n\n继续问发失败了怎么办（这里要问的是 ACK，但是忘记准备 MQ 相关的八股文了❗❗❗）\n一直在引入 ACK 的机制，但是真的想不起来了。就说了一个设置消息重发的配置。\n\n\n看到项目用了 Flowable，问为什么使用，是流程比较复杂吗。\n不是复杂，是需要流程可视化配置\n\n\n后序问开发中感觉比较难的部分。（不知道要不要说这个难点，还是换一个难点）\n说了流程这块（好像没有什么可以说了）。一开始是网上搜索用能直接生成 xml 文件的代码，把这个流程部署到我们的服务上（但是需求是能快速部署流程使用）。一开始用的开源项目的流动过程的配置比较难（因为这里当时还要配置结束的监听器之类的操作，可能直接给不会开发的人使用比较困难），后面搜到一个开源项目，就引入我们系统（下次就说参考开源项目，写的流程自动化配置😖）。然后统一在结束节点的地方加了一个监听器，根据不同的流程，调用微服务控制业务表的操作（这里以后问可以说一下用策略模式优化了服务间的调用，嗯但是可能有问题就是调用失败了怎么办，不然说写到 MQ 了？）\n\n\n问了这种问题为什么没有老员工带什么的。\n额我说后面开发就我一个了，所以我自己解决的。已经有点破防了。\n\n\n问学了什么新技术（因为简历里乱写热爱技术，学习新技术。。。）\n说了 copilot，我也不知道说什么了。反正就说了 GPT 那一套，还说了自己在写博客（真的内心已经在喊救命了）\n\n\n问获取和交流代码的途径\n神经我说开源项目的群（不知道我在说什么，胡言乱语）、博客\n\n\n反问\n感觉没戏就简单问了一下有几轮面试。\n\n\n总结\n没有根据简历准备面试（大忌❗❗❗）\n总结的时候发现问的好难啊，基本上要问的就是分布式事务和多线程（线程池），多线程可以去准备一下（顺便这块的八股文也背的还行）。没有什么八股文，除了第一个，难道是因为第一个我背的太明显了吗。\n中吾科技\n\n听说团队缩减了一半，然后重新招人，十几份里选一两个。等通知。。。两天面试都提到了分布式锁相关的内容，这个需要好好研究一下❗❗❗没有及时记录，有点混乱了。\n后来搜到了公司的官网，但是没有注册入口❔。\n\n一面（就一面）\n面试题和回答点\n\n\n关于项目问了很多（之前的团队，开发人数，微服务整合等等）\n实话实说我一个人干的。\n\n\n仓库部分的表设计，关于怎么锁库存的\n我说我分表了，简单的说了一下，但是应该不是他想要的答案，网上搜了一下分布式锁库存的问题（准备好了这个，后面面试重难点可以说这个❗❗❗）。\n这块如果是单体架构可以参考之前的开源项目可以设计一个出入库事务表，然后所有的出入库表关联这个出入库事务表，但是是分布式就不行 // todo 关于这块详细设置。\n\n\n乐观锁： 乐观锁是一种在数据操作时不使用传统锁机制，而是在数据提交时检查数据冲突的策略。在乐观锁中，当一个操作尝试更新库存时，它假设其他操作不会修改同一数据。如果在提交时发现冲突，通常会回滚操作并通知用户。\n\n\n悲观锁： 悲观锁是一种在数据操作时立即获取锁的策略。当一个操作尝试更新库存时，它会立即获取一个独占锁，阻止其他操作在同一时间内修改同一数据。当操作完成后，锁会被释放，其他操作可以继续执行。\n\n\n分布式锁： 在分布式系统中，由于数据可能分布在多个节点上，因此需要使用分布式锁来保证对共享资源的互斥访问。常见的分布式锁实现包括 ZooKeeper、Redis 等。\n\n\n事务管理： 使用数据库的事务管理功能来保证库存操作的原子性。在一个事务中，所有对库存的修改要么全部成功，要么全部失败，确保库存的一致性。\n\n\n库存锁定机制： 某些仓库管理系统可能会实现自己的库存锁定机制，比如在提交库存更新请求时，系统会检查当前库存是否可以满足请求，如果可以，则锁定库存，执行操作，最后解锁库存。\n\n\n库存预留机制： 在某些情况下，可能需要提前预留库存以支持订单处理。这通常涉及到一个额外的库存状态，如“预留”或“预留中”，在实际出库前，库存状态保持为“预留中”，从而实现对库存的锁定。\n\n\n消息队列： 在某些情况下，可以通过消息队列来实现库存的锁机制。例如，当一个操作需要更新库存时，它首先向消息队列发送一个消息，然后等待响应。如果响应表明库存可以更新，则执行操作；如果响应表明库存不可更新，则放弃操作。\n\n\n\n\n然后是问一点关于技术的问题，关于 Java 中的集合\n八股文关于集合全背。说到 HashMap 底层问了要不要继续。\n\n\n嗯然后说可以说下多线程的问题，比如 HashTable 和 ConcurrentHashMap。\nHashTable 底层就是加锁，很少用；ConcurrentHashMap 全背。然后提了一下 ArrayList 也是线程不安全的，可以用 Collections.synchronizedList()，但是遍历的时候还是要加锁，因为只有 add，remove 等方法加了锁。\n\n\n问 List 遍历能不能 remove\n说不行，会 Fail-fast（下次加上迭代器是可以的）\n\n\n问 Redis 的问题，分布式多线程问题。\n应该是要问这个，但是我直接整到多线程，线程池那里去了😥。（然后问不是在问 Redis，咋整到那里去了😗）。我说 Redis 我只是简单的使用，存短信验证码用到了。\n\n\n然后问多线程，核心线程参数\n（可能被我带跑偏了）说了面试前刚刚准备的那个线程池（日志记录的那个），包括这块的八股，多扯一点，加上线程池的执行顺序、拒绝策略什么的。\n\n\nMQ 的消息保证\n不会这个。和之前回答一样重试机制，但是继续问队列满了怎么办。需要加强背。MQ 的相关八股忘记准备了，这周末的重点❗❗❗\n\n\n服务器部署，有没有用过 jekins\n没有，后来他说他们是，我说我去看一下。。。\n\n\n离职状态，投了多久简历，有没有 offer，为什么离职，只剩我一个开发的话，应该还是蛮重要的。。。\n直接说发不出工资。\n\n\n期望薪资，反问\n\n\n总结\n提供了面试重难点的新思路，感觉如果是物流仓储必会问到这个，还有需要关注一下高可用相关的问题，这周好好准备一下。\n总结\n这个过了，最后去的这里。\n网新恒天（外派道富）\n\n嗯，又在胡言乱语，一紧张就胡言乱语。后面搜了如果到好的项目组就是 1055，后悔，早知道最后面这个，居然还有这种外包😭。全部都是八股文。（其实正常外包应该都是这样吧，第一天背了半天八股没有怎么问，嗯应该也问了，但是没有这么频繁，感觉这边面试是八股文集合）\n\n一面（八股）\n面试题和回答点\n\n\n自我介绍（+ 简单的英文自我介绍）\n英文，嗯，忘光了。\n\n\nArrayList 和 LinkedList 区别\n\n\nArrayList 初始容量\n\n\nHashMap 底层结构\n\n\nHashMap 扩容机制\n卡住了，卡到 put 了，然后说说几倍就行\n\n\nAOP 的原理🤡\n\n\nSPI 机制🤡\n\n\nJava 中有哪些锁？\n只说了 Lock 和 synchronized，顺便提到了公平锁和非公平锁。\n\n\n还有吗？\n可能想问 CAS？还是锁的分类？不知道我直接说的没有了吧。。。\n\n\n线程的 run() 和 start() 有什么区别？\n\n\nsleep() 和 wait() 有什么区别？\n\n\nMySQL 的索引\n不知道具体要问什么。。。说了一下 innodb 是聚簇索引。然后问了一下这个要问什么。。。然后说不问了\n\n\n事务的几个特性？ACID 是什么🤡\n\n\nSQL 优化\n\n\n有没有用过序列、触发器\n我说我不知道，问我有没有用过 Oracle\n\n\nMQ，有没有用过 Kafka\n\n\nLinux 常见命令🤡\n\n\n怎么在系统中找到一个文件\nfind。\n\n\n会不会前端\n\n\n最后英语自我介绍，反问\n英语真的想不出来阿巴了半天，反问懒得问了就说没有。\n\n\n总结\n八股文不熟，总览里的题目必会。好像过了，在推项目组，不知道行不行。\n二面（项目）\n间隔的时间比较久了，面试通过了，只记录一下过程中让做的一道比较有意思的题目。\n不借助 java 自带的并发容器类，实现一个吞吐率尽可能高的先入先出数据结构，最多能容纳1000个元素。实现线程无锁安全。\n/**   * @author ZYF   * @date: 2024/8/28 17:26   * @description:   */  public class LockFreeQueue&lt;E&gt; &#123;      private final AtomicReferenceArray&lt;E&gt; array;        private final AtomicInteger head;      private final AtomicInteger tail;        private final int capacity;        public LockFreeQueue(int capacity) &#123;          // 环形缓冲区实际大小为 capacity + 1          this.capacity = capacity + 1;          this.array = new AtomicReferenceArray&lt;&gt;(this.capacity);                this.head = new AtomicInteger(0);          this.tail = new AtomicInteger(0);      &#125;            public boolean offer(E item) &#123;          if (item == null) &#123;              throw new NullPointerException(&quot;Item cannot be null&quot;);          &#125;            while (true) &#123;              int currentTail = tail.get();              int nextTail = (currentTail + 1) % capacity;                if (nextTail == head.get()) &#123;                  // 队列已满                  return false;              &#125;                if (array.compareAndSet(currentTail, null, item)) &#123;                  // 插入成功，更新尾指针                  tail.compareAndSet(currentTail, nextTail);                  return true;              &#125;          &#125;      &#125;        public E poll() &#123;          while (true) &#123;              int currentHead = head.get();              int currentTail = tail.get();                if (currentHead == currentTail) &#123;                  // 队列为空                  return null;              &#125;                E item = array.get(currentHead);              if (item != null &amp;&amp; array.compareAndSet(currentHead, item, null)) &#123;                  // 读取成功，更新头指针                  head.compareAndSet(currentHead, (currentHead + 1) % capacity);                  return item;              &#125;          &#125;      &#125;        public boolean isEmpty() &#123;          return head.get() == tail.get();      &#125;        public boolean isFull() &#123;          return (tail.get() + 1) % capacity == head.get();      &#125;  &#125;  \n总结\n最后没有去这里，因为外包。但是待遇比现在的好，希望之后不会后悔。\n","categories":["面试","面试记录"],"tags":["Java","面试"]},{"title":"面试-数据结构和算法","url":"/posts/1b906b1a/","content":"\n\n前言根据刷题记录，整理各个类型的特点\n\n\n更新\n\n\n24.04.22 初始记录 数组的总结24.05.23 链表的总结24.05.24 哈希表的总结24.05.29 字符串的总结（KMP）24.06.09 二叉树总结24.07.10 动态规划总结\n\n数据结构\n数组\n基础理论\n1、数组是存放在连续内存空间上的相同类型数据的集合。\n\n\n数组下标从 0 开始\n\n\n数组的内存空间地址连续\n\n\n2、因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。\n3、数组的元素是不能删的，只能覆盖。\n4、二维数组在内存的空间地址不连续\n经典题目\n二分法\n需要遵循循环不变量原则。这里的循环不变量原则在二分法中的表现就是，循环过程中左闭右开，这个规则是不变的。\n双指针法\n快慢指针法：通过一个快指针和慢指针在一个 for 循环下完成两个 for 循环的工作。\n双向指针法：一个指针从左向右一个指针从右向左。从左向右的找等于目标值的位置，从右向左找不等于目标的位置，每次找到一个用不等于覆盖等于。（就是自己第一次题解时的做法）\n滑动窗口\n动态更新窗口的大小，找到最优解。\n滑动窗口的精妙之处在于根据当前子序列和大小的情况，不断调节子序列的起始位置。从而将 O(n^2) 的暴力解法降为 O(n)。\n模拟行为\n目前遇到的题型是螺旋矩阵。\n这类题目只要模拟数组需要执行的操作就行，需要注意边界值，遵循循环不变量原则。\n链表\n基础理论\n分类\n\n\n单链表\n指针域只能指向节点的下一个节点。\n\n\n双链表\n每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。\n\n\n循环链表\n链表首尾相连。\n\n\n存储方式\n数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。\n链表是通过指针域的指针链接在内存中各个节点。\n所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。\n链表的定义\npublic class ListNode &#123;      public int val;      public ListNode next;        public ListNode() &#123;      &#125;        public ListNode(int val) &#123;          this.val = val;      &#125;  &#125;\n链表操作\n删除节点\n将该节点跳过，前一节点指向后一节点。\n添加节点\n前一节点指向该节点，该节点指向后一节点。\n性能分析\n\n\n\n\n插入/删除（时间复杂度）\n查询（时间复杂度）\n适用场景\n\n\n\n\n数组\nO(n)\nO(1)\n数据量固定，频繁查询，较少增删\n\n\n链表\nO(1)\nO(n)\n数据量不固定，频繁增删，较少查询\n\n\n\n经典题目\n虚拟头节点\n链表中的增删操作，都是需要操作前一个节点进行指向。但是对于头节点的操作，由于没有前一个节点，每次都需要单独处理。因此使用虚拟头结点的技巧。（基本上做题都是加上虚拟节点比较方便）\n链表的基本操作\n\n\n获取链表第 index 个节点的数值\n\n\n在链表的最前面插入一个节点\n\n\n在链表的最后面插入一个节点\n\n\n在链表第 index 个节点前面插入一个节点\n\n\n删除链表的第 index 个节点的数值\n\n\n反转链表\n\n\n迭代法用双指针，改变两个节点之间的指针方向\n\n\n递归法和迭代法的思路基本一样，把移动下一步的操作放到递归里进行。\n\n\n两两交换链表中的节点\n这题也用到了虚拟头节点的方法。\n\n\n需要交换的两个节点的前一个节点，指向需要交换的第二个节点\n\n\n节点交换\n\n\n删除倒数第N个节点\n运用虚拟头节点 + 双指针。\n思路是，一个指针先走 N 步，然后两个指针一起向后。当快指针指向末尾时，慢指针的位置正好是倒数第 N 个节点。然后完成删除操作。\n链表相交\n这里的相交指的是引用完全相同，即：内存地址完全相同的交点\n环形链表\n\n\n判断是否有环\n\n\n判断交点位置这是一道数学题，具体解析在对应的文章中给出。\n\n\n哈希表\n基础理论\n定义\n哈希表是根据关键码的值而直接进行访问的数据结构。\n\n一般使用\n一般哈希表都是用来快速判断一个元素是否出现集合里。\n哈希函数/哈希碰撞\n哈希函数是把传入的 key 映射到符号表的索引上。\n哈希碰撞处理有多个 key 映射到相同索引上时的情景，处理碰撞的普遍方式是拉链法和线性探测法。\n常见的三种哈希结构\n\n\n数组\n\n\nset（集合）\n\n\nmap（映射）\n\n\n哈希表经典题目\n数组作为哈希表\n一般题目中出现规定 map 大小（比如明说都是小写字母），就可以使用数组。这些题用 map 确实可以，但使用 map 的空间消耗要比数组大一些，因为 map 要维护红黑树或者符号表，而且还要做哈希函数的运算。所以数组更加简单直接有效！\n\n关联题目：\n有效的字母异位词\n赎金信\n\nset 作为哈希表\n如果题目没有限制大小，就无法使用数组。\n主要因为：\n\n\n数组的大小是有限的，受到系统栈空间（不是数据结构的栈）的限制。\n\n\n如果数组空间够大，但哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。\n\n\n\n关联题目：\n两个数组的交集\n快乐数\n\nmap作为哈希表\nset 是一个集合，里面放的元素只能是一个 key，但是遇到 key 与 value 都要保存时，就需要使用 map。\n字符串\n基础理论\n定义\n字符串是若干字符组成的有限序列，也可以理解为是一个字符数组。\n字符串经典题目\n双指针\n双指针法在数组，链表和字符串中很常用。\n\n关联题目：\n反转字符串：只是简单使用 temp 作为中间变量。\n替换字符：数组填充类的问题，可以先预先给数组扩容带填充后的大小，然后再从后向前进行操作。\n与移除操作有关的双指针操作：\n翻转字符串内的单词 中的移除空格部分。\n之前数组部分中 移除数组元素\n\n反转系列\n反转就是双指针（头尾指针一起向中间移动，然后交换数组元素）\n\n关联题目：\n反转字符串II\n翻转字符串内的单词：这题的反转用了两次，先整体反转，再分段反转。\n右旋转字符串：和上题一样需要先局部反转再整体反转。（这种题笔试遇到直接 API 快一点）\n\nKMP\nKMP 算法是字符串查找最重要的算法。\nKMP 的主要思想是当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。\n\n关联题目：\n实现 strStr() 、重复的子字符串\n\n前缀表\n作用：前缀表是用来回退的，它记录了模式串与主串 (文本串) 不匹配的时候，模式串应该从哪里开始重新匹配。\n常见的基础题目是在文本串中查找一个模式串，例：在 aabaabaafa 中查找 aabaaf。这个查找是文本串指针顺序后移（不变），活动模式串进行匹配。\n前缀表用于记录查找失败后，模式串下一次返回查找的点。例：文本串指针到第二个 b 时，查找失败，这时模式串从 b 这个位置重新查询。\n什么是前缀表？\n记录下标 i 之前（包括 i）的字符串中，有多大长度的相同前缀后缀。\n最长公共前后缀\n前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串。\n后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串。这个部分暂时是比较好理解的。\n为什么使用前缀表可以告诉我们匹配失败之后跳到哪里重新匹配？\n\n这张图是教程内的图，下标 5 之前这部分的字符串（也就是字符串 aabaa）的最长相等的前缀 和 后缀字符串是 子字符串 aa ，因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面重新匹配就可以了。\n如何找到一张前缀表\n不是很能理解，但是背下来了\n// 需要找到前缀表的字符串String s;// 初始化int j = 0;int[] next = new int[s.length];for(int i = 1; i &lt; s.length, i++) &#123;\t// 不相同的情况\twhile(j != 0 &amp;&amp; s.charAt[i] != s.charAt[j]) &#123;\t\tj = next[j - 1];\t&#125;\tif(s.charAt[i] == s.charAt[j]) &#123;\t\tj++;\t&#125;\tnext[i] = j;&#125;\n栈与队列\n基础理论\n队列是先进先出，栈是先进后出。\n栈与队列的基础可以通过下面两题回忆。\n\n用栈实现队列\n用队列实现栈\n\n栈经典题目\n\n有效的括号：括号匹配是使用栈解决的经典问题。\n删除字符串中的所有相邻重复项：思路就是可以把字符串顺序放到一个栈中，然后如果相同的话 栈就弹出，这样最后栈里剩下的元素都是相邻不相同的元素了。\n逆波兰表达式求值：这题主要在于题目中给出的百度链接，其中描述了逆波兰式子的意思。计算方式就是遍历式子，遇到数字入栈，遇到运算符出栈两个数字进行计算，计算结果再入栈。直到式子循环完毕。\n\n队列经典题目\n\n滑动窗口最大值：这题需要用到单调队列，即单调递减或单调递增的队列（需要自己定义数据结构）\n前 K 个高频元素：这题需要用到优先级队列，其实就是堆（堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。）\n\n二叉树\n基础理论\n二叉树的种类\n满二叉树\n满二叉树：如果一棵二叉树只有度为 0 的结点和度为 2 的结点，并且度为 0 的结点在同一层上，则这棵二叉树为满二叉树。\n这棵二叉树为满二叉树，也可以说深度为 k，有 2^k-1 个节点的二叉树。\n完全二叉树\n完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（h 从 1 开始），则该层包含 1~ 2^(h-1) 个节点。\n优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。\n二叉搜索树\n二叉搜索树是一个有序树\n\n\n若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；\n\n\n若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；\n\n\n它的左、右子树也分别为二叉排序树\n\n\n平衡二叉搜索树\n平衡二叉搜索树：又被称为 AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。\n二叉树的存储方式\n二叉树可以链式存储，也可以顺序存储。\n那么链式存储方式就用指针， 顺序存储的方式就是用数组。\n用数组来存储二叉树如何遍历？如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。\n二叉树的遍历方式\n二叉树主要有两种遍历方式：\n\n\n深度优先遍历：先往深走，遇到叶子节点再往回走。\n\n\n广度优先遍历：一层一层的去遍历。\n这两种遍历是图论中最基本的两种遍历方式\n从深度优先遍历和广度优先遍历进一步拓展：\n\n\n\n\n深度优先遍历\n\n前序遍历（递归法，迭代法）\n中序遍历（递归法，迭代法）\n后序遍历（递归法，迭代法）\n\n\n\n广度优先遍历\n\n层次遍历（迭代法）\n这里前中后，其实指的就是中间节点的遍历顺序，前中后序指的就是中间节点的位置。\n\n\n\n\n❗二叉树的递归遍历、二叉树的迭代遍历、二叉树的统一迭代法：(https://kiml.site/posts/a297f438/)\n二叉树的层序遍历\n\n❗递归算法的三要素\n\n\n确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。\n\n\n确定终止条件： 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。\n\n\n确定单层递归的逻辑： 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。\n\n\n二叉树的定义\npublic class TreeNode &#123;    int val;    TreeNode left;    TreeNode right;    TreeNode() &#123;&#125;    TreeNode(int val) &#123; this.val = val; &#125;    TreeNode(int val, TreeNode left, TreeNode right) &#123;        this.val = val;        this.left = left;        this.right = right;    &#125;&#125;\n经典题目\n遍历方式\n\n❗二叉树的递归遍历、二叉树的迭代遍历、二叉树的统一迭代法：(https://kiml.site/posts/a297f438/)\n二叉树的层序遍历\n\n层序遍历相关的题目比较多，没有写到笔记里面。（一个模板可以做十道题，部分在 github 上提交了，部分没有做。）\n二叉树的属性\n\n\n是否对称、相同\n\n\n\n对称二叉树\n递归：后序遍历。判断左右子树：左右中、右左中是否相等。\n迭代：使用队列/栈将两个节点顺序放入容器中进行比较。\n\n\n\n求最大深度\n\n\n\n二叉树的最大深度\n递归：后序遍历，求根节点最大高度就是最大深度，通过递归函数的返回值做计算树的高度。\n\n\n\n求最小深度\n\n\n\n二叉树的最小深度\n递归：后序遍历，右节点为空，向左递归；左节点为空，向右递归。\n\n\n\n求节点数\n\n\n\n完全二叉树的节点个数\n普通二叉树的节点个数：层序遍历\n完全二叉树：\n分两种情况：满二叉树/最后一层节点没有满。但是这两种情况可以简化为一种，即孩子节点必定为满二叉树（按满二叉树算节点）\n于是就变成判断子树是否是满二叉树：向左递归的深度等于向右递归的深度\n\n\n\n是否平衡\n\n\n\n平衡二叉树\n递归：后序遍历。判断子树是否平衡并把结果向上传递。\n\n\n\n找所有路径\n\n\n\n二叉树的所有路径\n递归：前序遍历。涉及回溯。\n\n\n\n求左叶子之和\n\n\n\n左叶子之和\n递归：后序遍历。\n\n\n\n求左下角的值。\n\n\n\n找树左下角的值\n递归：顺序没有关系。找深度最大的左叶子节点（优先左遍历）。\n迭代：感觉层序遍历更简单一点。\n\n\n\n求路径总和\n\n\n\n路径总和、路径总和ii\n递归：需要回溯。\n\n二叉树的修改与构造\n\n\n翻转二叉树\n\n\n\n翻转二叉树\n递归：中序不行。左右两数交换指针。\n\n\n\n构造二叉树\n\n\n\n从中序与后序遍历序列构造二叉树、从前序与中序遍历序列构造二叉树\n最大二叉树\n递归：思路就是根据后序/前序的遍历结果。切割中序，再递归构造。\n\n\n\n合并二叉树\n\n\n\n合并二叉树\n递归：前序遍历。\n\n最近公共祖先\n\n二叉树的最近公共祖先：从底层向上传递信息（只能用后序）。找到一个节点的左子树含 p，右子树含 q（可以先交换两个数的大小顺序）\n二叉搜索树的最近公共祖先：遍历顺序随便。重点在当我们从上向下去递归遍历，第一次遇到 cur 节点是数值在 [q, p] 区间中，那么 cur 就是 q 和 p 的最近公共祖先。\n\n二叉搜索树的属性\n\n\n遍历\n\n\n\n二叉搜索树中的搜索：二叉搜索树的遍历是有方向的。\n\n\n\n中序遍历下，输出的二叉搜索树节点的数值是有序序列。\n\n\n\n验证二叉搜索树\n易错点：左子树所有节点小于中间节点，右子树所有节点大于中间节点\n\n\n\npre 标记前节点的双指针用法\n\n\n\n验证二叉搜索树\n二叉搜索树的最小绝对差\n二叉搜索树中的众数\n把二叉搜索树转换为累加树\n\n二叉搜索树的修改与构造\n\n\n插入操作\n\n\n\n二叉搜索树中的插入操作：找到位置直接插入\n\n\n\n删除操作\n\n\n\n删除二叉搜索树中的节点：删除非叶子节点：用右子树顶位（比较好理解）。\n修剪二叉搜索树：需要注意修剪情况。\n\n\n\n构造二叉树\n\n\n\n将有序数组转换为二叉搜索树：与构造二叉树基本一致。找到中间节点后切割。\n\n总结\n\n\n涉及到二叉树的构造，无论普通二叉树还是二叉搜索树一定前序，都是先构造中节点。\n\n\n求普通二叉树的属性，一般是后序，一般要通过递归函数的返回值做计算。\n\n\n求二叉搜索树的属性，一定是中序了，要不白瞎了有序性了。\n\n\n算法\n回溯算法\n理论基础\n\n回溯法也可以叫做回溯搜索法，它是一种搜索的方式。\n回溯法解决的问题都可以抽象为树形结构。因为回溯法解决的都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度就构成了树的深度。\n\n效率：回溯法并不是什么高效的算法。因为回溯的本质是穷举\n能解决的问题：组合问题、切割问题、子集问题、排列问题、棋盘问题。\n回溯法模板\nfor 循环横向遍历，递归纵向遍历，回溯不断调整结果集。\n\n\n回溯函数模板返回值以及参数回溯算法中函数返回值一般为 void。\n\n\n回溯函数终止条件\n\n\n回溯搜索的遍历过程\n\n\nvoid backtracking(参数) &#123;    if (终止条件) &#123;        存放结果;        return;    &#125;    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;        处理节点;        backtracking(路径，选择列表); // 递归        回溯，撤销处理结果    &#125;&#125;\n❗剪枝\n剪枝精髓是：for 循环在寻找起点的时候要有一个范围，如果这个起点到集合终止之间的元素已经不够 题目要求的 k 个元素了，就没有必要搜索了。\n❗去重\n\n去重包括 “树枝去重”和“树层去重”。如图所示：在 candidates[i] == candidates[i - 1] 相同的情况下：\n\n\nused[i - 1] == true，说明同一树枝 candidates[i - 1] 使用过\n\n\nused[i - 1] == false，说明同一树层 candidates[i - 1] 使用过\n\n\n经典题目\n回溯算法能解决如下题目：\n\n\n组合问题：N 个数里面按一定规则找出 k 个数的集合\n\n\n排列问题：N 个数按一定规则全排列，有几种排列方式\n\n\n切割问题：一个字符串按一定规则有几种切割方式\n\n\n子集问题：一个 N 个数的集合里有多少符合条件的子集\n\n\n棋盘问题：N 皇后，解数独等等\n\n\n组合问题\n回溯算法的精髓在于：for 循环横向遍历，递归纵向遍历，回溯不断调整结果集，优化回溯算法只有剪枝一种方法。做题前可以先把题目抽象成树，这样剪枝操作也比较好理解。\n\n组合\n组合总和III：相当于组合问题加了一个元素总和的限制。（大于元素总和需要剪枝）\n组合总和：给出的集合是不重复的，但是元素可以。\n组合总和II：给出的集合元素是有重复的，但是要求解集不重复。难点在去重\n电话号码的字母组合：多个集合求组合的问题。\n\n切割问题\n\n分割回文串：类似组合问题，但是求值处为一个范围截取。\n复原IP地址\n\n子集问题\n\n子集：树形结构中子集问题是要收集所有节点的结果，而组合问题是收集叶子节点的结果。\n子集II：在子集问题的基础上加上了去重。\n递增子序列：层去重。\n\n排列问题\n\n全排列：排列每层都需要从 0 开始搜索。\n[全排列 II]：在排列的基础上加上去重。\n\n图论额外拓展\n\n重新安排行程\n\n棋盘问题\n\nN皇后\n解数独\n\n性能分析\n这段直接抄的 (https://programmercarl.com/回溯总结.html)\n子集问题分析：\n\n\n时间复杂度：O(2^n)，因为每一个元素的状态无外乎取与不取，所以时间复杂度为 O(2^n)\n\n\n空间复杂度：O(n)，递归深度为 n，所以系统栈所用空间为 O(n)，每一层递归所用的空间都是常数级别，注意代码里的 result 和 path 都是全局变量，就算是放在参数里，传的也是引用，并不会新申请内存空间，最终空间复杂度为 O(n)\n排列问题分析：\n\n\n时间复杂度：O(n!)，这个可以从排列的树形图中很明显发现，每一层节点为 n，第二层每一个分支都延伸了 n-1 个分支，再往下又是 n-2 个分支，所以一直到叶子节点一共就是 n * n-1 * n-2 * …… 1 = n!。\n\n\n空间复杂度：O(n)，和子集问题同理。组合问题分析：\n\n\n时间复杂度：O(2^n)，组合问题其实就是一种子集的问题，所以组合问题最坏的情况，也不会超过子集问题的时间复杂度。\n\n\n空间复杂度：O(n)，和子集问题同理。\nN 皇后问题分析：\n\n\n时间复杂度：O(n!) ，其实如果看树形图的话，直觉上是 O(n^n)，但皇后之间不能见面所以在搜索的过程中是有剪枝的，最差也就是 O（n!），n!表示 n * (n-1) * …. * 1。\n\n\n空间复杂度：O(n)，和子集问题同理。解数独问题分析：\n\n\n时间复杂度：O(9^m) , m 是 ‘.’ 的数目。\n\n\n空间复杂度：O(n^2)，递归的深度是 n^2\n\n\n贪心算法\n贪心的本质是选择每一阶段的局部最优，从而达到全局最优。\n一般解题步骤（不一定能用）\n\n\n将问题分解为若干个子问题\n\n\n找出适合的贪心策略\n\n\n求解每一个子问题的最优解\n\n\n将局部最优解堆叠成全局最优解\n\n\n经典题目\n因为贪心算法没有什么套路，所以刷题很难分类。\n简单题\n\n分发饼干\nK次取反后最大化的数组和\n柠檬水找零\n\n中等题\n\n摆动序列\n单调递增的数字\n贪心解决股票问题\n买卖股票的最佳时机II\n两个维度权衡问题\n分发糖果\n根据身高重建队列\n\n难题\n\n区间问题\n跳跃游戏\n跳跃游戏II\n用最少数量的箭引爆气球\n无重叠区间\n划分字母区间\n合并区间\n其他难题\n最大子序和\n加油站\n监控二叉树\n\n动态规划\n\n动态规划，英文：Dynamic Programming，简称 DP，如果某一问题有很多重叠子问题，使用动态规划是最有效的。\n\n解题步骤\n\n\n确定 dp 数组（dp table）以及下标的含义\n\n\n确定递推公式\n\n\ndp 数组如何初始化\n\n\n确定遍历顺序\n\n\n举例推导 dp 数组\n如何 Debug : 找问题的最好方式就是把 dp 数组打印出来，看看究竟是不是按照自己思路推导的！\n\n\n经典题目\n动态规划基础\n\n斐波那契数\n爬楼梯\n使用最小花费爬楼梯\n不同路径\n不同路径 II\n整数拆分\n\n背包问题\n\n\n问能否能装满背包（或者最多装多少）：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])\n\n分割等和子集：01 背包\n最后一块石头的重量 II：01 背包\n\n问装满背包有几种方法：dp[j] += dp[j - nums[i]]\n\n目标和：01 背包\n零钱兑换 II：完全背包、组合\n组合总和 Ⅳ：完全背包、排列\n爬楼梯 （进阶）：完全背包、排列\n\n问背包装满最大价值：dp[j] = max(dp[j], dp[j - weight[i]] + value[i])\n\n一和零：01 背包\n\n问装满背包所有物品的最小个数：dp[j] = min(dp[j - coins[i]] + 1, dp[j])\n\n零钱兑换：完全背包。求最小数（for 循环先后顺序无所谓）\n完全平方数：完全背包。求最小数（for 循环先后顺序无所谓）\n\n\n遍历顺序\n\n\n01 背包\n\n二维 dp 数组：先遍历背包/先遍历物品都可以\n一维 dp 数组：只能先遍历物品再遍历背包容量，第二层 for 循环需要从大到小遍历\n\n\n\n完全背包\n\n一维 dp 数组：第二层 for 循环从小到大遍历。如果求组合数就是外层 for 循环遍历物品，内层 for 遍历背包。如果求排列数就是外层 for 遍历背包，内层 for 循环遍历物品。如果是求最小数，那么两层 for 循环排列的先后顺序无所谓。\n\n\n\n打家劫舍\n\n打家劫舍\n打家劫舍 II\n打家劫舍 III\n\n递推公式\n一般都是要求相邻格子要跳过，所以公式从前前个获取（因此初始化数组需要 0，1 位置）：dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i])\n股票问题\n\n买卖股票的最佳时机\n买卖股票的最佳时机 II\n买卖股票的最佳时机 III\n买卖股票的最佳时机 IV\n最佳买卖股票时机含冷冻期\n买卖股票的最佳时机含手续费\n\n递推公式\ndp 数组的定义为二维数组（可以塌缩，但是二维比较好理解）：不同状态计入数组。当天状态一般为持有/不持有两种；如果加入天数，状态需要增加第一天持有/不持有，第二天持有/不持有……。持有的状态递推为上一次不持有 - 当天买入股票价格；不持有的状态递推为上一次持有 + 当天卖出股票的价格。\nif (j % 2 == 0) &#123;        // 偶数买入        dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - 1] - prices[i]);    &#125; else &#123;        // 奇数卖出        dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - 1] + prices[i]);    &#125;\n编辑距离\n\n判断子序列\n不同的子序列\n两个字符串的删除操作\n编辑距离\n\n递推公式\ndp 数组的定义为二维数组，可以塌缩。定义：第一个参数到 i - 1；第二个参数到 j - 1 位置的所求量（为什么记为 i - 1？：为了初始化方便）。循环从左向右从上到下（此步可以画图模拟）。根据两个数组当前位置的字符是否相同，分别写出 dp 公式。\nfor (int i = 1; i &lt;= word1.length(); i++) &#123;        for (int j = 1; j &lt;= word2.length(); j++) &#123;            // 当前指针位置相同，dp[i][j] = dp[i - 1][j - 1] + 1            if (word1.charAt(i - 1) == word2.charAt(j - 1)) &#123;    \t        // 此处需要具体公式具体分析，一般相同时，状态由左上角推出。            dp[i][j] = dp[i - 1][j - 1];            &#125; else &#123; \t        // 此处需要具体公式具体分析，根据数组元素是否能改变，可以有三种不同的情况。            dp[i][j] = Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1);            &#125;        &#125;    &#125;\n子序列\n\n连续：\n\n最长递增子序列\n最长公共子序列\n不相交的线\n\n不连续：\n\n最长连续递增序列\n最长重复子数组\n最大子序和\n\n编辑距离：详见 编辑距离模块\n回文：\n\n回文子串\n最长回文子序列\n\n\n单调栈\n\n一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时可以用单调栈。\n\n使用单调栈主要有三个判断条件。\n\n\n当前遍历的元素 T[i] 小于栈顶元素 T[st.top()] 的情况\n\n\n当前遍历的元素 T[i] 等于栈顶元素 T[st.top()] 的情况\n\n\n当前遍历的元素 T[i] 大于栈顶元素 T[st.top()] 的情况\n\n\n\n每日温度\n下一个更大元素 I\n下一个更大元素 II\n接雨水\n柱状图中最大的矩形\n\n","categories":["面试"],"tags":["面试","双指针","数组","滑动窗口","链表","哈希表","字符串","二叉树","二叉搜索树","贪心算法","动态规划","KMP"]},{"title":"消息队列的选型与优缺点","url":"/posts/359ee88a/","content":"\n\n前言针对消息队列做出的总结。\n\n\n参考文章\n\n\n\nRabbitMQ超详细安装教程（Linux）\n\n\n更新\n\n24-07-23 初始记录24-08-09 补充 RabbitMQ 的延迟消息\n\n\nMQ 全称为 Message Queue。\nMQ 也被称为消息中间件。\nMQ 也是微服务之间的通信的一种方式。\n\n为什么使用 MQ\n\n\n任务异步处理将不需要同步处理的并且耗时长的操作由消息队列通知消息接收方进行异步处理。提高了应用程序的响应时间。\n\n\n应用程序解耦合\nMQ 相当于一个中介，生产方通过 MQ 与消费方交互，它将应用程序进行解耦合。\n\n\n削峰填谷\n\n\n技术选型对比\n\n市面上有哪些消息队列？\nActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，Redis。\n\n\n\n\n消息队列\n优点\n缺点\n\n\n\n\nRabbitMQ\n1.支持 AMQP 协议2.基于 erlang 语言开发，高并发性能较好3.工作模式较为灵活 4.支持延迟消息 5.提供较为友好的后台管理页面6.单机部署，1~2WTPS\n1.不支持水平扩容 2.不支持事务 3.消息吞吐量三者最差 4.当产生消息堆积，性能下降明显 5.消息重发机制需要手动设置 6.不支持消息重复消费\n\n\nRocketMQ\n1.高可用，高吞吐量，海量消息堆积，低延迟性能上，都表现出色 2.api 与架构设计更加贴切业务场景 3.支持顺序消息 4.支持事务消息 5.支持消息过滤 6.支持重复消费 7.支持延迟消息 8.支持消息跟踪 9.天然支持集群、负载均衡 10.支持指定次数和时间间隔的失败消息重发 11.单机部署，5~10WTPS\n1.生态圈相较 Kafka 有所不如 2.消息吞吐量与消息堆积能力也不如 Kafka 3.不支持主从自动切换 4.只支持 Java\n\n\nKafka\n1.高可用，高吞吐量，低延迟性能上，都表现出色 2.使用人数多，技术生态圈完善 3.支持顺序消息 4.支持多种客户端 5.支持重复消费\n1.依赖分区，消费者数量受限于分区数 2.单机消息过多时，性能下降明显 3.不支持事务消息 4.不支持指定次数和时间间隔的失败消息重发\n\n\n\n消息中间件对比 - 选择建议\n\n\n\n消息中间件\n建议\n\n\n\n\nKafka\n追求高吞吐量，适合产生大量数据的互联网服务的数据收集业务\n\n\nRocketMQ\n可靠性要求很高的金融互联网领域，稳定性高，经历了多次阿里双 11 考验\n\n\nRabbitMQ\n性能较好，社区活跃度高，数据量没有那么大，优先选择功能比较完备的 RabbitMQ\n\n\n\nRabbitMQ\n基础\n\n安装\nWindows\n\n\n下载 RabbitMQ（https://www.rabbitmq.com/docs/download）\n\n\n下载 Erlang（https://packagecloud.io/rabbitmq/erlang），并配置环境变量\nErlang 和 RabbitMQ 版本对照：https://www.rabbitmq.com/which-erlang.html\n\n\n运行 RabbitMQ\n\n\n# 开启管理插件rabbitmq-plugins enable rabbitmq_management# 启动rabbitmq systemctl start rabbitmq-server # 查看rabbitmq状态 systemctl status rabbitmq-server# 设置rabbitmq服务开机自启动systemctl enable rabbitmq-server# 关闭rabbitmq服务systemctl stop rabbitmq-server# 重启rabbitmq服务systemctl restart rabbitmq-server\nLinux\ndocker 安装\n# 1.yum包更新到最新yum update# 2.安装需要的软件包(yum-utils提供yum-config-manager的功能,，并且device mapper存储驱动程序需要device-mapper-persistent-data和lvm2)yum install -y yum-utils device-mapper-persistent-data lvm2# 3.设置yum源为阿里云yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo# 4.安装dockeryum install docker-ce -y# 5.安装后查看docker版本docker -v# 6.阿里云镜像加速sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;&#123;  &quot;registry-mirrors&quot;: [&quot;https://73z5h6yb.mirror.aliyuncs.com&quot;]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker# 安装启动rabbitmq容器docker run -d --name 容器名称 -e RABBITMQ_DEFAULT_USER=xxx -e RABBITMQ_DEFAULT_PASS=123456 -p 15672:15672 -p 5672:5672 rabbitmq:3.8.14-management\ndocker 常用命令\n# 启动dockersystemctl start docker# 停止dockersystemctl stop docker# 重启dockersystemctl restart docker# 查看docker状态systemctl status docker# 开机启动systemctl enable dockersystemctl unenable docker # 查看docker概要信息docker info # 查看docker帮助文档docker --help\n不使用 docker\n\n\n下载 RabbitMQ（https://www.rabbitmq.com/docs/download）\n\n\n下载 Erlang（https://packagecloud.io/rabbitmq/erlang）\nErlang 和 RabbitMQ 版本对照：https://www.rabbitmq.com/which-erlang.html\n\n\n安装 Erlang 和 RabbitMQ\n\n\n# 安装 Erlang## 解压rpm -Uvh erlang-23.2.7-2.el7.x86_64.rpm## 安装yum install -y erlang## 安装完成后输入如下指令查看版本号erl -v# 安装 RabbitMQ## 在 RabiitMQ 安装过程中需要依赖 socat 插件，首先安装该插件yum install -y socat## 解压 rpm -Uvh rabbitmq-server-3.8.14-1.el7.noarch.rpm ## 安装 yum install -y rabbitmq-server## 启动rabbitmq systemctl start rabbitmq-server ## 查看rabbitmq状态 systemctl status rabbitmq-server# 其他命令## 设置rabbitmq服务开机自启动systemctl enable rabbitmq-server## 关闭rabbitmq服务systemctl stop rabbitmq-server## 重启rabbitmq服务systemctl restart rabbitmq-server\n\n\nRabbitMQWeb 管理界面及授权操作\n\n\n# 打开RabbitMQWeb管理界面插件，然后访问服务器公网ip:15672。默认账号密码 guest，guestrabbitmq-plugins enable rabbitmq_management\n\n\n添加远程账户\n\n\n# 添加用户rabbitmqctl add_user 用户名 密码# 设置用户角色,分配操作权限rabbitmqctl set_user_tags 用户名 角色# 为用户添加资源权限(授予访问虚拟机根节点的所有权限)rabbitmqctl set_permissions -p / 用户名 &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;# 修改密码rabbitmqctl change_ password 用户名 新密码# 删除用户rabbitmqctl delete_user 用户名# 查看用户清单rabbitmqctl list_users\n角色有四种：\n\n\nadministrator：可以登录控制台、查看所有信息、并对 rabbitMQ 进行管理\n\n\nmonToring：监控者；登录控制台，查看所有信息\n\n\npolicymaker：策略制定者；登录控制台指定策略\n\n\nmanagment：普通管理员；登录控制\n\n\n基本使用\n\n\n添加依赖\n\n\n&lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;  &lt;/dependency&gt;\n\n\n配置信息\n\n\nspring:  rabbitmq:      rabbitmq:    port: 5673    host: localhost    username: swsk33    password: 123456\n五种模型\nBasic Queue\n\n（简单队列模型）：一个生产者、一个消费者，不需要设置交换机（使用默认的交换机）\n\n// 发送消息@Component  @Slf4j  public class RabbitMqSend &#123;      @Autowired      private AmqpTemplate amqpTemplate;      public void sendQueryOrderMessage(Object msg) &#123;          amqpTemplate.convertAndSend(&quot;xxx&quot;, msg);      &#125;  &#125;// 接收消息@Component  @Slf4j  public class RabbitMQListener &#123;        @RabbitListener(queues = &quot;xxx&quot;)      public void handlerOrderQueryMsg(String msg) &#123;          log.info(&quot;xxx接收到信息：&quot; + msg);          // 逻辑处理代码        return;    &#125;  &#125;\nWork Queue\n\n（工作队列模式）：一个生产者、多个消费者（竞争关系），不需要设置交换机（使用默认的交换机）\n\n// 发送消息@Component  @Slf4j  public class RabbitMqSend &#123;      @Autowired      private AmqpTemplate amqpTemplate;      public void sendQueryOrderMessage(Object msg) &#123;          // 队列名称  \t    String queueName = &quot;simple.queue&quot;;  \t    for (int i = 0; i &lt; 50; i++) &#123;  \t        // 发送消息 向队列中不停发送消息，模拟消息堆积。 \t        rabbitTemplate.convertAndSend(queueName, msg + i);  \t        Thread.sleep(20);  \t    &#125;      &#125;  &#125;// 接收消息@RabbitListener(queues = &quot;simple.queue&quot;)  public void listenWorkQueue1(String msg) throws InterruptedException &#123;      System.out.println(&quot;消费者1接收到消息：【&quot; + msg + &quot;】&quot; + LocalTime.now());      Thread.sleep(20);  &#125;    @RabbitListener(queues = &quot;simple.queue&quot;)  public void listenWorkQueue2(String msg) throws InterruptedException &#123;      System.err.println(&quot;消费者2........接收到消息：【&quot; + msg + &quot;】&quot; + LocalTime.now());      Thread.sleep(200);  &#125;\n在不添加额外配置的情况下，两个消费者会平分消息进行消费。为了避免这种情况，可以多加一个配置。prefetch 这个配置可以控制消费者预取的消息数量。\nspring:  rabbitmq:    listener:      simple:        prefetch: 1 # 每次只能获取一条消息，处理完成才能获取下一个消息\nFanout\n\n（发布订阅模式群发）：需要设置类型为 fanout 的交换机，并且交换机和队列进行绑定，当发送消息到交换机后，交换机会将消息发送到绑定的队列。\n\n//  交换机与队列绑定@Configurationpublic class FanoutConfig &#123;    /**     * 声明交换机     * @return Fanout类型交换机     */    @Bean    public FanoutExchange fanoutExchange()&#123;        return new FanoutExchange(&quot;xxx.fanout&quot;);    &#125;    /**     * 第1个队列     */    @Bean    public Queue fanoutQueue1()&#123;        return new Queue(&quot;fanout.queue1&quot;);    &#125;    /**     * 绑定队列和交换机     */    @Bean    public Binding bindingQueue1(Queue fanoutQueue1, FanoutExchange fanoutExchange)&#123;        return BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);    &#125;    /**     * 第2个队列     */    @Bean    public Queue fanoutQueue2()&#123;        return new Queue(&quot;fanout.queue2&quot;);    &#125;    /**     * 绑定队列和交换机     */    @Bean    public Binding bindingQueue2(Queue fanoutQueue2, FanoutExchange fanoutExchange)&#123;        return BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);    &#125;&#125;// 发送消息@Component  @Slf4j  public class RabbitMqSend &#123;      @Autowired      private AmqpTemplate amqpTemplate;      public void sendQueryOrderMessage(Object msg) &#123;          // 队列名称  \t    String exchangeName = &quot;xxx.fanout&quot;;  \t    for (int i = 0; i &lt; 50; i++) &#123;  \t        rabbitTemplate.convertAndSend(exchangeName, &quot;&quot;, msg);\t        Thread.sleep(20);  \t    &#125;      &#125;  &#125;// 接收消息@RabbitListener(queues = &quot;simple.queue&quot;)  public void listenWorkQueue1(String msg) throws InterruptedException &#123;      System.out.println(&quot;消费者1接收到消息：【&quot; + msg + &quot;】&quot; + LocalTime.now());      Thread.sleep(20);  &#125;    @RabbitListener(queues = &quot;simple.queue&quot;)  public void listenWorkQueue2(String msg) throws InterruptedException &#123;      System.err.println(&quot;消费者2........接收到消息：【&quot; + msg + &quot;】&quot; + LocalTime.now());      Thread.sleep(200);  &#125;\nDirect\n\n（路由模式）：需要设置类型为 direct 的交换机，交换机和队列进行绑定，并且指定 routing key，当发送消息到交换机后，交换机会根据 routing key 将消息发送到对应的队列\n\n// 发送消息@Component  @Slf4j  public class RabbitMqSend &#123;      @Autowired      private AmqpTemplate amqpTemplate;      public void sendQueryOrderMessage(Object msg) &#123;  \t    String exchangeName = &quot;xxx.direct&quot;;    \t    rabbitTemplate.convertAndSend(exchangeName, &quot;red&quot;, message);    &#125;  &#125;// 接收消息// 基于注解声明队列和交换机@RabbitListener(bindings = @QueueBinding(    value = @Queue(name = &quot;direct.queue1&quot;),    exchange = @Exchange(name = &quot;xxx.direct&quot;, type = ExchangeTypes.DIRECT),    key = &#123;&quot;red&quot;, &quot;blue&quot;&#125;))public void listenDirectQueue1(String msg)&#123;    System.out.println(&quot;消费者接收到direct.queue1的消息：【&quot; + msg + &quot;】&quot;);&#125;@RabbitListener(bindings = @QueueBinding(    value = @Queue(name = &quot;direct.queue2&quot;),    exchange = @Exchange(name = &quot;xxx.direct&quot;, type = ExchangeTypes.DIRECT),    key = &#123;&quot;red&quot;, &quot;yellow&quot;&#125;))public void listenDirectQueue2(String msg)&#123;    System.out.println(&quot;消费者接收到direct.queue2的消息：【&quot; + msg + &quot;】&quot;);&#125;\nTopic\n\n（通配符模式）：需要设置类型为 topic 的交换机，交换机和队列进行绑定，并且指定通配 符方式的 routing key，当发送消息到交换机后，交换机会根据 routing key 将消息发送到对应的队列。Topic 类型的 Exchange 与 Direct 相比，都是可以根据 RoutingKey 把消息路由到不同的队列。只不过 Topic 类型 Exchange 可以让队列在绑定 Routing key 的时候使用通配符。\n\n通配符规则：#：匹配一个或多个词*：匹配不多不少恰好 1 个词\n// 发送消息@Component  @Slf4j  public class RabbitMqSend &#123;      @Autowired      private AmqpTemplate amqpTemplate;      public void sendQueryOrderMessage(Object msg) &#123;  \t    String exchangeName = &quot;xxx.topic&quot;;    \t    rabbitTemplate.convertAndSend(exchangeName, &quot;china.news&quot;, message);    &#125;  &#125;// 接收消息@RabbitListener(bindings = @QueueBinding(    value = @Queue(name = &quot;topic.queue1&quot;),    exchange = @Exchange(name = &quot;xxx.topic&quot;, type = ExchangeTypes.TOPIC),    key = &quot;china.#&quot;))public void listenTopicQueue1(String msg)&#123;    System.out.println(&quot;消费者接收到topic.queue1的消息：【&quot; + msg + &quot;】&quot;);&#125;@RabbitListener(bindings = @QueueBinding(    value = @Queue(name = &quot;topic.queue2&quot;),    exchange = @Exchange(name = &quot;xxx.topic&quot;, type = ExchangeTypes.TOPIC),    key = &quot;#.news&quot;))public void listenTopicQueue2(String msg)&#123;    System.out.println(&quot;消费者接收到topic.queue2的消息：【&quot; + msg + &quot;】&quot;);&#125;\n消息转换器\n\nSpring 会把你发送的消息序列化为字节发送给 MQ，接收消息的时候，还会把字节反序列化为 Java 对象。默认情况下 Spring 采用的序列化方式是 JDK 序列化：数据体积过大、有安全漏洞、可读性差。\n\n\n\n在 publisher 和 consumer 两个服务中都引入依赖\n\n\n&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt;    &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt;    &lt;version&gt;2.9.10&lt;/version&gt;&lt;/dependency&gt;\n\n\n在启动类中添加一个 Bean\n\n\n@Beanpublic MessageConverter jsonMessageConverter()&#123;    return new Jackson2JsonMessageConverter();&#125;\n延迟消息\n\nRbbitMQ 实现延时消息主要有两种方式：\n\n死信消息（队列 ttl+ 死信 exchange）\n2. 延时插件 (rabbitmq-delayed-message-exchange)\n\n\n死信消息\n\nRabbitMQ 为每个队列设置消息的超时时间。只要给队列设置 x-message-ttl 参数（也可以给单条消息设置存活时间），就设定了该队列所有消息的存活时间，时间单位是毫秒。如果声明队列时指定了死信交换器，则过期消息会成为死信消息。\n\n\n延时插件\n\n\n进入 rabbitmq 的 docker 容器\n\n\ndocker exec -it mq bash\n\n\n下载插件并上传服务器（下载地址：[https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases][https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases]）\n\n\n# 将下载好的插件拷贝到docker容器中docker cp ./rabbitmq_delayed_message_exchange-3.9.0.ez rabbit:/plugins# 进入RabbitMQ容器docker exec -it rabbit /bin/bash# 启动插件rabbitmq-plugins enable rabbitmq_delayed_message_exchange# 可以通过以下命令查看所有安装过的插件rabbitmq-plugins list# 然后执行 exit 命令退出 docker 容器\n\n\npom 文件引入依赖\n\n\n&lt;dependency&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;  &lt;/dependency&gt;\n\n\n在代码中配置延迟队列\n\n\n@Configuration  public class RabbitMqConfig &#123;        public static final String ORDER_DELAY_KEY = &quot;order_delay&quot;;        /**       * 延时交换机，交换机类型为x-delayed-message       */    @Bean      public CustomExchange customExchange() &#123;          Map&lt;String, Object&gt; args = new HashMap&lt;&gt;();          //延时交换机一定要设置x-delayed-type属性          args.put(&quot;x-delayed-type&quot;, &quot;direct&quot;);          //第二个参数type需要设置成x-delayed-message          return new CustomExchange(&quot;order_delay_exchange&quot;, &quot;x-delayed-message&quot;, true, false, args);      &#125;        /**       * 订单延时队列       *       * @return 延时队列       */      @Bean      public Queue delayOrderQueue() &#123;          return new Queue(&quot;order_delay_queue&quot;, true);      &#125;        /**       * 订单延时队列绑定交换机       *       * @return 延时队列绑定交换机       */      @Bean      public Binding delayOrderBinding() &#123;          return BindingBuilder.bind(delayOrderQueue()).to(customExchange()).with(ORDER_DELAY_KEY).noargs();      &#125;&#125;\n\n\n编写方法向队列发送消息\n\n\n/**   * 发送订单延时消息   * delayTime 延迟的时间 单位是毫秒   *   * @param msg 发送的信息   */  public void sendDelayOrderMessage(Object msg, String routingKey, Long delayTime) &#123;      amqpTemplate.convertAndSend(&quot;order_delay_exchange&quot;, routingKey, msg,              message -&gt; &#123;                  //设置延迟时间                  message.getMessageProperties().setDelay(delayTime.intValue());                  return message;              &#125;);  &#125;\n\n\n监听队列\n\n\n@RabbitListener(queues = &quot;order_delay_queue&quot;)  public void handlerOrderDelayMsg(String msg) &#123;      log.info(&quot;order_delay_queue接收到信息：&quot; + msg);      val jsonObject = JSONUtil.parseObj(msg);    // 逻辑处理 ...&#125;\n消息重试\n添加如下配置实现消息重试：\nspring:    listener:        simple:          retry:            # 开启重试机制            enabled: true            # 最多重试            max-attempts: 10            # 第一次间隔            initial-interval: 3000ms            # 最多间隔时间            max-interval: 86400000ms            # 间隔间乘数            multiplier: 2\n特别注意： 如果在消息接收端的 application.yml 配置文件中没有添加 RabbitMQ 重试机制的相关配置，当接收端收到消息后程序抛出异常，那么发送端将得不到消息确认（ACK），此时发送端将会循环的发送消息，最终导致内存溢出。\nRocketMQ\n基础\nRocketMQ 组成结构图如下 ：\n\n交互过程如下：\n\n\nBrokder 定时发送自身状态 到 NameServer。\n\n\nProducer 请求 NameServer 获取 Broker 的地址。\n\n\nProducer 将消息发送到 Broker 中的消息队列。\n\n\nConsumer 订阅 Broker 中的消息队列，通过拉取消息，或由 Broker 将消息推送至 Consumer。\n\n\n具体介绍：\n\n\nProducer Cluster 消息生产者群\n\n\n\n\n负责发送消息，一般由业务系统负责产生消息。\n\n\n\n\nConsumer Cluster 消息费群\n\n\n\n\n负责消费消息，一般是后台系统负责异步消费。\n\n\n两种消费模式：\n\nPush Consumer，服务端向消费者端推送消息\nPull Consumer，消费者端向服务定时拉取消息\n\n\n\n\n\nNameServer 名称服务器\n\n\n\n\n集群架构中的组织协调员，相当于注册中心，收集 broker 的工作情况，不负责消息的处理\n\n\n\n\nBroker 消息服务器\n\n\n\n\n是 RocketMQ 的核心，负责消息的接受，存储，发送等。\n\n\n需要定时发送自身状态 到 NameServer，默认 10 秒发送一次，超时 2 分钟会认为该 broker 失效。\n\n\n安装\nWindows\n\n\n下载\n\n\n\n下载地址：https://archive.apache.org/dist/rocketmq/\n下载后解压到一个没有空格和中文的目录。并配置安装目录为环境变量。\n\n\n\n启动\n\n\n\nBroker 默认磁盘空间利用率达到 85% 就不再接收，这里在开发环境可以提高磁盘空间利用率报警阀值为 98%。\n\n# 调整默认的内存大小参数（按机器的大小配置）## 编辑runserver.cmd，修改并保存&quot;JAVA_OPT=%JAVA_OPT% ‐server ‐Xms512m ‐Xmx512m ‐Xmn512m ‐XX:MetaspaceSize=128m ‐ XX:MaxMetaspaceSize=320m&quot; # 运行bin/mqnamesrv.cmdcd bin/start mqnamesrv.cmd# 启动broker -n：指定NameServer的地址，运行bin/mqbroker.cmd ‐n 127.0.0.1:9876cd bin/start mqbroker.cmd -n 127.0.0.1:9876 autoCreateTopicEnable=true## 启动失败可以删除 C:/user/用户名/store 这个目录及目录下的所有文件，然后重新执行命令\n\n\n测试\n\n\n# 发送消息cd bin/ set NAMESRV_ADDR=127.0.0.1:9876 tools.cmd org.apache.rocketmq.example.quickstart.Producer# 接收消息set NAMESRV_ADDR=127.0.0.1:9876 tools.cmd org.apache.rocketmq.example.quickstart.Consumer\n\n\n安装管理端\n\n\n\nRocketMQ 提供了 UI 管理工具，名为 rocketmq-console，项目地址：https://github.com/apache/rocketmq-externals/tree/release-rocketmq-console-1.0.0\n\n# 下载源文件，并切换到console分支# 修改配置## 修改rocketmq-console\\src\\main\\resources\\application.propertiesserver.port=9877rocketmq.config.namesrvAddr=127.0.0.1:9876rocketmq.config.dataPath=/tmp/rocketmq-console/data# 打包## 进入目录下mvn clean package ‐Dmaven.test.skip=true# 启动cd /rocketmq-console/targetjava -jar rocketmq-console-ng-1.0.0.jar --server.port=9877 --rocketmq.config.namesrvAddr=127.0.0.1:9876# 访问 http://127.0.0.1:9877\nLinux\n\n由于 RocketMQ 由 Java 编写，基本操作与 Windows 一致，上传包到服务器后解压运行即可（这里只记录部分 Linux 命令）。\n\n# 编辑文件vim runserver.cmd # 文件位置下运行命令（后台运行）nohup java -jar rocketmq-console-ng-1.0.0.jar# 控制台相关tail -100 nohup.outtail -f nohup.out cp /dev/null nohup.out\n基本使用\n三种消息发送方式\n\n\n同步消息（sync message）\nproducer 向 broker 发送消息，执行 API 时同步等待， 直到 broker 服务器返回发送结果 。\n\n\n异步消息（async message）\nproducer 向 broker 发送消息时指定消息发送成功及发送异常的回调方法，调用 API 后立即返回，producer 发送消 息线程不阻塞 ，消息发送成功或失败的回调任务在一个新的线程中执行 。\n\n\n单向消息（oneway message）\nproducer 向 broker 发送消息，执行 API 时直接返回，不等待 broker 服务器的结果 。\n\n\n消息结构\nRocketMQ 的消息包括基础属性和扩展属性两部分：\n\n\n基础属性\n\ntopic： 主题相当于消息的一级分类，具有相同 topic 的消息将发送至该 topic 下的消息队列中，比方说一个电商 系统可以分为商品消息、订单消息、物流消息等，就可以在 broker 中创建商品主题、订单主题等，所有商品的消息发送至该主题下的消息队列中。\n消息体：即消息的内容 ，可以的字符串、对象等类型（可系列化）。消息的最大长度是 4M。\n消息 Flag：消息的一个标记，RocketMQ 不处理，留给业务系统使用。\n\n\n\n扩展属性\n\ntag：相当于消息的二级分类，用于消费消息时进行过滤，可为空 。\nkeys：Message 索引键，在运维中可以根据这些 key 快速检索到消息， 可为空 。\nwaitStoreMsgOK：消息 发送时是否等消息存储完成后再返回 。\n\n\n\nMessage 的基础属性主要包括消息所属主题 topic ， 消息 Flag（RocketMQ 不做处理）、 扩展属性、消息体 。\n生产者工程\n\n\n添加依赖\n\n\n&lt;dependency&gt;      &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;      &lt;artifactId&gt;rocketmq-spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n添加配置\n\n\nrocketmq:  nameServer: 127.0.0.1:9876  producer:    group: PID_PAY_PRODUCER\n\n\n发送同步消息\n\n\n@Service  @Slf4j  public class PayChannelAgentServiceImpl implements PayChannelAgentService &#123;        @Resource      private PayProducer payProducer;        /**       * 调用支付宝手机WAP下单接口       * @param aliConfigParam 支付渠道参数       * @param alipayBean 请求支付参数       * @return       * @throws BusinessException BusinessException       */        @Override      public PaymentResponseDTO createPayOrderByAliWAP(AliConfigParam aliConfigParam, AlipayBean alipayBean) throws BusinessException, UnsupportedEncodingException &#123;          // 拼接支付信息        ...        try &#123;              //发送支付结果查询延迟消息              PaymentResponseDTO&lt;AliConfigParam&gt; notice = new PaymentResponseDTO&lt;AliConfigParam&gt;();              notice.setOutTradeNo(alipayBean.getOutTradeNo());              notice.setContent(aliConfigParam);              notice.setMsg(&quot;ALIPAY_WAP&quot;);              payProducer.payOrderNotice(notice);                // 调用SDK提交表单          &#125; catch (Exception e) &#123;              ...        &#125;      &#125;  &#125;\n\n\n测试（控制台出现 end… 表示消息发送成功。进入管理端，查询消息。）\n\n\n消费者工程\n\n\n配置文件\n\n\nrocketmq:  nameServer: 127.0.0.1:9876\n\n\n消费消息（监听消息队列需要指定 topic 与 consumerGroup）\n\n\n@Slf4j  @Service  @RocketMQMessageListener(topic = &quot;TP_PAYMENT_ORDER&quot;, consumerGroup = &quot;CID_PAYMENT_CONSUMER&quot;)  public class PayConsumer implements RocketMQListener&lt;MessageExt&gt; &#123;      @Resource      private PayChannelAgentService payAgentService;      @Override      public void onMessage(MessageExt messageExt) &#123;          log.info(&quot;开始消费支付结果查询消息:&#123;&#125;&quot;, messageExt);          // 取出消息内容          String body = new String(messageExt.getBody(), StandardCharsets.UTF_8);          PaymentResponseDTO response = JSON.parseObject(body, PaymentResponseDTO.class);          String outTradeNo = response.getOutTradeNo();          String msg = response.getMsg();          String param = String.valueOf(response.getContent());          AliConfigParam aliConfigParam = JSON.parseObject(param, AliConfigParam.class);          // 判断是支付宝还是微信          PaymentResponseDTO result = new PaymentResponseDTO();          if (&quot;ALIPAY_WAP&quot;.equals(msg)) &#123;              // 查询支付宝支付结果              result = payAgentService.queryPayOrderByAli(aliConfigParam, outTradeNo);              //不管支付成功还是失败都需要发送支付结果消息              ...        &#125; else if (&quot;WX_JSAPI&quot;.equals(msg)) &#123;              // 查询微信支付结果              ...        &#125;            //返回查询获得的支付状态          if (TradeStatus.UNKNOWN.equals(result.getTradeState()) || TradeStatus.USERPAYING.equals(result.getTradeState())) &#123;          // 在支付状态未知或支付中，抛出异常会重新消息此消息              log.info(&quot;支付代理‐‐‐支付状态未知，等待重试&quot;);              throw new RuntimeException(&quot;支付状态未知，等待重试&quot;);          &#125;      &#125;  &#125;\n消息发送过程\n\n消息发送流程如下：\n\n\nProducer 从 NameServer 中获取主题路由信息\nBroker 将自己的状态上报给 NameServer，NameServer 中存储了每个 Broker 及主题、消息队列的信息。\nProducer 根据 topic 从 NameServer 查询所有消息队列，查询到的结果例如：\n\n\n[   &#123;&quot;brokerName&quot;:&quot;Broker‐1&quot;,&quot;queueId&quot;:0&#125;,   &#123;&quot;brokerName&quot;:&quot;Broker‐1&quot;,&quot;queueId&quot;:1&#125;,   &#123;&quot;brokerName&quot;:&quot;Broker‐2&quot;,&quot;queueId&quot;:0&#125;,   &#123;&quot;brokerName&quot;:&quot;Broker‐2&quot;,&quot;queueId&quot;:1&#125; ]\nProducer 按选择算法从以上队列中选择一个进行消息发送，如果发送消息失败则在下次选择的时候 会规避掉失败的 broker。\n\n\n构建消息，发送消息发送消息前进行校验，比如消息的内容长度不能为 0、消息最大长度、消息必要的属性是否具备等（topic、消息体，生产组等）。如果该 topic 下还没有队列则自动创建，默认一个 topic 下自动创建 4 个写队列，4 个读队列 。\n\n\n为什么要多个队列？\n\n\n高可用：当某个队列不可用时其它队列顶上。\n\n\n提高并发：发送消息是选择队列进行发送，提高发送消息的并发能力。 消息消费时每个消费者可以监听多个队列，提高消费消息的并发能力。\n生产组有什么用？\n在事务消息中 broker 需要回查 producer，同一个生产组的 producer 组成一个集群，提高并发能力。\n\n\n\n\n监听队列，消费消息一个消费组可以包括多个消费者，一个消费组可以订阅多个主题。一个队列同时只允许一个消费者消费，一个消费者可以消费多个队列中的消息。消费组有两种消费模式：\n\n集群模式：一个消费组内的消费者组成一个集群，主题下的一条消息只能被一个消费者消费。\n广播模式：主题下的一条消息能被消费组下的所有消费者消费。消费者和 broker 之间通过推模式和拉模式接收消息，推模式即 broker 推送给消费者，拉模式是消费者主动从 broker 查询消息。\n\n\n\n三种消息发送方式\n同步消息\n见基本使用的例子。\n异步消息\nproducer 向 broker 发送消息时指定消息发送成功及发送异常的回调方法，调用 API 后立即返回，producer 发送消 息线程不阻塞 ，消息发送成功或失败的回调任务在一个新的线程中执行 。\n/**   * 发送异步消息   * @param topic   * @param msg   */  public void sendASyncMsg(String topic, String msg)&#123;      rocketMQTemplate.asyncSend(topic,msg,new SendCallback() &#123;          @Override          public void onSuccess(SendResult sendResult) &#123;              // 成功回调              System.out.println(sendResult.getSendStatus());          &#125;          @Override          public void onException(Throwable e) &#123;              // 异常回调              System.out.println(e.getMessage());          &#125;      &#125;);  &#125;// 测试@Test  public void testSendASyncMsg() throws InterruptedException &#123;      this.producerSimple.sendASyncMsg(&quot;my‐topic&quot;, &quot;第一条异步步消息&quot;);      System.out.println(&quot;end...&quot;);      // 异步消息，为跟踪回调线程这里加入延迟      Thread.sleep(3000);  &#125;\n单向消息\nproducer 向 broker 发送消息，执行 API 时直接返回，不等待 broker 服务器的结果 。\n/**   * 发送单向消息   * @param topic   * @param msg   */  public void sendOneWayMsg(String topic, String msg)&#123;      this.rocketMQTemplate.sendOneWay(topic,msg);  &#125;\n自定义消息格式\n\n\n使用 String 传递数据\n\n\n// 生产端public void sendMsgByJson(String topic, OrderExt orderExt) &#123;      // 发送同步消息，消息内容将orderExt转为json      this.rocketMQTemplate.convertAndSend(topic, orderExt);      System.out.printf(&quot;send msg : %s&quot;, orderExt);  &#125;// 消费端：使用 JSON 工具将字符串转为对象@Component  @RocketMQMessageListener(topic = &quot;my‐topic&quot;, consumerGroup = &quot;demo‐consumer‐group&quot;)  public class ConsumerSimple implements RocketMQListener&lt;String&gt; &#123;      //接手到消息调用此方法      @Override      public void onMessage(String s) &#123;          // 如果是json数据，可以将json转为对象          // OrderExt orderExt = JSON.parseObject(s, OrderExt.class);          System.out.println(s);      &#125;  &#125;\n\n\n使用对象接收数据\n\n\n@Component  @RocketMQMessageListener(topic = &quot;my‐topic‐obj&quot;, consumerGroup = &quot;demo‐consumer‐group‐obj&quot;)  // RocketMQListener 泛型指定要转换的对象类型public class ConsumerSimpleObj implements RocketMQListener&lt;OrderExt&gt; &#123;      // 接手到消息调用此方法      @Override      public void onMessage(OrderExt orderExt) &#123;          System.out.println(orderExt);      &#125;  &#125;\n延迟消息\n\nRocketMQ 的延迟消息实现非常简单，只需要发送消息前设置延迟的时间，延迟时间存在十八个等级 （1s/5s/10s/30s/1m/2m/3m/4m/5m/6m/7m/8m/9m/10m/20m/30m/1h/2h），调用 setDelayTimeLevel() 设置与时间相对应的延迟级别即可。\n\n\n\n同步消息延迟\n\n\n// 生产端/**   * 发送延迟消息   * 消息内容为json格式   */  public void sendMsgByJsonDelay(String topic, OrderExt orderExt) throws JsonProcessingException, InterruptedException, RemotingException, MQClientException, MQBrokerException &#123;      // 发送同步消息，消息内容将orderExt转为json      Message&lt;OrderExt&gt; message = MessageBuilder.withPayload(orderExt).build();      // 指定发送超时时间（毫秒）和延迟等级      this.rocketMQTemplate.syncSend(topic, message, 1000, 3);      System.out.printf(&quot;send msg : %s&quot;, orderExt);  &#125;\n\n\n异步消息延迟\n\n\n/**   * 发送异步延迟消息   * 消息内容为json格式   */  public void sendAsyncMsgByJsonDelay(String topic, OrderExt orderExt) throws JsonProcessingException, InterruptedException, RemotingException, MQClientException, MQBrokerException &#123;      // 消息内容将orderExt转为json      String json = this.rocketMQTemplate.getObjectMapper().writeValueAsString(orderExt);      org.apache.rocketmq.common.message.Message message = new org.apache.rocketmq.common.message.Message(topic, json.getBytes(Charset.forName(&quot;utf‐8&quot;)));      // 设置延迟等级      message.setDelayTimeLevel(3);      // 发送异步消息      this.rocketMQTemplate.getProducer().send(message, new SendCallback() &#123;          @Override          public void onSuccess(SendResult sendResult) &#123;              System.out.println(sendResult);          &#125;            @Override          public void onException(Throwable throwable) &#123;              System.out.println(throwable.getMessage());          &#125;      &#125;);      System.out.printf(&quot;send msg : %s&quot;, orderExt);  &#125;\n消费重试\n当消息发送到 Broker 成功，在被消费者消费时如果消费者没有正常消费，此时消息会重试消费。消费重试存在两种场景：\n\n\n消息没有被消费者接收，比如消费者与 broker 存在网络异常。此种情况消息会一直被消费重试。\n\n\n当消息已经被消费者成功接收，但是在进行消息处理时出现异常，消费端无法向 Broker 返回成功，这种情况下 RocketMQ 会不断重试。borker 是怎么知道重试呢？ 消费者在消费消息成功会向 broker 返回成功状态，否则会不断进行消费重试。\n\n\n处理策略\n\n消息会按照延迟消息的延迟时间等级（1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h）从第 3 级开始重试，每试一次如果还不成功则延迟等级加 1。重试了 16 次还未被成功消费将会投递到死信队列，到达死信队列的消息将不再被消费。\n\n实际生产中不会让消息重试这么多次，通常在重试一定的次数后将消息写入数据库，由另外单独的程序或人工去处理。\npublic class ConsumerSimple implements RocketMQListener&lt;MessageExt&gt; &#123;      @Override      public void onMessage(MessageExt messageExt) &#123;          // 取出当前重试次数          int reconsumeTimes = messageExt.getReconsumeTimes();          // 当大于一定的次数后将消息写入数据库，由单独的程序或人工去处理          if (reconsumeTimes &gt;= 2) &#123;              // 将消息写入数据库，之后正常返回              return;          &#125;          throw new RuntimeException(String.format(&quot;第%s次处理失败..&quot;, reconsumeTimes));      &#125;  &#125;\nKafka\n基础\nKafka 是一个分布式的基于开发/订阅模式的消息队列（Message Queue），主要应用于大数据实时处理领域。\n\n","categories":["后端项目","准备工作"],"tags":["Java","RocketMQ","RabbitMQ","Kafka"]},{"title":"面试-并发🤕","url":"/posts/40294c75/","content":"\n\n前言\n❗表示必掌握，❔表示基本不会问\n\n\n更新\n\n\n24-06-03 初始记录24-06-04 AQS24-06-05 线程池24-06-06 高并发24-06-10 总结24-06-21 补充部分知识\n\n高并发（锁）\n❗Java 内存模型的理解\n大白话：Java 的对象都是处于主内存之中，而线程拥有自己的工作内存（CPU 级别的缓存）。操作过程，1) 线程把主内存中的数据读出 read，2) 线程把值加载到工作内存中 load，3) 线程使用这个值 use，4) 线程把算好的值设置到工作内存 assign，5) 把值存入 store，6) 写入主内存 write。如果有两个线程，会同时操作，即并发（操作结果可能只有一次的结果）。\n\n首先，JAVA 内存模型是指 JMM，而不是指内存结构，内存结构是在物理上的区域划分，而 JMM 则是抽象概念上的划分。\nJMM（内存模型）主要包括两块：主内存+工作内存。\n主内存：多个线程间通信的共享内存称之为主内存，即，数据是多个线程共享的，在物理内存结构上通常对应“堆”中的线程共享数据。\n工作内存：多个线程各自对应自己的本地内存，即，数据只属于该线程自己的，在物理内存结构上通常对应“本地方法栈”中的线程私有数据。\nJava 内存模型规定了所有的变量都存储在主内存 (Main Memory) 中，每条线程还有自己的工作内存 (Working Memory)，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作 (读取、赋值等) 都必须在工作内存中进行，而不能直接读写主内存中的变量，不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值得传递均需要通过主内存来实现。\n\n❗Java 内存模型中的原子性、有序性、可见性\n可见性：一个线程操作完，另一个线程必须读取操作后的数据。\n原子性：同时只有一个线程能操作。（不加操作默认情况下就是没有原子性的）\n\n\nJava 中的简单赋值操作（比如 int i=0）是原子性的，但是复杂的比如 i++ 是不能保证的。\n\n\n特例：32 位虚拟机的 long/double 类型的变量的简单赋值写操作，不是原子的\n\n为什么？ 因为 long/double 是 64 位的，高低 32 位由两个线程操作，可能会赋值错误。\n加上 volatile long/double 可以保障是原子的。（volatile 只有这里展示了原子性）\n\n\n\n有序性：编译之后，可能会指令重排。如果具备有序性，就不会发生指令重排。\n有哪些操作在 Java 规范中不能保障原子性？\n\n\n比如：i = x * y。需要先把 x 和 y 分别从主内存加载到工作内存里，然后再从工作内存里加载出来执行计算，计算后的结果再写回到工作内存里，最后还要从工作内存里把 i 的最新的值刷回主内存。\n\n\n有复杂的代码逻辑的操作不是原子的。解决：加锁，对对象加锁。\n\n\n可见性的硬件级别的说明\n每个处理器都有自己的寄存器。多个处理器各自运行一个线程的时候，导致某个变量放到寄存器里，其他线程无法看到。（第一个问题）\n处理器运行的线程对变量的写操作都是针对写缓冲来的，并不是直接更新主内存，导致一个线程更新了变量，但是仅仅在写缓冲器里面。（第二个问题）\n每个处理器有个自己的高速缓存，需要把数据写到高速缓存/主内存，但是其他处理器还是从自己的高速缓存读取数据。（第三个问题）\n❗从 Java 底层角度聊聊 volatile 关键字的原理\n\nvolatile 关键字与可见性的关系\n\nvolatile 关键字是用来解决可见性和有序性。给数据加上 volatile 关键字，在线程更新数据时，会把其他线程内缓存的数据值失效，这时其他线程会强制重新从主内存加载数据值（变成新的缓存）。\n在很多开源中间件系统中，大量使用 volatile。例子：在 main 方法中，会有一段逻辑，如果主线程在执行，不可以后台退出（这里的执行状态用一个值表示，根据值判断系统是否在运行）。如果提供了一个方法，需要关闭主线程，如果不加 volatile 关键字，其他线程更新状态，主线程没有同步，就会出问题。（这个类似的用法会在多处使用）\n❗指令重排以及 happens-before 原则\n\nvolatile 关键字与有序性的关系、连带问题\n\n❔happens-before 原则：\n\n\n程序次序规则：一个线程内，代码按写的顺序执行\n\n\n锁定规则：一个 unLock 操作先行与后一个 Lock 的操作（先解锁，后加锁）\n\n\nvolatile 变量规则：加了 volatile 关键字，写操作先，读操作后\n\n\n传递规则：如果 A 先于 B，B 先于 C，那么 A 一定先于 C\n\n\n线程启动规则：线程的启动 start() 方法先于此线程的每个操作\n\n\n线程中断规则：对线程的 interrupt() 调用，先于检测到终端的发生\n\n\n线程终结规则：线程的所有操作都先于线程的终止检测操作\n\n\n对象终结规则：对象的初始化在 finalize() 之前\n\n\n这个规则制定了在特殊情况下，不允许指令重排。而因为这个规则，volatile 关键字有一定的防止指令重排的效果（只能先写后读）。\n同时，volatile 关键字本身，就有其他避免指令重排的规则（就是底层。。。最好不要问这个，谁记得住啊）。\n❗volatile 底层是如何基于内存屏障保证可见性和有序性的\nvolatile 不能保证原子性。（只能加锁 synchronized、lock）。\nvolatile 保证可见性：对于 volatile 修饰的变量，执行写操作，JVM 会发送一条 lock 前缀指令给 CPU，CPU 在计算完之后将值强制刷回主内存。其他线程有一个嗅探机制（MESI 缓存一致性协议），会去失效线程内的缓存。\nvolatile 保证有序性：加入内存屏障，可以禁止指令重排。\n\n对于 volatile 修改变量的读写操作，都会加入内存屏障。每个 volatile 写操作前面，加 StoreStore 屏障，禁止上面的普通写和他重排；每个 volatile 写操作后面，加 StoreLoad 屏障，禁止跟下面的 volatile 读/写重排。每个 volatile 读操作后面，加 LoadLoad 屏障，禁止下面的普通读和 voaltile 读重排；每个 volatile 读操作后面，加 LoadStore 屏障，禁止下面的普通写和 volatile 读重排。\n\nsynchronized 为什么又叫内置锁？\nsynchronized 是内置于 JDK 中的，底层实现是 native，由 C/C++ 语言实现；同时，加锁、解锁都是 JDK 自动完成，不需要用户显示控制，非常方便。\n❗说说 synchronized 关键字的底层原理\n因为 synchronized 可以同时保证原子性、可见性和有序性，所以在并发编程中经常会用到他，synchronized 主要有三种用法：修饰实例方法、修饰静态方法、修饰代码块。\nsynchronized 修饰代码块时，JVM 采用 monitorenter 、monitorexit 两个指令来实现同步，monitorenter 指令指向同步代码块的开始位置， monitorexit 指令则指向同步代码块的结束位置。\nsynchronized 修饰同步方法时，JVM 采用 ACC_SYNCHRONIZED 标记符来实现同步，这个标记了该方法是一个同步方法。\n❗大白话（修饰代码块）：每个对象实例都会关联一个 monitor，一个类的 class 对象也会关联一个 monitor。一个线程过来，把 monitor 置 1（可以重复加锁，二次加 monitor 变成 2、3…）。当线程走出 synchronized，执行 monitorexit，底层获取对应的 monitor 进行释放。线程 2 加锁失败，陷入一个阻塞等待的状态。\nSyncrhronized 怎么保证可见性？\nJMM 中使用 happens-before 语义：\n\n\n线程解锁前，必须把共享变量的最新值刷新到主内存中。\n\n\n线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新获取最新的值。（注意：加锁与解锁需要是同一把锁）\n\n\nSynchronized 怎么保证原子性？\n为什么会有两个 monitorexit 呢？\n这个主要是防止在同步代码块中线程因异常退出，而锁没有得到释放，这必然会造成死锁（等待的线程永远获取不到锁）。因此最后一个 monitorexit 是保证在异常情况下，锁也可以得到释放，避免死锁，它由编译器自动产生的一个异常处理器来执行。\nSynchronized 可重入的原理\n重入锁是指一个线程获取到该锁之后，该线程可以继续获得该锁，且不再被阻塞。底层原理维护一个计数器，当线程获取该锁时，计数器加一，再次获得该锁时继续加一，释放锁时，计数器减一，当计数器值为 0 时，表明该锁未被任何线程所持有，其它线程可以竞争获取锁。\nSynchronized 怎么保证有序性？\n首先，Synchronized 保证有序性，但不表示他能禁止指令重排。\n而之所以会有序性问题，是因为硬件层面做了很多优化，比如处理器做强化和指令重排等，这些技术引入会导致有序性问题。这有序性问题主要出在多线程中，因为单线程中是遵循 JMM 的 as-if-serial 语义的，能保证数据间的依赖关系的，比如 A 依赖于 B，B 依赖于 C，那 A 的实现之前，必须会先执行 C。as-if-serial 语义的意思是：不管怎么重排序，单线程程序的执行结果不能被改变。编译器、runtime 和处理器都必须遵守 as-if-serial 语义。\n但是多线程就可能因为指令重排导致在另一个线程中先执行到了 C，多线程程序的语义就被重排序破坏了！Synchronized 同步代码块可以锁住当前线程，这样每个线程单独执行，就可以保证有序性了。\nSynchronized 和监视器（monitor）有什么关系？为什么 Synchronized 可以使用任意对象？\n首先，每个对象都可以被认为是一个“监视器 monitor”，这个监视器由三部分组成：独占锁、入口队列，等待队列。\n注意：一个对象只能有一个独占锁，但是任意线程都可以拥有这个独占锁（说白了，独占锁就是一个标记）。\nSynchronized 需要获取对象锁，实际上就是获取的是对象中的独占锁，通过这个标记来判断是否已有线程进入占用（所以 synchronized 无论使用什么对象都可以，每个对象在堆中都有独占锁）。\n而入口队列中放的则是要竞争锁资源的其他线程，如果线程使用了 wait 方法，则进入对象的等待列队中。\nSynchronized 中的锁中什么是重量锁（对象锁），自旋锁，自适应自旋锁，轻量锁，偏向锁，锁消除，锁粗化？\n线程的阻塞和唤醒需要 CPU 从用户态转为核心态，频繁的阻塞和唤醒对 CPU 来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。同时我们发现在许多应用上面，对象锁的锁状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的，所以引入自旋锁。\n就是等待锁的线程并不进入阻塞状态，而是执行一个无意义的循环。在循环结束后查看锁是否已经被释放，若已经释放则直接进入执行状态。因为长时间无意义循环也会大量浪费系统资源，因此自旋锁适用于间隔时间短的加锁场景。\n自适应自旋锁：\n\n\n自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。\n\n\n偏向锁：\n\n\n偏向于第一个获得它的线程。当线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程 ID，以后该线程在进入和退出同步块时不需要进行 CAS 加锁和解锁操作。适用于只有 1 个线程的情况。无法代替重量锁。\n\n\n轻量锁：\n\n\n如果有第二线程过来竞争，则从偏向锁升级为轻量锁，线程尝试使用 CAS 将对象头中的 Mark Word 替换为指向锁记录的指针。如果成功，当前线程获得锁。适用于只有 2 个线程情况。无法代替重量锁。\n\n\n重量锁：\n\n\n当有 3 个及以上的线程竞争时，升级为重量锁，获得锁的执行，没获得锁的阻塞挂起，直到持有锁的线程执行完同步块唤醒它们。重量级锁通过对象内部的监视器（monitor）实现，其中 monitor 的本质是依赖于底层操作系统的实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。\n\n\n锁消除：\n\n\nJVM 检测到不可能存在共享数据竞争，这时 JVM 会对这些同步锁进行锁消除。比如一个方法中使用变量是属于自己方法中的，那么这个变量是只属于该线程自己的，其他线程抢不走，这时候这个方法中的变量就没必要加锁了。锁消除的依据是逃逸分析（底层判断该数据是否有被全局引用或者程序指向无法被访问到的地方等）的数据支持。\n\n\n锁粗化：\n\n\n锁粗化就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。如上面实例：vector 每次 add 的时候都需要加锁操作，JVM 检测到对同一个对象（vector）连续加锁、解锁操作，会合并一个更大范围的加锁、解锁操作，即加锁解锁操作会移到 for 循环之外。\n\n\n多线程中 synchronized 锁升级的原理是什么？\n偏向所锁，轻量级锁都是乐观锁，重量级锁是悲观锁。\n一个对象刚开始实例化的时候，没有任何线程来访问它的时候。它是可偏向的，意味着，它现在认为只可能有一个线程来访问它，所以当第一个线程来访问它的时候，它会偏向这个线程，此时，对象持有偏向锁。偏向第一个线程，这个线程在修改对象头成为偏向锁的时候使用 CAS 操作，并将对象头中的 ThreadID 改成自己的 ID，之后再次访问这个对象时，只需要对比 ID，不需要再使用 CAS 在进行操作。\n一旦有第二个线程访问这个对象，因为偏向锁不会主动释放，所以第二个线程可以看到对象的偏向状态，这时表明在这个对象上已经存在竞争了，检查原来持有该对象锁的线程是否依然存活，如果挂了，则可以将对象变为无锁状态，然后重新偏向新的线程，如果原来的线程依然存活，则马上执行那个线程的操作栈，检查该对象的使用情况，如果仍然需要持有偏向锁，则偏向锁升级为轻量级锁，（偏向锁就是这个时候升级为轻量级锁的）。如果不存在使用了，则可以将对象回复成无锁状态，然后重新偏向。\n轻量级锁认为竞争存在，但是竞争的程度很轻，一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。 但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止 CPU 空转。\nSynchronized 锁只会自动升级，不会降级（ReentrantReadWriteLock 读写锁可以降级）。\nsynchronized 和 volatile 的区别是什么？\nsynchronized 表示只有一个线程可以获取作用对象的锁，执行代码，阻塞其他线程。\nvolatile 表示变量在 CPU 的寄存器中是不确定的，必须从主存中读取。保证多线程环境下变量的可见性；禁止指令重排序。\n区别：\n\n\nvolatile 是变量修饰符；synchronized 可以修饰类、方法、变量。\n\n\nvolatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。\n\n\nvolatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。\n\n\nvolatile 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化。\n\n\n❗对 CAS 的理解及其底层实现原理\nCAS 叫做比较并交换，CAS 指令包含 3 个参数：新值，旧值，内存值（内存位置），线程会先获取内存值，然后复制到变量副本，生成旧值，旧值在一系列操作后生成新值。\n若旧值=内存值，说明没有被其他线程抢先占有，则修改内存值为新值；\n若旧值≠内存值，说明内存值已经被其他线程修改，则自旋获取新的内存值，然后重新操作。\n大白话：比如说使用 synchronized 对于代码块进行加锁，这个时候多个线程的执行是串行的。比如一个累加的计数器，优化可以把 int 类型的累加字段改成AtomicInteger类型（原子类），方法改为 incrementAndGet，此时不用 synchronized 也是线程安全的。这个原子类底层就是 CAS（Compare and Set）。在线程执行 incrementAndGet 时，会先读取，再尝试设置：当一个线程成功执行 CAS 操作（就是对比旧值是否是原来的值），另一个就会失败，失败就会重新读取，再次设置。\n❗CAS 会出现经典的 ABA 问题\n原因：第一个线程刚获得 A，第二个线程就抢走也获得 A，然后改成 B 后又改成 A，这时候第一个线程发现变量是 A，就继续执行。但是这样会出现潜藏的问题，比如修改的是金额，存一笔和存两笔是两个概念。\n解决：加入版本号解决。\n❗对 JDK 中的 AQS 的理解，AQS 的实现原理\n多线程访问数据除了 synchronized，CAS，ConcurrentHashMap，还有 Lock。ReentrantLock 的底层就是 AQS（Abstract Queue Synchronizer）。\nReentrantLock lock = new ReentrantLock(); // 默认使用非公平锁// 传入参数true，就使用公平锁ReentrantLock lock = new ReentrantLock(true);lock.lock();look.unlock();\n大白话：AQS 底层有个 state，多个线程执行 CAS 更新 state；还有一个变量记录加锁线程。AQS 中会有一个等待队列的概念。当前一个线程释放了锁，会去唤醒等待队列中的队首元素。\n非公平锁：在唤醒等待队列的过程中，如果有另一个线程抢占锁，是可以成功的。\n公平锁：在唤醒等待队列的过程中，如果需要抢占锁，需要加入到等待队列内，进行等待。\nReetrantReadWriteLock 读写锁和 RenntrantLock 有什么区别？\nReentrantLock 有一定的局限性，它的读锁与读锁间也会互斥，但读数据并不会改动数据，没有必要加锁保护，这就降低了程序的性能。\n因以上问题，诞生了读写锁，读写锁一种读写分离技术，它的读锁是共享的，写锁是独占的，也就是说，多个线程是可以一起读数据的，只有写数据的时候，才会同步线程。\n读写锁 ReentrantReadWriteLock 有什么特点？\n\n\n公平性可以选择：支持非公平 (默认) 和公平的锁获取，吞吐量非公平优于公平。\n\n\n重进入：读锁和写锁都支持线程重进入。\n\n\n锁降级：获取写锁，再获取读锁，然后释放写锁，这样写锁就降级为了读锁。（注：Synchronized 是不能进行锁降级的，意义不一样）。\n\n\nReentrantLock 与 Synchronized 的区别\n\n\n二者的本质区别：synchronized 是关键字，ReentrantLock 是一个类 相同点：这两个都是可重入锁。\n\n\nReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁\n\n\nReentrantLock 只适用于代码块锁，而 synchronized 可以修饰类、方法、变量等。\n\n\n什么是死锁？\nA 需要 B 解锁，B 需要 A 解锁，两个都在中间互相等待，却谁也无法满足条件，从而发生阻塞，就是死锁。\n怎么防止死锁？\n\n\n不要写嵌套锁，容易死锁；\n\n\n尽量少用同步代码块 (Synchronized);\n\n\n尽量使用 ReentrantLock 的 tryLock 方法设置超时时间，超时可以退出，防止死锁；\n\n\n尽量降低锁粒度，尽量不要几个功能一把锁；\n\n\n尽量使用 JUC 包；\n\n\n❗ConcurrentHashMap 实现线程安全的底层原理\nJDK1.8 以前，多个数组，分段加锁，一个数组一个锁。他将一个大的 ConcurrentHashMap 分成 16 个小的 Segment。也就是说可以同时承受 16 个线程的并发。\nJDK1.8 以后，数组里每个元素进行 put 操作，都是有一个不同的锁，对当个位置进行 put 操作时，采取的是 CAS 的策略。如果 CAS 操作失败，就使用 synchronized 对这个位置的对象进行锁定，然后基于链表或红黑树，对数组元素进行写入。\n多线程\n❗创建线程的 4 种方法\n\n\n继承 Thread 类。通过继承 Thread 类，并重写它的 run 方法，我们就可以创建一个线程。\n\n\n\n\n首先定义一个类来继承 Thread 类，重写 run 方法。\n\n\n然后创建这个子类对象，并调用 start 方法启动线程。\n\n\npublic class MyThread extends Thread &#123;      private int count = 5;        /**       * 重写父类中的run()， 执行具体的业务逻辑       */      @Override      public void run() &#123;          count--;          System.out.println(count);      &#125;        public static void main(String[] args) &#123;          //1. 创建线程对象的实例， 该对象必须继承Thread类及重写了run()          MyThread my = new MyThread();            //2. 创建多个线程的实例， 进入线程的初始化状态          Thread t1 = new Thread(my);          Thread t2 = new Thread(my);          Thread t3 = new Thread(my);          /*3. 启动线程， 线程只有执行start()之后才算是真正的启动, 才会执行run()方法里面的具体逻辑           线程启动后会进入线程的就绪状态，等待CPU的调用*/          t1.start();          t2.start();          t3.start();      &#125;  &#125;\n\n\n实现 Runnable 接口。通过实现 Runnable ，并实现 run 方法，也可以创建一个线程。\n\n\n\n\n首先定义一个类实现 Runnable 接口，并实现 run 方法。\n\n\n然后创建 Runnable 实现类对象，并把它作为 target 传入 Thread 的构造函数中\n\n\n最后调用 start 方法启动线程。\n\n\npublic class RunnableThread implements Runnable &#123;      @Override      public void run() &#123;          System.out.println(&quot;thread run ......&quot;);      &#125;        public static void main(String[] args) &#123;          new Thread(new RunnableThread()).run();      &#125;  &#125;\n\n\n实现 Callable 接口，并结合 Future 实现\n\n\n\n\n首先定义一个 Callable 的实现类，并实现 call 方法。call 方法是带返回值的。\n\n\n然后通过 FutureTask 的构造方法，把这个 Callable 实现类传进去。\n\n\n把 FutureTask 作为 Thread 类的 target ，创建 Thread 线程对象。\n\n\n通过 FutureTask 的 get 方法获取线程的执行结果。\n\n\npublic class TestFuture &#123;      public static void main(String[] args) throws ExecutionException, InterruptedException &#123;         FutureTask futureTask = new FutureTask&lt;&gt;(new CallableThread());          new Thread(futureTask).start();          Object o = futureTask.get();          System.out.println(o);      &#125;  &#125;    class CallableThread implements Callable &#123;      @Override      public Object call() throws Exception &#123;          System.out.println(&quot;call一下&quot;);          return 1;      &#125;  &#125;\n\n\n通过线程池创建线程此处用 JDK 自带的 Executors 来创建线程池对象。\n\n\n\n\n首先，定一个 Runnable 的实现类，重写 run 方法。\n\n\n然后创建一个拥有固定线程数的线程池。\n\n\n最后通过 ExecutorService 对象的 execute 方法（这个方法接收一个 Runnable 实例）传入线程对象。\n\n\npublic class ExecutorThread implements Runnable&#123;      @Override      public void run() &#123;          System.out.println(&quot;run一下&quot;);      &#125;        public static void main(String[] args) &#123;          ExecutorService executorService = Executors.newFixedThreadPool(10);          executorService.execute(new ExecutorThread());          executorService.shutdown();      &#125;  &#125;\n说一下 Runnable 和 Callable 有什么区别？\n相同点：\n\n\n都是接口\n\n\n都可以编写多线程程序\n\n\n都采用 Thread.start() 启动线程\n\n\n主要区别：\n\n\nRunnable 接口 run 方法无返回值；Callable 接口 call 方法有返回值，是个泛型，和 Future、FutureTask 配合可以用来获取异步执行的结果。\n\n\nRunnable 接口 run 方法只能抛出运行时异常，且无法捕获处理；Callable 接口 call 方法允许抛出异常，可以获取异常信息。\n\n\n注：Callalbe 接口支持返回执行结果，需要调用 FutureTask.get() 得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。\n线程的 run() 和 start() 有什么区别？\n每个线程都是通过某个特定 Thread 对象所对应的方法 run() 来完成其操作的，run() 方法称为线程体。通过调用 Thread 类的 start() 方法来启动一个线程。\nstart() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。\nstart() 方法来启动一个线程，真正实现了多线程运行。调用 start() 方法无需等待 run 方法体代码执行完毕，可以直接继续执行其他的代码； 此时线程是处于就绪状态，并没有运行。 然后通过此 Thread 类调用方法 run() 来完成其运行状态， run() 方法运行结束， 此线程终止。然后 CPU 再调度其它线程。\nrun() 方法是在本线程里的，只是线程里的一个函数，而不是多线程的。 如果直接调用 run()，其实就相当于是调用了一个普通函数而已，直接调用 run() 方法必须等待 run() 方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用 start() 方法而不是 run() 方法。\n为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？\nnew 一个 Thread，线程进入了新建状态。调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。\n而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。\n总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。\nstart() 方法为什么能开启多线程？\n真正实现开启多线程的是 start() 方法中的 start0() 方法。\n调用 start0() 方法后，该线程并不一定会立马执行，只是将线程变成了可运行状态（NEW —&gt; RUNNABLE）；具体什么时候执行，取决于 CPU ，由 CPU 统一调度；我们又知道 Java 是跨平台的，可以在不同系统上运行，每个系统的 CPU 调度算法不一样，所以就需要做不同的处理，这件事情就只能交给 JVM 来实现了，start0() 方法自然就表标记成了 native。\n线程的 6 种状态是什么？\n\n\n新建状态（new）：创建线程对象。\n\n\n就绪状态（runnable）：start 方法。\n\n\n阻塞状态（blocked）：无法获得锁对象（线程没抢到）。\n\n\n等待状态（waiting）：wait 方法。\n\n\n计时状态（timed_waiting）：sleep 方法。\n\n\n死亡状态（terminated）：全部代码运行完毕。\n\n\n线程的调度模式是什么？\n分时调度：轮流获取 CPU 使用权。\n抢占式调度：优先级高的线程占用 CPU。\n请说出与线程同步以及线程调度相关的方法\n\n\nwait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；\n\n\nsleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理 InterruptedException 异常；\n\n\nnotify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关；\n\n\nnotityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；\n\n\nsleep() 和 wait() 有什么区别？\n相同点：两者都可以暂停线程的执行。\n不同点：\n\n\nsleep 方法，不会释放资源（本质是占用线程），如果占具锁资源，则其他线程不可进；wait 方法会释放锁资源，即其他线程可进来。\n\n\nwait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用 wait(long timeout) 超时后线程会自动苏醒。\n\n\nJava 中你怎样唤醒一个阻塞的线程？\n首先 ，wait()、notify() 方法是针对对象的，调用任意对象的 wait() 方法都将导致线程阻塞，阻塞的同时也将释放该对象的锁，相应地，调用任意对象的 notify() 方法则将随机解除该对象阻塞的线程，但它需要重新获取该对象的锁，直到获取成功才能往下执行；\n其次，wait、notify 方法必须在 synchronized 块或方法中被调用，并且要保证同步块或方法的锁对象与调用 wait、notify 方法的对象是同一个，如此一来在调用 wait 之前当前线程就已经成功获取某对象的锁，执行 wait 阻塞后当前线程就将之前获取的对象锁释放。\nnotify() 和 notifyAll() 有什么区别？\n如果线程调用了对象的 wait() 方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。\nnotifyAll() 会唤醒所有的线程，notify() 只会唤醒一个线程。\nnotifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify() 只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。\n为什么 wait(), notify() 和 notifyAll() 必须在同步方法或者同步块中被调用？\n这是 JDK 强制的，wait() 方法和 notify()/notifyAll() 方法在调用前都必须先获得对象的锁，也就是 synchronized 对象锁。\nJava 线程数过多会造成什么异常？\n\n\n线程的生命周期开销非常高\n\n\n消耗过多的 CPU 资源如果可运行的线程数量多于可用处理器的数量，那么有线程将会被闲置。大量空闲的线程会占用许多内存，给垃圾回收器带来压力，而且大量的线程在竞争 CPU 资源时还将产生其他性能的开销。\n\n\n降低稳定性。JVM 在可创建线程的数量上存在一个限制，这个限制值将随着平台的不同而不同，并且承受着多个因素制约，包括 JVM 的启动参数、Thread 构造函数中请求栈的大小，以及底层操作系统对线程的限制等。如果破坏了这些限制，那么可能抛出 OutOfMemoryError 异常。\n\n\nThreadLocal\nThreadlocal 是一个线程内部的存储类，提供了线程内存储变量的能力,可以在指定线程内存储数据，数据存储以后，只有指定线程可以得到存储数据。这些变量不同之处在于每一个线程读取的变量是对应的互相独立的。\n其内部维护了一个 ThreadLocalMap，该 Map 用于存储每一个线程的变量副本。并且 key 为线程对象，value 为对应线程的变量副本。\n为什么 ThreadLocal 会发生内存泄漏？\n因为 ThreadLocal 中的 key 是弱引用，而 value 是强引用。当 ThreadLocal 没有被强引用时，在进行垃圾回收时，key 会被清理掉，而 value 不会被清理掉，这时如果不做任何处理，value 将永远不会被回收，产生内存泄漏。\n如何解决 ThreadLocal 的内存泄漏？\n其实在 ThreadLocal 在设计的时候已经考虑到了这种情况，在调用 set()、get() 、remove() 等方法时就会清理掉 key 为 null 的记录，所以在使用完 ThreadLocal 后最好手动调用 remove() 方法。\n为什么要将 key 设计成 ThreadLocal 的弱引用？\n如果 ThreadLocal 的 key 是强引用，是会发生内存泄漏的。如果 ThreadLocal 的 key 是强引用，引用的 ThreadLocal 的对象被回收了，但是 ThreadLocalMap 还持有 ThreadLocal 的强引用，如果没有手动删除，ThreadLocal 不会被回收，发生内存泄漏。\n如果是弱引用的话，引用的 ThreadLocal 的对象被回收了，即使没有手动删除，ThreadLocal 也会被回收。value 也会在 ThreadLocalMap 调用 set() 、get()、remove() 的时候会被清除。\n线程池\nExecutors 类有哪几种常见的线程池？\n4 种：单例线程池、固定大小线程池、可缓存线程池、大小无限线程池。\n（1）newSingleThreadExecutor：创建一个单例线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。只有 1 个核心线程，无非核心线程，执行完立即回收，任务队列为链表结构的有界队列。\n（2）newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。如果希望在服务器上使用线程池，建议使用 newFixedThreadPool 方法来创建线程池，这样能获得更好的性能。只有核心线程，线程数量固定，执行完立即回收，任务队列为链表结构的有界队列。\n（3） newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60 秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 JVM）能够创建的最大线程大小。无核心线程，非核心线程数量无限，执行完闲置 60s 后回收，任务队列为不存储元素的阻塞队列。\n（4）newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。核心线程数量固定，非核心线程数量无限，执行完闲置 10ms 后回收，任务队列为延时阻塞队列。\n❗说说线程池的底层工作原理\n避免频繁的创建线程，销毁线程……\nExecutorService threadPool = Executors.newFixedThreadPool(10) // corePoolSize\n如果线程池内数量小于 corePoolSize，就会创建一个线程执行任务。线程池一般会带一个队列，当线程执行任务完成，会等待阻塞在队列上（队首），尝试从队列继续获取任务。如果任务多于 corePoolSize，会进入阻塞队列。如果阻塞队列满了，可以根据 maximumPoolSize 创建额外的线程。额外线程的空闲时间根据 keepAliveTime 进行自行销毁。\n如果额外的线程都创建完了，队列还是满的，还有新来的任务。会 reject 掉，有几种 reject 策略，可以传入 RejectedExecutionHandler。\n\n\nAbortPolicy：抛异常\n\n\nDiscardPolicy：扔掉\n\n\nDiscardOldestPolicy：删除最旧的任务\n\n\nCallerRunsPolicy：返回调用者线程执行任务\n\n\n自定义\n\n\n（常用）FixedThreadPool 的队列是 LinkedBlockingQueue，无界阻塞队列，即队列长度无线大。corePoolSize 与 maximumPoolSize 一样大。\n❗线程池的核心配置参数\n代表线程池的类是 ThreadPoolExecutor。corePoolSize（核心线程数），maximumPoolSize（线程池），keepAliveTime（多余的空闲线程在终止之前等待新任务的最长时间），workQueue（阻塞队列）。\n七个核心参数：\n\n\n参数一：核心线程数（不能小于 0）\n\n\n参数二：最大线程数（&gt;=核心线程数）\n\n\n参数三：临时线程最大存活时间（不能小于 0）\n\n\n参数四：时间单位（参数三的单位）\n\n\n参数五：等待列队（不能为 null）\n\n\n参数六：创建线程工厂（不能为 null，一般用默认线程工厂）\n\n\n参数七：任务的拒绝策略（不能为 null）\n\n\n拒绝策略有哪些\n\n\nThreadPoolExecutor.AbortPolicy：丢弃任务并抛出异常（默认）；\n\n\nThreadPoolExecutor.DiscardPolicy：丢弃任务，不抛异常（不推荐）；\n\n\nThreadPoolExecutor.DiscardOldestPolicy：丢弃等待最久的任务；\n\n\nThreadPoolExecutor.CallerRunsPolicy：调用执行自己的线程（main）运行 run 方法。\n\n\n❗如果在线程池中使用无界阻塞队列会发生什么问题？\n\n面试题：在远程服务异常的情况下，使用无界阻塞队列，是否会导致内存异常飙升？\n调用超时，队列变得越来越大，会导致内存飙升，可能还会导致 OOM\n\n❗线程池队列满了之后，会发生什么事情\n无界队列，内存溢出。\n有界队列，但是如果 maximumPoolSize 数量很大，可以无限制创建线程，但是每个线程占用栈内存，可能会导致内存资源耗尽，或者线程太多，CPU 负载太高。\n有界队列，maximumPoolSize 数量固定，多余的任务会被拒绝。\n建议：自定义一个 reject 策略，如果线程池无法执行更多任务，可以把任务信息持久化写入磁盘。等负载降低重新执行这些任务。\n❗如果线上机器突然宕机，线程池的阻塞队列中的请求怎么办？\n线程池内积压的任务丢失。\n解决：在提交任务前，在数据库内插入任务信息，并更新他的状态：已提交、未提交、已完成……。系统重启后把任务状态重新提交。\n❗如何合理设置线程池的核心线程数？\n\n\nCPU 密集型任务：如果应用程序执行的是 CPU 密集型任务，通常情况下，核心线程数应该设置为等于 CPU 核心数。这可以充分利用 CPU 资源。\n\n核心线程数=CPU 核心数\n核心线程数=CPU 核心数 +1\n\n\n\nIO 密集型任务：如果应用程序执行的是 IO 密集型任务（例如，文件读写、网络通信等），通常情况下，核心线程数可以设置为大于 CPU 核心数，以充分利用等待 IO 操作时的线程空闲时间。\n\n核心线程数=2 * CPU 核心数\n核心线程数=CPU 核心数 / (1- 阻塞系数)\n\n\n\n混合型任务：核心线程数=(线程等待时间/线程 CPU 时间 +1) * CPU 核心数\n\n\n","categories":["面试","八股文"],"tags":["面试","八股文","多线程","线程池"]},{"title":"面试 Redis","url":"/posts/25de1bd9/","content":"\n\n前言\n❗表示必掌握，❔表示基本不会问\n\n\n更新\n\n\n24-06-24 初始记录\n\n什么是 Redis\nRedis(Remote Dictionary Server) 是一个使用 C 语言编写的，开源的（BSD 许可）高性能非关系型（NoSQL）的键值对数据库。\nRedis 可以存储键和五种不同类型的值之间的映射。键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。\n什么是 NoSQL？\nNoSQL 的全称是 Not-Only SQL，指的是非关系型数据库，它是关系型数据库的补充，没有表与表之间的关系，主要用于海量数据的处理问题。\n除了 Redis，你还了解其它的 NoSQL 吗?\nnosql 数据库有很多，比如 HBase、MongoDB、Memcached 等，Redis 相比于其他的 nosql 而言，效率高，数据结构比较丰富。\n\n\nMongoDB\n\n高性能、无模式的文档型数据库 (一个文档相当于关系数据库中的一条记录，格式是 xml 或者 json 等)，支持二级索引，非常适合文档化格式的存储及查询。MongoDB 的官方定位是通用数据库，确实和 MySQL 有些像，现在也很流行，但它还是有事务、join 等短板，在事务、复杂查询应用下无法取代关系型数据库。但 MongoDB 更注重庞大数据的存储和操作，但不适合用于临时存储的缓存，如果将数据做缓存使用，还是 Redis 性能更高。\n\n\n\nRedis\n\n内存型 Key/Value 系统，读写性能非常好，支持操作原子性，很适合用来做高速缓存。\n\n\n\nHBase\n\n存储容量大，一个表可以容纳上亿行、上百万列，可应对超大数据量要求扩展简单的需求。\n\n\n\nRedis 有哪些优缺点？\n优点\n\n\n读写性能优异。Redis 能读的速度是 110000 次/s，写的速度是 81000 次/s。\n\n\n支持数据持久化。支持 AOF 和 RDB 两种持久化方式。\n\n\n支持事务。Redis 的所有操作都是原子性的，同时 Redis 还支持对几个操作合并后的原子性执行。\n\n\n数据结构丰富。除了支持 string 类型的 value 外还支持 hash、set、zset、list 等数据结构。\n\n\n支持主从复制。主机会自动将数据同步到从机，可以进行读写分离。\n\n\n缺点\n\n\n数据库容量受到物理内存的限制，不能用作海量数据的高性能读写。因此 Redis 适合的场景主要局限在较小数据量的高性能操作和运算上。\n\n\nRedis 不具备自动容错和恢复功能。主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的 IP 才能恢复。\n\n\n数据不同步。主机宕机，宕机前有部分数据未能及时同步到从机，切换 IP 后还会引入数据不一致的问题，降低了系统的可用性。\n\n\nRedis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。\n\n\n为什么要用 Redis/为什么要用缓存？\n高性能\n假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数缓缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！\n高并发\n直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。\n为什么要用 Redis 而不用 map/guava 做缓存?\n缓存分为本地缓存和分布式缓存。以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。\n使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 redis 或 memcached 服务的高可用，整个程序架构上较为复杂。\nRedis 与 Memcached 的区别是什么？为什么不选 Memcached?\n\n\nmemcached 所有的值均是简单的字符串，且只支持 k/v 类型，redis 作为其替代者，支持更为丰富的数据类型。\n\n\nredis 可以持久化其数据，memcached 只用做缓存提升性能，不能做持久化。\n\n\nmemcached 存储数据有限制：1M 【大于 1M，认为就行分割】（内存碎片）\n\n\nmemcached 集群数据没有复制和同步机制（崩溃不会影响程序，会从数据库中取数据）。\n\n\nmemcached 内存不能及时回收，它只有 LRU(算法) 这一种方式，而 redis 有多种内存回收方式。\n\n\nRedis 为什么这么快？\n\n\n完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是 O(1)；\n\n\n数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的；\n\n\n采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；\n\n\n使用多路 I/O 复用模型，非阻塞 IO；\n\n\n使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；\n\n\nRedis 的主要缺点是什么？\n\n\n内链：[[面试-08 Redis#在工作中，如果数据库修改了数据，那就跟 redis 数据不同步了，此时该办？（缓存双写一致性问题）|缓存双写一致性问题]]\n外链：缓存双写一致性问题\n\n\n内链：[[面试-08 Redis#缓存雪崩|缓存雪崩问题]]\n外链：缓存雪崩问题\n\n\n内链：[[面试-08 Redis#缓存穿透|缓存穿透问题]]\n外链：缓存穿透问题\n\n\n内链：[[面试-08 Redis#那怎么解决缓存的并发竞争问题？比如多个子系统去set一个key但最后执行顺序和我们期望顺序不一样。|缓存的并发竞争问题]]\n外链：缓存的并发竞争问题\n\n\n数据类型\nRedis 的数据类型有哪些？它的数据操作是怎么样的？\n\n\n数据类型\n\nstring、hash、list(有序、可重复)、set(无序、不可重复)、zset(不可重复，基于 score 实现排序)\n\n\n\n数据操作\n\nRedis 中的数据存储方式是 key-value 形式\nRedis 不能保存 JAVA 对象，需要转为 JSON 对象后存入 Redis\n\n\n\n\n\n\n数据类型\n可以存储的值\n操作\n应用场景\n\n\n\n\nString\n字符串、整数或浮点数\n1.对整个字符串或者字符串的其中一部分执行操作 2.对整数和浮点数执行自增或自减操作\n做简单的键值对缓存\n\n\nList\n列表\n1.从两端压入或弹出元素 2.对单个或多个元素进行修剪，只保留一个范围内的元素\n存储一些列表型的数据结构，类似粉丝列表、文章的评论列表之类的数据\n\n\nSet\n无序集合\n1.添加、获取、移除单个元素 2.检查一个元素是否在集合中 3.计算交集、并集、差集 从集合里面随机获取元素\n交集、并集、差集的操作，比如两人的粉丝列表做交集\n\n\nHash\n包含键值对的无序散列表\n1.添加、获取、移除单个键值对 2.获取所有键值对 3.检查某个键是否存在\n结构化的数据，比如一个对象\n\n\nZSet\n有序集合\n1.添加、获取、移除元素 2.根据分值范围或成员来获取元素 3.计算一个键的排名\n去重，但可以排序，如获取前几名用户\n\n\n\nRedis 的应用场景\n\n\n计数器\n\n\n\n\n可以对 String 进行自增自减运算，从而实现计数器功能。Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。\n\n\n\n\n缓存\n\n\n\n\n将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。\n\n\n\n\n会话缓存\n\n\n\n\n可以使用 Redis 来统一存储多台应用服务器的会话信息。当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。\n\n\n\n\n全页缓存（FPC）\n\n\n\n\n除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。以 Magento 为例，Magento 提供一个插件来使用 Redis 作为全页缓存后端。此外，对 WordPress 的用户来说，Pantheon 有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。\n\n\n\n\n查找表\n\n\n\n\n例如 DNS 记录就很适合使用 Redis 进行存储。查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。\n\n\n\n\n消息队列 (发布/订阅功能)\n\n\n\n\nList 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息。不过最好使用 Kafka、RabbitMQ 等消息中间件。\n\n\n\n\n分布式锁实现\n\n\n\n\n在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。\n\n\n\n\n其它\n\n\n\n\nSet 可以实现交集、并集等操作，从而实现共同好友等功能。ZSet 可以实现有序性操作，从而实现排行榜等功能。\n\n\nRedis 应用场景（根据类型）\n\n\nString\n\n适合最简单的 k-v 存储，类似于 memcached 的存储结构，短信验证码，配置信息等，就用这种类型来存储。\n\n\n\nHash\n\n一般 key 为 ID 或者唯一标示，value 对应的就是详情了。如商品详情，个人信息详情，新闻详情等。\n\n\n\nList\n\n因为 list 是有序的，比较适合存储一些有序且数据相对固定的数据。如省市区表、字典表等。因为 list 是有序的，适合根据写入的时间来排序，如：最新的***，消息队列等。\n\n\n\nSet\n\n可以简单的理解为 ID-List 的模式，如微博中一个人有哪些好友，set 最牛的地方在于，可以对两个 set 提供交集、并集、差集操作。例如：查找两个人共同的好友等。\n\n\n\nZSet\n\n自动会根据 score 的值进行排序。比较适合类似于 top 10 等不根据插入的时间来排序的数据。\n\n\n\nRedis 持久化\n什么是 Redis 持久化？\n\n\n持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。\n\n\nRedis 的持久化机制是什么？各自的优缺点？\nRDB\n\n\n简述\n\nRDB 是二进制快照形式，数据体量小，保存效率高，但丢失风险也较大，因为它是定时定量更改才会自动持久化，无法实时存储，如果在快照之前丢失，则无法找回。\n\n\n\n优点\n\n只有一个文件 dump.rdb，方便持久化。\n容灾性好，一个文件可以保存到安全的磁盘。\n性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能\n相对于数据集大时，比 AOF 的启动效率更高。\n\n\n\n缺点\n\n数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候)\n\n\n\nAOF\n\n\n简述\n\nAOF 是过程命令形式，数据体量大 (可以用 AOF 重写解决该问题)，效率低于 RDB，记录每个操作，存储格式也更复杂，但数据相对完整 (最快可以每秒同步一次)，且弥补了 RDB 不能实时存储的缺点。\n\n\n\n优点\n\n数据安全，AOF 持久化可以配置 appendfsync 属性，有 always，每进行一次命令操作就记录到 AOF 文件中一次。\n通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。\nAOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）)\n\n\n\n缺点\n\nAOF 文件比 RDB 文件大，且恢复速度慢。\n数据集大的时候，比 rdb 启动效率低。\n\n\n\nAOF 数据体量大，那有什么办法可以解决这个问题吗？\n\n\nRedis 中引入了 AOF 重写机制可以压缩文件体积——执行压缩命令即可。\n\n\nAOF 重写可以降低磁盘占用量，也能提高数据恢复效率，它会对同一数据的多条写命令合并为一条写命令，且为了防止数据量过大造成缓冲区溢出，每条指令最多为 64 个元素。\n\n\nAOF 重写其实是一个同步开启的子进程，Redis 执行指令时，子进程也会开启重写，主进程会将写入的数据同步到子进程，子进程则开始重写 AOF 文件，写完后再返回给主进程，完成 AOF 重写。\n\n\n选用\n\n\nAOF 文件比 RDB 更新频率高，优先使用 AOF 还原数据。\n\n\nAOF 比 RDB 更安全也更大\n\n\nRDB 性能比 AOF 好\n\n\n如果两个都配了优先加载 AOF\n\n\n如果对数据非常敏感用 AOF，如果追求大数据集的恢复速度选 RDB。\n\n\nRedis 持久化数据和缓存怎么做扩容？\n\n\n如果 Redis 被当做缓存使用，使用一致性哈希实现动态扩容缩容。\n\n\n如果 Redis 被当做一个持久化存储使用，必须使用固定的 keys-to-nodes 映射关系，节点的数量一旦确定不能变化。否则的话 (即 Redis 节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有 Redis 集群可以做到这样。\n\n\n数据删除\nRedis 是怎么进行数据删除的？过期删除策略？\n三种过期策略\n定时删除\n创建一个定时器，当 key 设置过期时间，且过期时间到达时，由定时器任务立即执行对键的删除操作。\n这样的好处是及时快速释放内存，坏处时，消耗过多的处理器性能。\n惰性删除\n定时删除策略中，从删除方法来看，必然会导致有 key 过期了但未从 redis 中删除的情况。\n面对这种情况，redis 在操作一个 key 时，会先判断这个值是否过期，若已过期，则删除该 key；若未过期，则进行后续操作。\n定期删除（常用）\n\n\nRedis 默认会每秒进行十次过期扫描，过期扫描不会遍历过期字典中所有的 key，而是采用了一种简单的贪心策略。\n\n从过期字典中随机 20 个 key；\n删除这 20 个 key 中已经过期的 key；\n如果过期的 key 比率超过 1/4，那就重复步骤 1；\n同时，为了保证过期扫描不会出现循环过度，导致线程卡死现象，算法还增加了扫描时间的上限，默认不会超过 25ms。\n如果某一时刻，有大量 key 同时过期，Redis 会持续扫描过期字典，造成客户端响应卡顿，因此设置过期时间时，就尽量避免这个问题，在设置过期时间时，可以给过期时间设置一个随机范围，避免同一时刻过期。\n(expires 字典会保存所有设置了过期时间的 key 的过期时间数据，其中，key 是指向键空间中的某个键的指针，value 是该键的毫秒精度的 UNIX 时间戳表示的过期时间。键空间是指该 Redis 集群中保存的所有键。)\nRedis 中同时使用了惰性过期和定期过期两种过期策略。\n\n\n\n怎么判断一个 Key 还有多少时间\n\n\nTTL 命令（命令行）\n\n正数 -&gt; 剩余时间\n-1 -&gt; 永久 Key\n-2 -&gt; Key 已经过期或者不存在\n\n\n\n如何配置定期删除执行时间间隔？\nredis 的定时任务默认是 10s 执行一次，如果要修改这个值，可以在 redis.conf 中修改 hz 的值。\nredis.conf 中，hz 默认设为 10，提高它的值将会占用更多的 cpu，当然相应的 redis 将会更快的处理同时到期的许多 key，以及更精确的去处理超时。\nhz 的取值范围是 1~500，通常不建议超过 100，只有在请求延时非常低的情况下可以将值提升到 100。\n单线程的 redis，如何知道要运行定时任务\n\nRedis 是单线程的，线程不但要处理定时任务，还要处理客户端请求，线程不能阻塞在定时任务或处理客户端请求上，那么，redis 是如何知道何时该运行定时任务的呢？\n\nRedis 的定时任务会记录在一个称为最小堆的数据结构中。在这个堆中，最快要执行的任务排在堆的最上方。在每个循环周期，Redis 都会将最小堆里面已经到点的任务立即进行处理。处理完毕后，将最快要执行的任务还需要的时间记录下来，这个时间就是接下来处理客户端请求的最大时长，若达到了该时长，则暂时不处理客户端请求而去运行定时任务。\nRedis key 的过期时间和永久有效分别怎么设置？\nEXPIRE 和 PERSIST 命令。\n内存淘汰\nRedis 的内存淘汰策略有哪些？\nRedis 的内存淘汰策略是指在 Redis 的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。\n\n\n\n操作的数据集\n内存淘汰策略\n说明\n\n\n\n\n设置过期时间的键空间选择性移除（可能会过期的数据集 server.db[i].expires）\nvolatile-lru\n淘汰最近一次使用时间距现在最久的数据（Least Recently Used）最常用\n\n\n\nvolatile-lfu\n淘汰使用次数最少的数据（Least Frequently Used）\n\n\n\nvolatile-ttl\n淘汰过期时间最近的数据\n\n\n\nvolatile-random\n淘汰随机数据\n\n\n全局的键空间选择性移除（所有数据集）\nallkeys-lru\n淘汰最近一次使用时间距现在最久的数据\n\n\n\nallkeys-lfu\n淘汰使用次数最少的数据\n\n\n\nallkeys-random\n淘汰随机数据\n\n\n放弃数据驱逐\nno-enviction\n禁止驱逐数据（Redis4.0 中默认策略），会引发错误 OOM(Out Of Memory)\n\n\n\n总结\nRedis 的内存淘汰策略的选取并不会影响过期的 key 的处理。内存淘汰策略用于处理内存不足时需要申请额外空间的数据；过期策略用于处理过期的缓存数据。\nMySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据？\nRedis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略 (上面的 allkeys-lru，移除最近最少使用的 key)。\nRedis 主要消耗什么物理资源？\n内存。\nRedis 的内存用完了会发生什么？\n如果达到设置的上限，Redis 的写命令会返回错误信息（但是读命令还可以正常返回。）或者你可以配置内存淘汰机制，当 Redis 达到内存上限时会冲刷掉旧的内容。\nRedis 如何做内存优化？\n可以好好利用 Hash，list，sorted set，set 等集合类型数据，因为通常情况下很多小的 Key-Value 可以用更紧凑的方式存放到一起。尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的 web 系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的 key，而是应该把这个用户的所有信息存储到一张散列表里面\n集群方案\n说一说 Redis 的主从复制\n对于大型网站来说，每秒需要读取的数据远远超过单台 Redis 服务所能承受的压力，而写入的数据相对来说较少，这时候用 Redis 的主从复制模式可以很好的提升同一个内容的读取速度。\nRedis 主从复制模式其实是一个读写分离模型，将主服务器用来处理写操作，从服务器只提供读操作，不过主从复制是所有内容完全一致的，而不是分库分表的，严格来说不算集群。\n主从复制模式最大的问题是只有一个主节点，没有实现高可用，所以还需要哨兵机制来实现高可用。\n主从同步过程\n当启动一个 slave node 的时候，它会发送一个 PSYNC &lt;runid&gt; &lt;offset&gt; 命令给 master node。\n如果这是 slave node 初次连接到 master node，那么会触发一次 full resynchronization 全量复制（接收命令判断 runid 是否匹配，判定 offset 是否在复制缓冲区中）。此时 master 会启动一个后台线程，开始生成一份 RDB 快照文件，\n\n\n同时还会将从客户端 client 新收到的所有写命令缓存在 replication buffer（redis server 会为每一个连接到自己的客户端创建一个 replication buffer，用来缓存主库执行的命令）中。RDB 文件生成完毕后， master 会将这个 RDB 发送给 slave，slave 会先写入本地磁盘，然后再从本地磁盘加载到内存中，过程中基于旧的数据对外提供服务。\n\n如果 replication buffer 写满了（client-output-buffer-limit），无论客户端是普通客户端还是从库，只能断开跟这个客户端的连接了。这样从库全量同步失败，只能再次尝试全量同步。\n\n\n\n接着 master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。\n\n如果 slave node 开启了 AOF，那么立即执行重写 AOF\n\n\n\nslave node 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据。（主库的写命令，除了传给从库后，还会写入 repl_backlog_buffer）\n\n\n如果从库给的 runid 和 offset 都是对的，那么主服务器就会从上次同步的 offset 位置开始进行增量同步\n\n\n如果 offset 已经小于了主的复制缓冲区中最小的那个偏移量，就会进行全量复制\n\n\n切换了主服务器也会进行全量复制\n\n\n\n什么是 Redis 哨兵？\nsentinel（哨兵）是用于监控 Redis 集群中 Master 状态的工具，其本质就是一个独立运行的进程，是 Redis 的高可用解决方案。\nsentinel 可以监视一个或者多个 Redis master 服务，以及这些 master 服务的所有从服务；当某个 master 服务下线时，自动将该 master 下的某个从服务升级为 master 服务替代已下线的 master 服务继续处理请求，并且其余从节点开始从新的主节点复制数据。（它会直接修改配置文件，来实现修改主服务器）\n在 Redis 安装完成后，会有一个 redis-sentinel 的文件，这就是启动 sentinel 的脚本文件，同时还有一个 sentinel.conf 文件，这个是 sentinel 的配置文件。\n但哨兵也可能会挂，所以需要对哨兵也实现高可用（集群）。\n哨兵的核心知识\n哨兵至少需要 3 个实例，来保证自己的健壮性。\n哨兵 + Redis 主从的部署架构，是不保证数据零丢失的，只能保证 Redis 集群的高可用性。\n对于哨兵 + Redis 主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练。\n为什么要搭建 Redis 集群？\nRedis 有内置集群 cluster，Redis cluster 是无中心节点的集群架构，本身就是去中心化的，也就是说，每个节点都保存各自的数据和整个集群的状态。每个节点都和其他所有节点连接，而且这些连接保持活跃，这样就保证了我们只需要连接集群中的任意一个节点，就可以获取到其他节点的数据。\ncluster 集群中内置了哨兵机制，不需要再额外启动哨兵程序。\nRedis cluster 为了保证数据的高可用，加入了主从模式，主节点只用来存，从节点只用来取，如果主节点挂掉了，就会在从节点中选取一个来充当主节点。当然，如果通过集群命令，还可以实现在任何一个节点写入。\nRedis 集群工作流程\n\n\n通过哈希的方式，将数据分片，每个节点均分存储一定哈希槽 (哈希值) 区间的数据，默认分配了 16384 个槽位\n\n\n每份数据分片会存储在多个互为主从的多节点上\n\n\n数据写入先写主节点，再同步到从节点 (支持配置为阻塞同步)\n\n\n同一分片多个节点间的数据不保持一致性\n\n\n读取数据时，当客户端操作的 key 没有分配在该节点上时，redis 会返回转向指令，指向正确的节点\n\n\n扩容时时需要需要把旧节点的数据迁移一部分到新节点\n\n\n在 redis cluster 架构下，每个 redis 要放开两个端口号，比如一个是 6379，另外一个就是 加 1w 的端口号，比如 16379。\n16379 端口号是用来进行节点间通信的，也就是 cluster bus 的东西，cluster bus 的通信，用来进行故障检测、配置更新、故障转移授权。cluster bus 用了另外一种二进制的协议，gossip 协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间。\n你知道哪些分布式寻址法？\nhash 算法（大量缓存重建）\n一致性 hash 算法（自动缓存迁移）+ 虚拟节点（自动负载均衡）\nredis cluster 的 hash slot （槽）算法\n你了解一致性哈希吗？\n简单来说，一致性 Hash 算法将整个哈希值空间组织成一个虚拟的圆环，整个空间圆按顺时针方向布局，正上方点代表 0，也代表 2^32-1，即一共 2^32 个点组成的圆环称为 Hash 环。\n一致性哈希算法可用于 Redis 的集群搭建，当然这种用法已经过时了，现在可以用 Redis cluster 的哈希槽来替代一致性哈希算法，实现集群搭建。\n使用一致性哈希算法时，多个服务器也会落在这个 Hash 环上，并且能确定各自的位置，这样用户访问的时候，会根据用户 IP 计算出哈希值，对应到哈希环上，并顺时针行走，遇到的第一台服务器就是该用户被分配到的服务器。\n但是一致性哈希会有数据倾斜的问题，也就是可能多台服务器聚集在相近的地方，这时就需要将服务器多构建几个虚拟节点，来分散到 Hash 环上的各个位置，来使数据分配的服务器较为均衡，设置的虚拟节点约多，数据分配的越是相对均匀。\nRedis 集群是同步复制还是异步复制？是否会有写操作丢失情况？为什么？\n异步复制。\nRedis 主节点与从节点之间的数据复制是异步复制的，当客户端发送写请求给 master 节点的时候，客户端会直接返回 OK，然后主节点同步到各个从节点中。\n如果主节点没来得及同步给从节点时发生宕机，那么主节点内存中的数据就会丢失。\n如果主节点中开启持久化，能不能保证数据不丢失呢？\n不能。\n主节点宕机后（脑裂也会有相同的数据丢失问题），会自动启动哨兵机制，重新选举新的主节点，如果这时候旧的主节点恢复故障重启了，它就会去同步新的主节点数据，而这时新的主节点并没有同步那之前丢失的数据，旧的主节点的上的数据则会在同步新主节点上数据时，刷新掉，此时数据还是会丢失。\n怎么才能保证数据不丢失？或者如保证尽量少的数据丢失？\n没办法完全保证数据不丢失。但是可以通过设置主从节点间的同步复制延迟时间来尽量少的数据丢失。\n比如，在 Redis 集群中，在 redis 配置文件中修改同步复制延迟的时间不超过 10s，一但延迟超过这个时间，说明主节点可能出了问题（不一定是宕机），那么配置生效，主节点只能读，不能再写入。\n\n\nmin-slaves-to-write 1\n\n\nmin-slaves-max-lag 10\n\n\n要求至少有 1 个 slave，数据复制和同步的延迟不能超过 10 秒（这样脑裂最多就丢失 10s 数据）\n\n\n同时在客户端做降级处理，把数据写到本地磁盘。\n什么是 Redis 脑裂？会存在什么问题？\n一个集群中的 master 恰好网络故障，导致与 sentinal 联系不上了，sentinal 把另一个 slave 提升为了 master。此时就存在两个 master 了。\n当我们发现的时候，停止掉其中的一个 master，手动切换成 slave，当它连接到提升后的 master 的时候，会开始同步数据，那么自己脑裂期间接收的写数据就被丢失了。\nRedis 集群如何选择数据库？\nRedis 集群目前无法做数据库选择，默认在 0 数据库。\nRedis 集群最大节点个数是多少？\n16384 个\n生产环境中的 redis 是怎么部署的？\nredis cluster，10 台机器，5 台机器部署了 redis 主实例，另外 5 台机器部署了 redis 的从实例，每个主实例挂了一个从实例，5 个节点对外提供读写服务，每个节点的读写高峰 qps 可能可以达到每秒 5 万，5 台机器最多是 25 万读写请求/s。\n\n\n机器是什么配置？32G 内存 + 8 核 CPU + 1T 磁盘，但是分配给 redis 进程的是 10g 内存，一般线上生产环境，redis 的内存尽量不要超过 10g，超过 10g 可能会有问题。\n\n\n5 台机器对外提供读写，一共有 50g 内存。\n\n\n因为每个主实例都挂了一个从实例，所以是高可用的，任何一个主实例宕机，都会自动故障迁移，redis 从实例会自动变成主实例继续提供读写服务。\n\n\n你往内存里写的是什么数据？每条数据的大小是多少？商品数据，每条数据是 10kb。100 条数据是 1mb，10 万条数据是 1g。常驻内存的是 200 万条商品数据，占用内存是 20g，仅仅不到总内存的 50%。目前高峰期每秒就是 3500 左右的请求量。其实大型的公司，会有基础架构的 team 负责缓存集群的运维。\n\n\n缓存异常\n缓存预热\n系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题。用户直接查询事先被预热的缓存数据。\n解决方法\n\n\n自动：使用监听器（web/Spring boot）监听某个事件（项目启动/容器的创建），在事件触发时查询数据库，把一些热门数据提前缓存到 Redis 中\n\n\n手动：使用单元测试脚本 动态的往 Redis 中进行数据的添加\n\n\n缓存雪崩\n缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。\n解决方法\n\n\n设置缓存的失效时间尽量错开（比如 30 天 + 随机数 (s)），热门数据时间长点，不热门的时间短点。\n\n\n设置多级缓存，Nginx 缓存 +redis 缓存 +ehcache 缓存……每一个缓存都是一个集群，相同的数据会在多种服务器进行缓存，可以 100% 解决缓存雪崩。\n\n\n侧面解决：优化数据库，提升效率，使用页面静态技术（多级缓存）代替从 redis 中取值。\n\n\n限流/降级\n\n\n超热数据使用永久 Key（定期维护）\n\n\n缓存穿透\n就是指反复查询一个数据库一定不存在的数据，导致数据库压力过大，这种情况一般只有恶意攻击才会出现。\n解决方法\n\n\n接口层增加校验，如用户鉴权校验，id 做基础校验，id&lt;=0 的直接拦截\n\n\n从缓存取不到的数据，在数据库中也没有取到，这时也可以将 key-value 对写为 key-null，缓存有效时间可以设置短点，如 30 秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个 id 暴力攻击\n\n\n采用布隆过滤器（在海量数据中判断一个数据是否存在），将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。根据 Hash 判断，如果数据不存在，那么一定不存在。\n\n\n加密参数，符合加密规则的参数才会被接收\n\n\n缓存击穿\n是指一个热点 key 的 redis 缓存失效，导致大量请求瞬间集中到数据库。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。\n解决方法\n\n\n多级缓存\n\n\n延长热点数据有效期。\n\n\n限流/降级\n\n\n缓存降级\n当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。\n热点数据和冷数据\n\n\n热点数据，缓存才有价值\n\n某 IM 产品，生日祝福模块，当天的寿星列表，缓存以后可能读取数十万次。某导航产品，我们将导航信息，缓存以后可能读取数百万次。\n\n\n\n对于冷数据而言，大部分数据可能还没有再次访问到就已经被挤出内存，不仅占用内存，而且价值不大。\n\n\n频繁修改的数据，看情况考虑使用缓存\n\n这个读取接口对数据库的压力很大，但是又是热点数据，这个时候就需要考虑通过缓存手段，减少数据库的压力，比如我们的某助手产品的，点赞数，收藏数，分享数等是非常典型的热点数据，但是又不断变化，此时就需要将数据同步保存到 Redis 缓存，减少数据库压力。\n\n\n\n线程模型\n为什么 Redis 是单线程的？\nRedis 的底层主要是三大部分：IO 多路复用程序 + 队列 + 文件事件分派器。而文件事件分派器就是用来分派执行任务的，且它是单线程的，所以说 Redis 也是单线程的。\n此外，Redis 底层是基于 C 语言所写，且是基于内存运行，所以他的 IO 速度很快，相对来说主要要占用的是 CPU 的资源，如果使用多线程反而会因为线程的切换增大开销，降低效率。对于不是处理海量数据，多用于缓存使用的 Redis 来说，使用单线程是效率最优的。\nRedis 是单线程的，为什么还需要用它实现分布式锁？\nRedis 单线程与分布式锁没有关系。Redis 单线程只能保证在 Redis 中的读写是按一定顺序执行（Redis 不保证原子性，也不会回滚，某条命令运行失败也会继续执行），但在分布式中，是多台机器间的多进程调用，为了保证执行过程中，不被其他进程抢断执行，需要有一个第三方组件来实现分布式锁。即使数据就在 Redis 中，也无法保证数据在进行其他服务处理的时候，被其他进程抢走。\nRedis 是单线程的，如何提高多核 CPU 的利用率？\n可以在同一个服务器部署多个 Redis 的实例，并把他们当作不同的服务器来使用，在某些时候，无论如何一个服务器是不够的， 所以，如果你想使用多个 CPU，你可以考虑一下分区。\nRedis 分区\n为什么要做 Redis 分区\n分区可以让 Redis 管理更大的内存，Redis 将可以使用所有机器的内存，提升内存和计算能力。\n怎么实现 Redis 分区？\nCluster 集群就很好的实现了 Redis 分区。客户端随机地请求任意一个 Redis 实例，然后由 Redis 将请求转发给正确的 Redis 节点。Redis Cluster 实现了一种混合形式的查询路由，但并不是直接将请求从一个 Redis 节点转发到另一个 Redis 节点，而是在客户端的帮助下直接 redirected 到正确的 Redis 节点。\nRedis 分区的缺点是什么？\n涉及多个 key 的操作时可能会比较麻烦一点：比如两个集合 key 在不同的机子上，那就不能直接在 Redis 中做交集。\nRedis 分区和集群有什么区别？\n分区是逻辑概念，即一个 master 可以分为一个 master+n 个 slave。\n集群是系统结构，集群是分区概念的一种实现方式。\n分布式问题\n那怎么解决缓存的并发竞争问题？比如多个子系统去 set 一个 key 但最后执行顺序和我们期望顺序不一样\n可以采用分布式锁（Zookeeper 和 Redis 都可以实现分布式锁）的方案。（如果不存在 Redis 的并发竞争 Key 问题，不要使用分布式锁，这样会影响性能）\n基于 Zookeeper 临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在 Zookeeper 上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。\n在实践中，当然是从以可靠性为主。所以首推 Zookeeper。\n说一说 Redis 分布式锁\n首先，分布式锁是一种思想，是为了解决多机器多进程之间的同步问题，需要引入第三方来做锁处理。\nRedis 分布式锁的加锁，其实就是给 Key 键设置一个值（SET lock_key random_value NX PX 5000，NX 表示键不存在时才设置），其他进程执行前会判断 Redis 中这个 Key 是否有值，如果发现这个 Key 有值了，就说明已有其他进程在执行，则循环等待，超时则获取失败。\n解锁就是将 Key 键删除，为了保证解锁的原子性操作，用 Redis 自带的 LUA 脚本完成操作。\nRedis 做为分布式锁的优点是性能高，缺点是不可靠，比如在 Redis 集群架构中，一旦主节点宕机，新的主节点会给新进程也加锁。\n但不论如何，分布式锁一定会带来性能消耗问题，且实际中使用查询的比例远大于写的比例，除非是重要的敏感数据，不然为了更高的性能，一般会选择舍弃使用分布式锁。\n这里为什么要用 Lua 脚本来完成解锁操作？\nRedis 只能保证单个指令进入 Redis 是单线程原子性的，但不能保证多个命令之间的顺序是原子性的，但是 Lua 指令可以将这个命令绑定，相当于只有一个执行命令，保证它们是顺序执行的。\n为什么 Redis 分布式解锁要保证原子性？\n主要是怕误将其他客户端的锁解开。\n比如客户端 A 加锁，一段时间之后客户端 A 解锁，在进入 unlock 后执行 jedis.del() 之前，锁突然过期了，此时客户端 B 尝试加锁成功，然后客户端 A 再执行 del() 方法，这时候客户端 A 已经执行过 Random_Value 的判断，虽然和客户端 B 的不一样，但我们总不能每一行代码都做一个值判断吧，这时候客户端 A 就会将客户端 B 的锁给解除了。\nRedis 分布式锁应该注意什么？\n加锁的时候，应考虑到执行一半宕机或故障导致没能执行到解锁的命令，产生死锁，所以需要给定一个过期时间，防止死锁。\n解锁要保证原子一致性。\nRedis 的解锁就是把 key 删除即可，但是删除的时候不能随便删，比如线程 A 不能删除线程 B 的 key，这个时候 value 就起到作用了，random_value 我们设置为随机值，每一个线程都生成一个随机值作为 random_value，删除 key 的时候先判断随机值是否和本线程的一致，一致的才可以删除。\nRedis 事务\nRedis 事务的概念\nRedis 事务的本质是通过 MULTI、EXEC、WATCH 等一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。\n总结说：Redis 事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。\nRedis 事务的三个阶段\n\n\n事务开始 MULTI\n\n\n命令入队\n\n\n事务执行 EXEC\n\n\n事务执行过程中，如果服务端收到有 EXEC、DISCARD、WATCH、MULTI 之外的请求，将会把请求放入队列中排队\nRedis 事务相关问题\nRedis 事务功能是通过 MULTI、EXEC、DISCARD 和 WATCH 四个原语实现的。（Redis 事务很鸡肋）\n\n\nRedis 会将一个事务中的所有命令序列化，然后按顺序执行。\n\n\nRedis 不支持回滚，“Redis 在事务失败时不进行回滚，而是继续执行余下的命令”， 所以 Redis 的内部可以保持简单且快速。\n\n\n如果在一个事务中的命令出现错误，那么所有的命令都不会执行（就是除非你的命令写错了，导致所有命令不执行）；\n\n\n如果在一个事务中出现运行错误，那么正确的命令会被执行。\n\n\nWATCH 命令是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。 可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到 EXEC 命令。\nMULTI 命令用于开启一个事务，它总是返回 OK。 MULTI 执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当 EXEC 命令被调用时，所有队列中的命令才会被执行。\nEXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil 。\n通过调用 DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。\nUNWATCH 命令可以取消 watch 对所有 key 的监控。\nRedis 事务保证原子性吗？\nRedis 中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚，事务过程中任意命令执行失败，其余的命令仍会被执行。\nRedis 事务保证隔离性吗？\nRedis 是单进程程序，并且它保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。因此，Redis 的事务是总是带有隔离性的。\n场景\n在工作中，如果数据库修改了数据，那就跟 Redis 数据不同步了，此时该办？（缓存双写一致性问题）\n第一种是硬编码方式；\n\n\n让服务的更新和查询分先后进行执行，服务将数据库更新后，再查返更新后的数据，把更新后的数据再更新到 Redis。如果有多个服务同时调用，就用 MQ 获取 Mysql 的 binlog 中的修改顺序，依次发送消息给 redis，MySQL 的顺序记录就是先后更改的执行顺序，MQ 根据这个顺序即可保证先后的更新顺序，让 Redis 的更新顺序不出问题。\n\n\n第二种是 Redis 缓存二次开发解决（MyBatisPlus+Redis 整合：餐饮项目中使用到）。\n\n\n用 Mybatis 二级缓存对外开放的 cache 接口进行二次开发，Cache 支持 SPI 机制，通过注解来调动相关配置类，通过实现 Mybatis 二级缓存接口 Cache 集成 Redis 缓存，可以自动更新 MySQL 数据到 Redis 缓存中。\n\n\n为了防止在读写的过程中出现高并发问题，还需要加上 ReentrantReadWriteLock 读写锁，ReentrantLock 只能进入一个线程，ReentrantReadWriteLock 允许多个线程访问，提高高并发，但只支持多个线程读，不支持同时读写或写写。\n\n\n但是以上方式也不能完全解决同步问题，仍存在分布式的高并发问题，如果需要完全保证一致性，就需要使用分布式锁，对每个事务上锁。但这样对系统资源消耗过大，得不偿失，毕竟读取的量是远大于增删改的量的。\n\n\n假如 Redis 里面有 1 亿个 key，其中有 10W 个 key 是以某个固定的已知前缀开头的，如何将它们全部找出来？\n使用 keys 指令可以扫出指定模式的 key 列表。\n使用 SCAN+MATCH 参数匹配前缀命令获取所有 key（会重复，需要进行去重处理）\nredis 127.0.0.1:6379&gt; KEYS PATTERNSCAN 0MATCH &quot;prefix:*&quot;\n\n匹配模式:\n\nh?llo 匹配 hello, hallo 和 hxllo\nh*llo 匹配 hllo 和 heeeello\nh[ae]llo 匹配 hello and hallo, 不匹配 hillo\nh[^e]llo 匹配 hallo, hbllo, … 不匹配 hello\nh[a-b]llo 匹配 hallo 和 hbllo\n\n\n以上是原先的答案，但是参考博客 (https://cloud.tencent.com/developer/article/2408542)，这样回答反而是错误的。\n根据上篇博客的内容，具体的测试内容不放出了。总之这题如果面试官只是要考查你 KEYS 命令和 SCAN 命令的区别，并且想要看看你知不知道 KEYS 命令的阻塞问题，那么你回答 SCAN 就已经过了。而实际中，如果真的有经验，你就会发现 SCAN 的能力阈值是在那里的。于是你需要继续反问面试官，是否有时间要求。\n\n自己进行了一下验证，如果直接一次 scan 一千万的记录 耗时为: 10.15 秒。\n理论上 scan 一个键值对的时间为 1 微秒左右。\n如果 Redis 里面有 1000 万个 key 的话 60 台服务器如果同时进行一次所有的 scan 那么搞不好至少会有在 运行期间内产生总计 600S 的延迟时间.\n\nRedis redis 正给线上的业务提供服务，那使用 keys 指令会有什么问题？\n由于 Redis 是单线程的，而 keys 是遍历查询，每个数据都会遍历一次，所以 keys 指令去查找大量数据会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。\n可替代方式是，可以使用 scan 指令，scan 指令可以无阻塞的提取出指定模式的 key 列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用 keys 指令长。\n但这里要注意的是，scan 指令有一个坑，不会自动释放连接，需要手动释放连接。// todo 这个需要查找 具体的解决方案我有做笔记。\nScan 为什么可以不阻塞提取 key 列表？为什么会有重复问题？\nScan 命令其实是迭代器方式对数据进行遍历获取，但它是分次进行的，可以在中途返回查到的数据，做到不阻塞，且因为 Redis 底层是 Hash 字典，会有扩容和缩容问题，所以 scan 每次都会往前退一定数据开始继续遍历，所以会有重复问题。（具体见笔记）。\n使用 Redis 做过异步队列吗，是如何实现的？\n使用 list 类型保存数据信息，rpush 生产消息，lpop 消费消息，当 lpop 没有消息时，可以 sleep 一段时间，然后再检查有没有信息，如果不想 sleep 的话，可以使用 blpop, 在没有信息的时候，会一直阻塞，直到信息的到来。Redis 可以通过 pub/sub 主题订阅模式实现一个生产者，多个消费者，当然也存在一定的缺点，当消费者下线时，生产的消息会丢失。\nRedis 如何实现延时队列？\n使用 sortedset，使用时间戳做 score，消息内容作为 key，调用 zadd 来生产消息，消费者使用 zrangbyscore 获取 n 秒之前的数据做轮询处理。\nRedis 回收进程如何工作的？\n\n\n一个客户端运行了新的命令，添加了新的数据。\n\n\nRedis 检查内存使用情况，如果大于 maxmemory 的限制， 则根据设定好的策略进行回收。\n\n\n一个新的命令被执行，等等。\n\n\n所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。\n\n\n如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。\n\n\nRedis 回收使用的是什么算法？\nLRU 算法（将最近最久未使用的页面予以淘汰。）\nRedis 常见性能问题和解决方案？\n\n\nMaster 最好不要做任何持久化工作，包括内存快照和 AOF 日志文件，特别是不要启用内存快照做持久化。\n\n\n如果数据比较关键，某个 Slave 开启 AOF 备份数据，策略为每秒同步一次。\n\n\n为了主从复制的速度和连接的稳定性，Slave 和 Master 最好在同一个局域网内。\n\n\n尽量避免在压力较大的主库上增加从库\n\n\nMaster 调用 BGREWRITEAOF 重写 AOF 文件，AOF 在重写的时候会占大量的 CPU 和内存资源，导致服务 load 过高，出现短暂服务暂停现象。\n\n\n为了 Master 的稳定性，主从复制不要用图状结构，用单向链表结构更稳定，即主从关系为：Master&lt;–Slave1&lt;–Slave2&lt;–Slave3…，这样的结构也方便解决单点故障问题，实现 Slave 对 Master 的替换，也即，如果 Master 挂了，可以立马启用 Slave1 做 Master，其他不变。\n\n\nRedis 官方为什么不提供 Windows 版本？\n因为目前 Linux 版本已经相当稳定，而且用户量很大，无需开发 windows 版本，反而会带来兼容性等问题。\n一个字符串类型的值能存储最大容量是多少？\n512M\nRedis 如何做大量数据插入？\nRedis2.6 开始 redis-cli 支持一种新的被称之为 pipe mode 的新模式用于执行大量数据插入工作。\n","categories":["面试","八股文"],"tags":["面试","八股文"]},{"title":"Activiti7 + dynamic-datasource 多数据源配置","url":"/posts/2dbd20ab/","content":"\n\n前言之前数据库不涉及多数据源的问题，本次引入 Activiti7 后需要配置单独的数据源。网上的方法都是自己写 bean 注入，然后在 SpringProcessEngineConfiguration 内进行 set 操作，但是出现了很大的问题。。。\n\n\n更新\n\n\n25-03-03 初始记录\n\n问题\n原参考文章如下：SpringBoot 给 Activiti7 配置单独数据源。\n根据文章配置，出现了原来配置的其他数据源失效，原先的事物注解 @Transactional 失效等问题。\n原因\n具体原因不清楚，目前只知道 @Bean 配置 PlatformTransactionManager 和 DataSource 会导致 dynamic-datasource 配置的默认数据源失效。\n解决\n从 DynamicDataSourceProvider 获取数据源并构建事物管理，具体配置信息如下。\n@Configuration  public class ActivitiDataSourceConfig extends AbstractProcessEngineAutoConfiguration &#123;        @Resource      private DynamicDataSourceProvider dynamicDataSourceProvider;        @Bean      public SpringProcessEngineConfiguration springProcessEngineConfiguration(ActivitiProperties activitiProperties) &#123;          SpringProcessEngineConfiguration conf = new SpringProcessEngineConfiguration();          DataSource dataSource = dynamicDataSourceProvider.loadDataSources().get(DBConstants.DATASOURCE_WORKFLOW);          conf.setDataSource(dataSource);          conf.setTransactionManager(new DataSourceTransactionManager(dataSource));          conf.setDeploymentName(activitiProperties.getDeploymentName());          conf.setDatabaseSchema(activitiProperties.getDatabaseSchema());          conf.setDatabaseSchemaUpdate(activitiProperties.getDatabaseSchemaUpdate());          conf.setDbHistoryUsed(activitiProperties.isDbHistoryUsed());          conf.setAsyncExecutorActivate(activitiProperties.isAsyncExecutorActivate());          if (!activitiProperties.isAsyncExecutorActivate()) &#123;              ValidatorSet springBootStarterValidatorSet = new ValidatorSet(&quot;activiti-spring-boot-starter&quot;);              springBootStarterValidatorSet.addValidator(new AsyncPropertyValidator());              if (conf.getProcessValidator() == null) &#123;                  ProcessValidatorImpl processValidator = new ProcessValidatorImpl();                  processValidator.addValidatorSet(springBootStarterValidatorSet);                  conf.setProcessValidator(processValidator);              &#125; else &#123;                  conf.getProcessValidator().getValidatorSets().add(springBootStarterValidatorSet);              &#125;          &#125;          conf.setMailServerHost(activitiProperties.getMailServerHost());          conf.setMailServerPort(activitiProperties.getMailServerPort());          conf.setMailServerUsername(activitiProperties.getMailServerUserName());          conf.setMailServerPassword(activitiProperties.getMailServerPassword());          conf.setMailServerDefaultFrom(activitiProperties.getMailServerDefaultFrom());          conf.setMailServerUseSSL(activitiProperties.isMailServerUseSsl());          conf.setMailServerUseTLS(activitiProperties.isMailServerUseTls());            conf.setHistoryLevel(activitiProperties.getHistoryLevel());          conf.setCopyVariablesToLocalForTasks(activitiProperties.isCopyVariablesToLocalForTasks());          conf.setSerializePOJOsInVariablesToJson(activitiProperties.isSerializePOJOsInVariablesToJson());          conf.setJavaClassFieldForJackson(activitiProperties.getJavaClassFieldForJackson());            if (activitiProperties.getCustomMybatisMappers() != null) &#123;              conf.setCustomMybatisMappers(getCustomMybatisMapperClasses(activitiProperties.getCustomMybatisMappers()));          &#125;            if (activitiProperties.getCustomMybatisXMLMappers() != null) &#123;              conf.setCustomMybatisXMLMappers(new HashSet&lt;&gt;(activitiProperties.getCustomMybatisXMLMappers()));          &#125;            if (activitiProperties.getCustomMybatisXMLMappers() != null) &#123;              conf.setCustomMybatisXMLMappers(new HashSet&lt;&gt;(activitiProperties.getCustomMybatisXMLMappers()));          &#125;            if (activitiProperties.isUseStrongUuids()) &#123;              conf.setIdGenerator(new StrongUuidGenerator());          &#125;            if (activitiProperties.getDeploymentMode() != null) &#123;              conf.setDeploymentMode(activitiProperties.getDeploymentMode());          &#125;          return conf;      &#125;  &#125;\n","categories":["bug记录","2025"],"tags":["Java"]},{"title":"聚合支付-功能实现","url":"/posts/8582b8be/","content":"\n\n前言之前的项目已经接触了支付宝、微信、银联三种支付方式了。正好把这个项目写一遍，看了技术栈有一些是没有接触过的，应该能学到很多。项目 git 地址：https://gitee.com/kiml_rgb/shanjupay.git\n前端项目地址：https://gitee.com/kiml_rgb/shanjupay_web\n\n\n更新\n\n\n25-04-07 迁移原笔记\n\n\n总结其实除了之前做过的内容，这个项目资料里只有一点重要：根据代码，项目中的聚合支付实现主要依靠==扫码接口的 request 中的 user-agent ==来判断浏览器类型，从而判断支付渠道，达到聚合支付的效果\n\n\n\n项目概述\n聚合支付目前主要的做法就是线上聚合收银台 (开放 API)，线下 C2B 一码多付、线下 B2C 商家扫码。平台应以 SaaS 服务形式提供给各商户订单管理、门店管理、财务数据统计等基础服务，闪聚支付还以支付为入口，通过广告、营销、金融等服务，构建一个移动支付的全生态系统。\n功能模块\n平台主要包括三个模块：官网&amp;开放平台、商户平台、运营平台，详细功能如下：\n\n\n\n\n功能模块名称\n功能说明\n\n\n\n\n官网&amp;开放平台\n产品展示、功能介绍、帮助中心和开发者中心\n\n\n商户平台 - 首页\n提供商户注册、登录、基本信息查看、数据看板\n\n\n商户平台 - 账户管理\n提供商户企业资质认证、企业信息查看和套餐购买\n\n\n商户平台 - 支付管理\n为商户提供应用创建、渠道参数配置、交易总览和开启支付 (生成二维码) 等\n\n\n商户平台 - 门店管理\n为商户提供新增门店、店长分配、门店导入等\n\n\n商户平台 - 员工管理\n为商户提供新增员工、定义角色、分配角色等\n\n\n商户平台 - 优惠管理\n为商户提供优惠券管理、活动统计等\n\n\n运营平台 - 商户管理\n对商户进行检索、审核和订单统计\n\n\n运营平台 - 优惠管理\n为商户设置优惠策略和优惠券发送\n\n\n运营平台 - 管理员管理\n运营平台 - 管理员管理\n\n\n\n业务主体流程\n\n项目技术架构\n技术架构\n\n技术栈\n\n重点了解微服务技术栈：\n服务端基于 Spring Boot 构建，采用 Spring Cloud Alibaba 微服务架构。\n\n\n基础设施业务数据持久化采用 MySQL，数据缓存采用 Redis，采用 RocketMQ 的事务消息机制完成部分场景下的分布式事务控制，采用第三方云平台完成文件上传与分布式存储。\n\n\n组件系统微服务基于 SpringBoot 开发，数据库连接池采用 Druid，POJO 构建采用 Lombok，日志系统采用 Log4j2， Guava 工具类库，Mybatis Plus 持久层接口实现，Sharding-jdbc 分库分表组件，Swagger 接口规范组件，XXL-job 分布式任务调度组件，Sentinel 限流组件等。\n\n\n接入 Zuul 网关完成客户端认证、路由转发等功能，Dubbo RPC 完成微服务远程调用，JWT 提供前后端令牌管理方案。\n\n\n视图平台支持 H5、PC 等各种前端。\n\n\n商户注册&amp;资质申请\n系统交互流程\n\n商户注册的流程由商户平台应用、商户服务、SaaS 平台、验证码服务四个微服务之间进行交互完成，各微服务的职责介绍如下：\n1）商户平台应用：此应用主要为商户提供业务功能，包括：商户资质申请、员工管理、门店管理等功能。\n2）商户服务： 提供商户管理的相关服务接口，供其它微服务调用，主要为商户平台应用提供接口服务，功能包括：商户基本信息管理、资质申请（这个功能蛮莫名其妙的，写了但是没有后续的审核操作，不知道干什么用的😥）、商户应用管理、渠道参数配置、商户员工信息管理、商户门店管理等。\n3）SaaS 平台：闪聚支付项目是一个 SaaS 平台 ，所谓 SaaS 平台即多个用户租用平台的业务功能，这样用户即可省去软件系统开发的成本，每个商户就是一个租户，所以又称为多租户系统。 SaaS 平台提供租户管理、账号管理、权限管理、资源管理、套餐管理、系统认证授权等功业务功能。在上图商户注册的流程中，商户注册的账号等信息需要写入 SaaS 平台，由 SaaS 平台统一管理账号，分配权限，商户统一通过 SaaS 平台登录闪聚支付。\n4）验证码服务：提供获取短信验证码、校验验证码的接口。 商户使用手机号进行注册，平台通过校验手机验证码来确认是否本人在注册。\n\n获取短信验证码\n短信验证码为一个开源的服务，可单独开启使用。\n开源 git 地址：(https://github.com/fightingape/sailing)\n\n大致看了一下这个开源项目是根据传入的业务名称，获取配置好的 code 长度和 Service 实现。后续应该还可以加入别的实现（比如阿里云的短信服务等）\n其中生成验证信息这个方法。\n1.根据业务名称 + 随机 UUID 生成 key 存入 redis。这个 key 会返回给服务请求方。\n2.根据配置好的 Map 获取名称对应的 len 即 code 码长度，如果传入不存在的 name，会直接报错。\n3.验证服务就是根据返回给服务请求方的 key，查询 Redis 缓存是否存在，不存在返回 false，即验证码错误。\n\n本项目中没有使用，只是简单控制台打印了一下。也可以直接在这个服务里存入 redis（因为要申请开通阿里云短信服务有点麻烦，又要多部署一个服务，而且这个功能比较简单不打算花时间开通了）。\n之前有写过阿里云的短信，关联文章：\n\n内链：[[【代码模板】阿里云接口实现短信发送]]\n外链：【代码模板】阿里云接口实现短信发送\n\n文件上传\n资质申请的流程中涉及到了文件上传的功能。之前已经写过使用 Minio 作为文件服务器和用阿里云 OSS 作为文件存储两种方式。这里的上传直接把七牛云换成了 Minio。顺便整理了一下之前写过的两种方式。\n文件上传：\n\n内链：[[【代码模板】文件存储]]\n外链：【代码模板】文件存储\n\n支付参数配置\n\n这个部分是项目的核心，之前做别的项目的时候，接触了微信支付和支付宝支付。就和这个项目中说的一样，用户只能先选择支付类型。再调用对应的接口获取支付二维码。而通过聚合支付这个平台，可以只生成一个链接，根据用户扫码，跳转不同的支付。\n\n商户应该配置哪些第三方支付渠道的参数\n服务类型是闪聚支付平台为商户提供的聚合支付服务通道，共分为线上和线下两大类：\n线上支付服务通道：\n\n\n手机 APP 支付\n\n\nPC 网页支付\n\n\n手机网页支付\n\n\n小程序支付\n线下支付服务通道：\n\n\n收款码支付 (C 扫 B)：即商户出示付款码，用户扫收款码完成支付。\n\n\nB 扫 C：即顾客出示付款码，商户扫描付款码。\n\n\n系统交互流程\n\n\n商户应用创建流程\n\n\n\n商户渠道参数配置交互流程\n交易服务职责：提供支付渠道参数配置、订单、发起支付、转账、退款等功能。\n\n\nC 扫 B\n\n1、为门店生成统一的支付二维码，用户扫一下二维码即可使用微信支付也可使用支付宝完成支付。\n2、闪聚支付平台与微信、支付宝对接，闪聚支付作为中介，最终的支付动作（银行交易）仍通过微信、支付宝进行。\n3、闪聚平台作为中介调用微信、支付宝的下单接口，完成支付。\n\n重点：根据代码，项目中的聚合支付实现主要依靠==扫码接口的 request 中的 user-agent ==来判断浏览器类型\n业务流程如下：\n\n生成二维码的系统交互流程如下：\n\n\n\n商户登录商户应用平台 ，查询门店列表\n\n\n商户平台请求交易服务获取门店二维码 URL\n\n\n商户平台根据 URL 生成二维码\n\n\n交易服务支付入口：\n\n\n\n顾客扫描二维码，请求交易服务支付入口\n\n\n交易服务解析请求，生成支付确认页面\n\n\n交易服务向服务响应支付确认页面\n\n\n支付宝统一下单接口对接：\n\n\n\n顾客输入金额，点击立即支付\n\n\n请求交易服务，交易服务保存订单\n\n\n交易服务调用支付渠道代理服务的支付宝下单接口\n\n\n支付渠道代理服务调用支付宝的统一下单接口。\n\n\n支付凭证返回\n\n\n\n支付宝支付相关内容：\n内链：[[【代码模板】支付宝支付接入]]\n外链：【代码模板】支付宝支付接入\n\n微信支付接口对接：\n\n微信支付相关内容：\n内链：[[【代码模板】微信支付接入]]\n外链：【代码模板】微信支付接入\n\n获取支付结果（RocketMQ）\n\n完成支付后第三方支付系统提供两种方式获取支付结果：\n\n\n第三方支付系统主动通知闪聚支付平台支付结果。\n\n\n闪聚支付平台主动从第三方支付系统查询支付结果。\n\n\n以上两种方法在实际项目中可以都用，其中第二种是必须用的，因为第一种是由第三方支付系统主动通知闪聚支付平台，当调用闪聚平台接口无法通信达到一定的次数后第三方支付系统将不再通知。\n\n对接 SAAS\n系统交互流程\n商户注册时与 SAAS 的交互流程已经在商户注册模块给出。\n分布式认证需求\n\n\n统一认证授权分布式系统的每个服务（系统）都会有认证、授权的需求，如果每个服务都实现一套认证授权逻辑会非常冗余，考虑分布式系统共享性的特点，需要由独立的认证服务来处理系统认证授权的请求。如下图，闪聚支付平台包括：商户平台应用、运营平台应用、门户应用，每个应用都需要身份认证，闪聚支付平台统一由 UAA 认证服务完成认证。\n\n\n\n开放认证体系考虑分布式系统开放性的特点，UAA 认证服务不仅服务于平台自身，并且对第三方系统也要提供认证，平台应提供扩展和开放的认证机制，以开放 API 的方式供第三方应用接入，一方应用（内部系统服务）和三方应用（第三方应用）均采用统一机制接入。\n\n\n分布式系统认证技术方案详见下图：\n\n流程所涉及到统一账号服务、UAA 服务、API 网关这三个组件职责如下:\n1） 统一账号服务：提供商户和平台运营人员的登录账号、密码、角色、权限、资源等系统级信息的管理，不包含用户业务信息。\n2） 统一认证服务：它承载了 OAuth2.0 接入方认证、登入用户的认证、授权以及生成令牌的职责，完成实际的用户认证、授权功能。\n3） API 网关：作为系统的唯一入口，API 网关为接入方提供定制的 API 集合，它可能还具有其它职责，如身份验证、监控、负载 均衡、缓存等。API 网关方式的核心要点是，所有的接入方和消费端都通过统一的网关接入微服务，在网关层处理 所有的非业务功能。\nBUG 记录\nRestTemplate 使用 GET 请求，返回中文乱码\n\n内链：[[RestTemplate使用GET请求，返回中文乱码]]\n外链：RestTemplate使用GET请求，返回中文乱码\n\n项目中访问 Swagger 地址，404（未解决）\n不管怎么访问 swagger 的页面地址，都返回 404。但是直接用 apifox 的 URL 导入，是可以成功的🥴。\n使用 mapstruct 转换对象，报错 Cannot find implementation for……\n这个项目中是因为 User 微服务没有依赖 mapstruct。但是 swagger 中有这个依赖，他直接用了 swagger 中的依赖。网上搜索还有一种情况可能出现这个问题。\n\n内链：[[使用mapstruct转换对象，报错Cannot find implementation for……]]\n外链：使用mapstruct转换对象，报错Cannot find implementation for……\n\n前端 JS 在 Long 长度大于 17 位时，出现精度丢失的问题\n\n内链：[[Long长度大于17位时，精度丢失]]\n外链：Long长度大于17位时，精度丢失\n\n使用 git 提交报错：error RPC failed; HTTP 413 curl 22 The requested URL returned error 413\n\n内链：[[使用 git 提交报错：error RPC failed; HTTP 413 curl 22 The requested URL returned error 413]]\n外链：使用 git 提交报错：error: RPC failed; HTTP 413 curl 22 The requested URL returned error: 413\n\n","categories":["后端项目","其他项目"],"tags":["Java"]},{"title":"社区中老年志愿者平台","url":"/posts/25cfff2e/","content":"\n\n前言本项目主要记录自接外包项目需要注意的点。项目 git 地址：https://gitee.com/kiml_rgb/silver-volunteer.git\n\n\n更新\n\n\n25-02-02 初始记录\n\n项目概述\n单体项目，分为小程序端和后台管理部分。本项目相关笔记主要用于记录对接外包项目需要注意的要点。\n技术栈\n\n\n\n层级\n技术\n\n\n\n\n视图\n小程序、Vue\n\n\n组件\nSpring boot、Log4j2、Mybatis Plus\n\n\n基础设施\nMysql、Minio\n\n\nDevOps\nMaven、Git\n\n\n\n准备\n收费\n\n\n\n项目\n计费标准\n\n\n\n\n阿里云服务器\n按阿里云报价信息（新人首年有折扣）\n\n\n域名\n一年一续费\n\n\n小程序认证费用\n每年 300\n\n\n开发费用\n\n\n\n\n时间\n\n\n\n项目\n时间\n备注\n\n\n\n\n小程序备案\n3 day\n企业资质\n\n\n小程序后台备案（服务器域名备案）\n3 day\n个人资质，与小程序备案资质可以不同，只需要后台可以访问\n\n\n阿里云短信资质审核\n1 day\n阿里云实名为个人，审核资质为自用\n\n\n阿里云短信签名审核（试用）\n2 hour\n自用资质在没有备案网站/上线 App 的情况下只能选择线上试用，线上试用短信有限制\n\n\n阿里云短信签名审核（已备案网站）\n7-10 day\n目前运营商实名报备流程平均需要 5-7 个工作日，部分运营商可能延长至7-10 个工作日。\n\n\n阿里云短信模板审核\n2 hour\n\n\n\n域名注册\n\n信息模板 实名认证\n\n\n\n服务器\n\n\n前后端项目\n\n\nJava 环境、MySQL 环境、Redis 环境\n\n\n文件存储服务（例：Minio）、docker 环境\n\n\n\n内链：[[装机-软件安装（Linux）]]\n外链：装机-软件安装（Linux）\n\n\n\nnginx\n\n\n\n内链：[[【代码模板】Nginx]]\n外链：【代码模板】Nginx\n\n\n\nssl 证书\n\n\n\n内链：[[Let’s Encrypt 免费申请泛域名 SSL 证书，并实现自动续期]]\n外链：Let’s Encrypt 免费申请泛域名 SSL 证书，并实现自动续期\n\nBUG\nemoji 表情保存报错\n","categories":["后端项目","其他项目"]},{"title":"【代码模板】Nginx","url":"/posts/bc551f67/","content":"\n\n前言Nginx 常用模板\n\n\n更新\n\n\n25-03-24 初始记录\n\n简单项目模板\nuser root;worker_processes  1;events &#123;    worker_connections  1024;&#125;http &#123;    include       mime.types;    default_type  application/octet-stream;    sendfile        on;    keepalive_timeout  65;    client_max_body_size 500M;    # HTTP server block, redirect to HTTPS 此部分内容可以由证书网站生成    server &#123;        listen       80;        server_name  sxqxyyl.cn www.sxqxyyl.cn;        # Redirect HTTP to HTTPS        return 301 https://$host$request_uri;    &#125;    # HTTPS server block    server &#123;        listen       443 ssl;        server_name  sxqxyyl.cn www.sxqxyyl.cn;        # SSL certificate and key        # SSL 相关内容可以由证书网站生成        location / &#123;            root  /root/frontend/dist;            index   index.html index.htm;  # 确保这是您的网站根目录            try_files $uri $uri/ /index.html;        &#125;\t\t# 前端访问路径配置为 /api        location /api/ &#123;            rewrite ^/api/(.*)$ /$1 break;  # 确保路径被重写为后端应用需要的格式            proxy_pass http://127.0.0.1:8888/;  # 将请求转发到后端服务            proxy_redirect off;            proxy_set_header Host $host;            proxy_set_header X-Real-IP $remote_addr;            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        &#125;        location /minio/ &#123;            proxy_pass http://127.0.0.1:9000/;  # MinIO 运行在 HTTP 9000 端口            proxy_set_header Host $host;            proxy_set_header X-Real-IP $remote_addr;            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        &#125;        # Error pages for 500, 502, 503, 504        error_page   500 502 503 504  /50x.html;        location = /50x.html &#123;            root  /root/frontend/dist;        &#125;    &#125;&#125;\n","categories":["后端项目","准备工作"],"tags":["Nginx"]},{"title":"【代码模板】支付宝支付接入","url":"/posts/fc17a9b8/","content":"\n\n前言支付宝支付接入流程\n\n\n更新\n\n\n24-07-19 初始记录\n\n支付产品\n支付宝为普通商户提供如下支付产品 https://b.alipay.com/page/product-workspace/all-product：\n\n配置支付宝沙箱环境\n接入手机网站支付需要具备如下条件：\n\n\n申请前必须拥有经过实名认证的支付宝账户；\n\n\n企业或个体工商户可申请；\n\n\n需提供真实有效的营业执照，且支付宝账户名称需与营业执照主体一致；\n\n\n网站能正常访问且页面显示完整，网站需要明确经营内容且有完整的商品信息；\n\n\n网站必须通过 ICP 备案。如为个体工商户，网站备案主体需要与支付宝账户主体名称一致；\n\n\n如为个体工商户，则团购不开放，且古玩、珠宝等奢侈品、投资类行业无法申请本产品。具体见：https://opendocs.alipay.com/open/203\n支付宝沙箱环境配置见：沙箱环境 - 支付宝文档中心 (alipay.com)\n\n\n注册开放平台账号\n支付宝开放平台地址：支付宝开放平台 (alipay.com)\n配置密钥\n进入沙箱页面：https://open.alipay.com/develop/sandbox/app\n\n启用证书模式，并根据提示完成对应的配置。\n测试环境准备\n我们在测试支付宝下单接口时需要使用支付宝扫描二维码，需要在手机安装支付宝客户端（沙箱版本），用沙箱账号登录支付宝，扫二维码，二维码的地址即为下单接口的地址。\n或者使用模拟器进行测试。模拟器安装地址：MuMu模拟器官网_安卓12模拟器_网易手游模拟器 (163.com)\n安装完成后进行登录。\n手机网站支付接口（H5）\n\n小程序文档 - 支付宝文档中心 (alipay.com)\n商家在网页应用中调用支付宝提供的网页支付接口，接口会调起支付宝客户端内的支付模块，此时会从商家网页应 用跳转到支付宝客户端中并开始支付；支付完成后会跳转回商家网页应用内，最后商家展示支付结果。\n\n接口交互\n手机网站支付快速接入 - 支付宝文档中心 (alipay.com)\n\n\n用户在商户的 H5 网站下单支付后，商户系统按照手机网站支付接口 alipay.trade.wap.payAPI 的参数规范生成订 单数据\n\n\n前端页面通过 Form 表单的形式请求到支付宝。此时支付宝会自动将页面跳转至支付宝 H5 收银台页面，如果用户手机上安装了支付宝 APP，则自动唤起支付宝 APP。\n\n\n输入支付密码完成支付。\n\n\n用户在支付宝 APP 或 H5 收银台完成支付后，会根据商户在手机网站支付 API 中传入的前台回跳地址 return_url 自动跳转回商户页面，同时在 URL 请求中以 Query String 的形式附带上支付结果参数，详细回跳参数见“手机网站支付接口 alipay.trade.wap.pay”前台回跳参数。\n\n\n支付宝还会根据原始支付 API 中传入的异步通知地址 notify_url，通过 POST 请求的形式将支付结果作为参数通知 到商户系统，详情见支付结果异步通知。\n\n\n下单接口定义\n请求地址：\n\n\n\n环境\nHttps 请求地址\n\n\n\n\n沙箱环境\nhttps://openapi.alipaydev.com/gateway.do\n\n\n正式环境\nhttps://openapi.alipay.com/gateway.do\n\n\n\n公共请求参数：请求参数说明 - 支付宝文档中心 (alipay.com)\n下单接口测试\n\n\nmaven 依赖\n\n\n&lt;dependency&gt;      &lt;groupId&gt;com.alipay.sdk&lt;/groupId&gt;      &lt;artifactId&gt;alipay-sdk-java&lt;/artifactId&gt;      &lt;version&gt;对应的最新版本&lt;/version&gt;  &lt;/dependency&gt;\n\n\n代码编写：可参考示例\n\n\n@Slf4j  @Controller  public class PayTestController &#123;      String APP_ID = &quot;XXX&quot;;      String APP_PRIVATE_KEY = &quot;XXX&quot;;      String ALIPAY_PUBLIC_KEY = &quot;XXX&quot;;      String CHARSET = &quot;utf‐8&quot;;      String serverUrl = &quot;https://openapi.alipaydev.com/gateway.do&quot;;      // 正式 &quot;https://openapi.alipay.com/gateway.do&quot;@GetMapping(&quot;/alipaytest&quot;)      public void alipaytest(HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws IOException &#123;         // 获得初始化的AlipayClient   AlipayClient alipayClient = new DefaultAlipayClient(serverUrl, APP_ID, APP_PRIVATE_KEY, &quot;json&quot;, CHARSET, ALIPAY_PUBLIC_KEY, &quot;RSA2&quot;);         // 创建API对应的 request               AlipayTradeWapPayRequest alipayRequest = new AlipayTradeWapPayRequest();         // 填充业务参数          alipayRequest.setBizContent(&quot;&#123;&quot; + &quot; \\&quot;out_trade_no\\&quot;:\\&quot;20150320010101123\\&quot;,&quot; + &quot; \\&quot;total_amount\\&quot;:\\&quot;0.01\\&quot;,&quot; + &quot; \\&quot;subject\\&quot;:\\&quot;Iphone6 16G\\&quot;,&quot; + &quot; \\&quot;product_code\\&quot;:\\&quot;QUICK_WAP_PAY\\&quot;&quot; + &quot; &#125;&quot;);          String form = &quot;&quot;;          try &#123;              // 调用SDK生成表单              form = alipayClient.pageExecute(alipayRequest).getBody();          &#125; catch (AlipayApiException e) &#123;              e.printStackTrace();          &#125;          httpResponse.setContentType(&quot;text/html;charset=&quot; + CHARSET);         // 直接将完整的表单html输出到页面          httpResponse.getWriter().write(form);          httpResponse.getWriter().flush();          httpResponse.getWriter().close();      &#125;  &#125;\n\n\n二维码生成指定二维码的 URL，模拟器/手机必须可以访问到此地址。（本机测试需要在同一个局域网内并使用局域网地址，或者使用内网穿透的地址）\n\n\n完整代码\n\n\n工具类\n\n\n@Slf4j  @Component  public class AlipayUtil &#123;        private static AlipayConfig alipayConfig;        public AlipayUtil(AlipayConfig alipayConfig)&#123;          AlipayUtil.alipayConfig = alipayConfig;      &#125;        /**       * 创建阿里云链接       * @param alipayConfig 支付宝支付配置       * @return AlipayClient       */    public static AlipayClient createClient(AlipayConfig alipayConfig) &#123;          AlipayClient alipayClient = null;          try &#123;              alipayConfig.setAppCertContent(ResourceUtil.readUtf8Str(alipayConfig.getAppCertPath()));              alipayConfig.setAlipayPublicCertContent(ResourceUtil.readUtf8Str(alipayConfig.getAlipayPublicCertPath()));              alipayConfig.setRootCertContent(ResourceUtil.readUtf8Str(alipayConfig.getRootCertPath()));              alipayClient = new DefaultAlipayClient(alipayConfig);          &#125; catch (AlipayApiException e) &#123;              log.error(&quot;AlipayClient创建失败:&quot; + e.getMessage());              // 构建异常日志              val operLog = OperLog.builder().title(&quot;支付宝支付&quot;)                      .businessType(BusinessType.OTHER.ordinal())                      .operUrl(alipayConfig.getServerUrl())                      .operParam(JSONUtil.toJsonPrettyStr(alipayConfig))                      .status(BusinessStatus.FAIL.ordinal())                      .errorMsg(e.getErrMsg())                      .build();              AsyncManager.me().execute(AsyncFactory.recordOper(operLog));          &#125;          return alipayClient;      &#125;        /**       * 预支付接口调用       * @param alipayTradePrecreateRequest 支付宝预支付接口请求       * @return AlipayTradePrecreateResponse 支付宝预支付接口返回       */      public static AlipayTradePrecreateResponse alipayTradePrecreate(AlipayTradePrecreateRequest alipayTradePrecreateRequest) &#123;          alipayTradePrecreateRequest.setNotifyUrl(alipayConfig.getNotifyUrl());          AlipayTradePrecreateResponse alipayTradePrecreateResponse = new AlipayTradePrecreateResponse();          try &#123;              alipayTradePrecreateResponse = createClient(alipayConfig).certificateExecute(alipayTradePrecreateRequest);                log.info(&quot;[返回参数]：\\n&quot; + JSONUtil.toJsonPrettyStr(alipayTradePrecreateResponse));                if(alipayTradePrecreateResponse.isSuccess())&#123;                  return alipayTradePrecreateResponse;              &#125; else &#123;                  log.error(alipayTradePrecreateResponse.getOutTradeNo() + &quot;支付宝支付失败:&quot; + alipayTradePrecreateResponse.getMsg());                  // 构建异常日志                  val operLog = OperLog.builder().title(&quot;支付宝支付&quot;)                          .businessType(BusinessType.OTHER.ordinal())                          .operUrl(alipayConfig.getServerUrl())                          .requestMethod(alipayTradePrecreateRequest.getApiMethodName())                          .operParam(JSONUtil.toJsonPrettyStr(alipayTradePrecreateRequest))                          .status(BusinessStatus.FAIL.ordinal())                          .errorMsg(JSONUtil.toJsonPrettyStr(alipayTradePrecreateResponse))                          .build();                  AsyncManager.me().execute(AsyncFactory.recordOper(operLog));              &#125;          &#125; catch (AlipayApiException e) &#123;              log.error(alipayTradePrecreateResponse.getOutTradeNo() + &quot;支付宝支付失败:&quot; + e.getMessage());              // 构建异常日志              val operLog = OperLog.builder().title(&quot;支付宝支付&quot;)                      .businessType(BusinessType.OTHER.ordinal())                      .operUrl(alipayConfig.getServerUrl())                      .operParam(JSONUtil.toJsonPrettyStr(alipayTradePrecreateRequest))                      .status(BusinessStatus.FAIL.ordinal())                      .errorMsg(e.getMessage())                      .build();              AsyncManager.me().execute(AsyncFactory.recordOper(operLog));          &#125;          return alipayTradePrecreateResponse;      &#125;        /**       * 订单查询接口调用       * @param alipayTradeQueryRequest 支付宝查单接口请求       * @return AlipayTradeQueryResponse 支付宝查单接口返回       */      public static AlipayTradeQueryResponse alipayTradeQuery(AlipayTradeQueryRequest alipayTradeQueryRequest) &#123;          AlipayTradeQueryResponse alipayTradeQueryResponse = new AlipayTradeQueryResponse();          try &#123;              alipayTradeQueryResponse = createClient(alipayConfig).certificateExecute(alipayTradeQueryRequest);              if(alipayTradeQueryResponse.isSuccess())&#123;                  log.info(&quot;支付宝查单返回：&quot; + JSONUtil.toJsonPrettyStr(alipayTradeQueryResponse));                  return alipayTradeQueryResponse;              &#125; else &#123;                  log.error(alipayTradeQueryResponse.getOutTradeNo() + &quot;支付宝查单失败:&quot; + alipayTradeQueryResponse.getMsg());                  // 构建异常日志                  val operLog = OperLog.builder().title(&quot;支付宝查单&quot;)                          .businessType(BusinessType.OTHER.ordinal())                          .operUrl(alipayConfig.getServerUrl())                          .requestMethod(alipayTradeQueryRequest.getApiMethodName())                          .operParam(JSONUtil.toJsonPrettyStr(alipayTradeQueryRequest))                          .status(BusinessStatus.FAIL.ordinal())                          .errorMsg(alipayTradeQueryResponse.getMsg())                          .build();                  AsyncManager.me().execute(AsyncFactory.recordOper(operLog));              &#125;          &#125; catch (AlipayApiException e) &#123;              log.error(alipayTradeQueryResponse.getOutTradeNo() + &quot;支付宝查单失败:&quot; + e.getMessage());              // 构建异常日志              val operLog = OperLog.builder().title(&quot;支付宝查单&quot;)                      .businessType(BusinessType.OTHER.ordinal())                      .operUrl(alipayConfig.getServerUrl())                      .operParam(JSONUtil.toJsonPrettyStr(alipayTradeQueryRequest))                      .status(BusinessStatus.FAIL.ordinal())                      .errorMsg(e.getMessage())                      .build();              AsyncManager.me().execute(AsyncFactory.recordOper(operLog));          &#125;          return alipayTradeQueryResponse;      &#125;        /**       * 支付宝订单关闭       * @param alipayTradeCloseRequest 支付宝关单接口请求       * @return AlipayTradeCloseResponse 支付宝关单接口返回       */      public static AlipayTradeCloseResponse alipayTradeClose(AlipayTradeCloseRequest alipayTradeCloseRequest) &#123;          AlipayTradeCloseResponse alipayTradeQueryResponse = new AlipayTradeCloseResponse();          try &#123;              alipayTradeQueryResponse = createClient(alipayConfig).certificateExecute(alipayTradeCloseRequest);              if(alipayTradeQueryResponse.isSuccess())&#123;                  return alipayTradeQueryResponse;              &#125; else &#123;                  log.error(alipayTradeQueryResponse.getOutTradeNo() + &quot;支付宝关单失败:&quot; + alipayTradeQueryResponse.getMsg());                  // 构建异常日志                  val operLog = OperLog.builder().title(&quot;支付宝关单&quot;)                          .businessType(BusinessType.OTHER.ordinal())                          .operUrl(alipayConfig.getServerUrl())                          .requestMethod(alipayTradeCloseRequest.getApiMethodName())                          .operParam(JSONUtil.toJsonPrettyStr(alipayTradeCloseRequest))                          .status(BusinessStatus.FAIL.ordinal())                          .errorMsg(alipayTradeQueryResponse.getSubMsg())                          .build();                  AsyncManager.me().execute(AsyncFactory.recordOper(operLog));              &#125;          &#125; catch (AlipayApiException e) &#123;              log.error(alipayTradeQueryResponse.getOutTradeNo() + &quot;支付宝关单失败:&quot; + e.getMessage());              // 构建异常日志              val operLog = OperLog.builder().title(&quot;支付宝关单&quot;)                      .businessType(BusinessType.OTHER.ordinal())                      .operUrl(alipayConfig.getServerUrl())                      .operParam(JSONUtil.toJsonPrettyStr(alipayTradeCloseRequest))                      .status(BusinessStatus.FAIL.ordinal())                      .errorMsg(e.getMessage())                      .build();              AsyncManager.me().execute(AsyncFactory.recordOper(operLog));          &#125;          return alipayTradeQueryResponse;      &#125;  &#125;\n\n\n创建支付宝 V3 版本请求对象\n\n\nprivate AlipayTradePrecreateRequest createAlipayBeanV3ByOrder(Order order) &#123;      AlipayTradePrecreateRequest alipayTradePrecreateRequest = new AlipayTradePrecreateRequest();      JSONObject bizContent = new JSONObject();      bizContent.set(&quot;out_trade_no&quot;, order.getOrderNo());      // 支付宝支付 订单总金额，单位为元，精确到小数点后两位，取值范围为 [0.01,100000000]，金额不能为 0。      bizContent.set(&quot;total_amount&quot;, order.getTotal());  \t// 标题部分根据需求修改    // String subject = order.getGoodName();      // if (ObjectUtil.isNotEmpty(order.getSize())) &#123;      //     subject = subject + &quot;[&quot; + order.getSize() + &quot;]&quot;;      // &#125;      // subject = &quot;x-design风格化定制周边订单_&quot; + subject;        bizContent.set(&quot;subject&quot;, subject);        alipayTradePrecreateRequest.setBizContent(bizContent.toString());      return alipayTradePrecreateRequest;  &#125;\n\n\n支付宝查单\n\n\nprivate BaseResponse&lt;Integer&gt; getAlipayBaseResponse(Order order, HttpServletRequest request) &#123;      AlipayTradeQueryRequest alipayTradeQueryRequest = new AlipayTradeQueryRequest();      JSONConfig jsonConfig = new JSONConfig();      jsonConfig.setIgnoreNullValue(false);      JSONObject bizContent = new JSONObject(jsonConfig);      bizContent.set(&quot;out_trade_no&quot;, order.getOrderNo());      bizContent.set(&quot;trade_no&quot;, null);      alipayTradeQueryRequest.setBizContent(bizContent.toString());      log.info(&quot;订单：&quot; + order.getOrderNo() + &quot;支付宝查单：&quot; + JSONUtil.parse(alipayTradeQueryRequest));      AlipayTradeQueryResponse alipayTradeQueryResponse = AlipayUtil.alipayTradeQuery(alipayTradeQueryRequest);      log.info(&quot;订单：&quot; + order.getOrderNo() + &quot;支付宝查单结果：&quot; + JSONUtil.parse(alipayTradeQueryResponse));      // 支付宝订单号      String tradeNo = alipayTradeQueryResponse.getTradeNo();      OtherPayInfo otherPayInfo = new OtherPayInfo();      otherPayInfo.setTradeNo(tradeNo);      // 支付时间      LocalDateTime time = null;      if (ObjectUtil.isNotNull(alipayTradeQueryResponse.getSendPayDate())) &#123;          time =  LocalDateTime.ofInstant(alipayTradeQueryResponse.getSendPayDate().toInstant(), ZoneId.systemDefault());      &#125;        // 客户未扫码直接调用会出现订单不存在      if (ObjectUtil.isNull(alipayTradeQueryResponse.getTradeStatus())) &#123;          return new BaseResponse&lt;&gt;(VMSystem.ORDER_STATUS_CREATE);      &#125;        if (&quot;TRADE_SUCCESS&quot;.equals(alipayTradeQueryResponse.getTradeStatus())) &#123;  \t    // 其他业务需求 修改订单信息 发送打印邮件等        // // 修改订单信息          // val updateOrderByWx = this.updateOrderStatusByPay(order.getOrderNo(), time, VMSystem.ORDER_STATUS_PAYED, otherPayInfo);          // // 发送打印邮件          // this.sendMailtoPrint(order);          // if (updateOrderByWx) &#123;          //     return new BaseResponse&lt;&gt;(VMSystem.ORDER_STATUS_PAYED);          // &#125; else &#123;          //     throw new LogicException(&quot;订单状态更新异常&quot;);          // &#125;      &#125; else if (&quot;WAIT_BUYER_PAY&quot;.equals(alipayTradeQueryResponse.getTradeStatus())) &#123;          return new BaseResponse&lt;&gt;(VMSystem.ORDER_STATUS_CREATE);      &#125; else &#123;          log.error(order.getOrderNo() + &quot;支付宝支付失败:网关描述：&quot; + alipayTradeQueryResponse.getMsg() + &quot;业务描述：&quot; + alipayTradeQueryResponse.getSubMsg());          // 构建异常日志          OperLog operLog = OperLog.builder().title(&quot;支付宝支付&quot;)                  .businessType(BusinessType.OTHER.ordinal())                  .operIp(IpUtils.getIpAddr(request))                  .operParam(JSONUtil.toJsonPrettyStr(alipayTradeQueryRequest.getTextParams()))                  .status(BusinessStatus.FAIL.ordinal())                  .method(alipayTradeQueryRequest.getApiMethodName())                  .requestMethod(&quot;GET&quot;)                  .errorMsg(&quot;支付宝支付失败:网关描述：&quot; + alipayTradeQueryResponse.getMsg() + &quot;业务描述：&quot; + alipayTradeQueryResponse.getSubMsg())                  .build();          AsyncManager.me().execute(AsyncFactory.recordOper(operLog));          // 修改订单信息          this.updateOrderStatusByPay(order.getOrderNo(), time, VMSystem.ORDER_STATUS_FAILED, otherPayInfo);          val baseResponse = new BaseResponse&lt;&gt;(VMSystem.ORDER_STATUS_FAILED);          baseResponse.setMessage(&quot;支付宝支付失败:网关描述：&quot; + alipayTradeQueryResponse.getMsg() + &quot;业务描述：&quot; + alipayTradeQueryResponse.getSubMsg());          return baseResponse;      &#125;  &#125;\n\n\n订单关闭\n\n\n// 支付宝订单关闭  AlipayTradeCloseRequest alipayTradeCloseRequest = new AlipayTradeCloseRequest();  JSONConfig jsonConfig = new JSONConfig();  jsonConfig.setIgnoreNullValue(false);  JSONObject bizContent = new JSONObject();  bizContent.set(&quot;out_trade_no&quot;, order.getOrderNo());  bizContent.set(&quot;trade_no&quot;, order.getTradeNo());  alipayTradeCloseRequest.setBizContent(bizContent.toString());  AlipayUtil.alipayTradeClose(alipayTradeCloseRequest);\nBUG\n验签出错，建议检查签名字符串或签名私钥与应用公钥是否匹配\n\n技术文档：https://opendocs.alipay.com/support/01ravw\n问题原因\n密钥不匹配、编码格式不统一（本次测试后更换中文编码格式）、请求参数数据有误、接口调用加签方式和应用上选择的加签方式不对应、SDK 调用的提交方法有误、SDK 运行环境有误\n\n","categories":["后端项目","准备工作"],"tags":["Java","代码模板"]},{"title":"Let’s Encrypt 免费申请泛域名 SSL 证书，并实现自动续期","url":"/posts/a1d28c6/","content":"\n\n前言参考文章：使用 Let’s Encrypt 免费申请泛域名 SSL 证书，并实现自动续期\n\n\n更新\n\n\n25-04-07 初始记录\n\n环境准备\n\n\n一台可以访问互联网的服务器（Linux 环境，如 Ubuntu/CentOS）。\n\n\nRoot 权限或 sudo 权限。\n\n\n一个已解析的域名（本文以 example.com 为例）。\n\n\nCertbot 自动安装\n\n\n选择安装环境\n\n\n\nInstall system dependencies\nFor APT-based distributions (e.g. Debian, Ubuntu …):\n\n\nsudo apt updatesudo apt install python3 python3-venv libaugeas0\nFor RPM-based distributions (e.g. Fedora, CentOS …):\nsudo dnf install python3 augeas-libs\n\n\nRemove certbot-auto and any Certbot OS packages\n\n\nSet up a Python virtual environment\n\n\nsudo python3 -m venv /opt/certbot/sudo /opt/certbot/bin/pip install --upgrade pip\n\n\nInstall Certbot\n\n\nsudo /opt/certbot/bin/pip install certbot certbot-nginx\n\n\nPrepare the Certbot command\n\n\nsudo ln -s /opt/certbot/bin/certbot /usr/bin/certbot\n申请单域名 SSL 证书\n\n\nChoose how you’d like to run Certbot\n\n\nsudo certbot --nginx# 手动配置 nginxsudo certbot certonly --nginx\n\n这里获取 nginx 默认的配置位置在 /etc/nginx。可以为自己安装完成的 nginx 创建软链到此目录下\n\n\n\nsudo certbot certonly --nginx\n\n\necho &quot;0 0,12 * * * root /opt/certbot/bin/python -c &#x27;import random; import time; time.sleep(random.random() * 3600)&#x27; &amp;&amp; sudo certbot renew -q&quot; | sudo tee -a /etc/crontab &gt; /dev/null\n\n\nConfirm that Certbot worked\n\n\n","categories":["后端项目","准备工作"]},{"title":"SonarQube与GitLab集成（一）","url":"/posts/7d0e1c35/","content":"\n\n前言最近比较闲，分配了这个任务，顺便做个笔记。更新第二版方案，更适合生产环境。\n\n\n参考文章在 gitlab ci/cd 流程中集成 sonar 进行自动 Code Review\ngitlab Runner 安装与部署\n\n\n更新\n\n\n24-12-11 初始记录24-12-12 完成SonarQube与插件的安装24-12-16 maven 与 多模块项目\n\n准备工作\n\n\nSonarQube：选择适合项目的 SonarQube 版本。~Java8 适配的 SonarQube 版本最高为 7.8~。这里部署的是： docker 方式的 9.9 LTS 版本官方长期支持版本。\n\n\nGitLab：14.9.1 版本\n\n\n# 可以通过以下命令查看cat /opt/gitlab/embedded/service/gitlab-rails/VERSION\n\n\ndocker：Docker version 20.10.17, build 100c701。官方推荐版本 20.10 以上。\n\n\nGitlab CI\n\n\nSonarScanner/Maven + Java 11\n\n\nSonarQube 安装\n\n\ndocker-compose.yml\n\n\nversion: &quot;3&quot;services:  sonarqube:    image: sonarqube:9.9-community    depends_on:      - db    environment:      SONAR_JDBC_URL: jdbc:postgresql://db:5432/sonar      SONAR_JDBC_USERNAME: sonar      SONAR_JDBC_PASSWORD: sonar    volumes:      - sonarqube_data:/opt/sonarqube/data      - sonarqube_extensions:/opt/sonarqube/extensions      - sonarqube_logs:/opt/sonarqube/logs      - sonarqube_conf:/opt/sonarqube/conf    ports:      - &quot;9000:9000&quot;  db:    image: postgres:15.3    environment:      POSTGRES_USER: sonar      POSTGRES_PASSWORD: sonar    volumes:      - postgresql:/var/lib/postgresql      - postgresql_data:/var/lib/postgresql/datavolumes:  sonarqube_data:\texternal: true  sonarqube_extensions:\texternal: true  sonarqube_logs:\texternal: true  sonarqube_conf:\texternal: true  postgresql:  postgresql_data:\n\n\ndocker-compose 命令\n\n\n# 前台启动, 启动项目中的所有服务。docker-compose up# 后台启动, 启动所有服务并在后台运行。 docker-compose up -d# -f 指定使用的Compose模板文件，默认为docker-compose.yml，可以多次指定docker-compose -f docker-compose.yml up -d# 列出项目中目前的所有容器docker-compose ps # 停止所有服务。docker-compose stop# 停止和删除容器、网络、卷、镜像。docker-compose down# 删除已经在compose文件中定义的和匿名的附在容器上的数据卷docker-compose down -v\nSonarQube 插件安装\nSonarQube 有两个插件：\n\n\nhttps://github.com/javamachr/sonar-gitlab-plugin\n\n\nhttps://github.com/mc1arke/sonarqube-community-branch-plugin\n第一个插件可以将 SonarQube 的审查结果以评论的试发布到 gitlab 上面。暂未使用第二个插件可以实现增强 SonarQube 多分支包括 MR 的代码检测。\n\n\n\n\n下载 sonar-gitlab-plugin 对应 5.4 版本的 jar 包\n\n\n下载 sonarqube-community-branch-plugin 对应 1.14.0 的 jar 包\n\n\n上传 jar 包到挂载的 sonarqube_extensions 目录里面的 plugins 目录里面。上传到 JumpServer 可以在目录下输入：rz；下载为 sz\n\n\n修改挂载的 sonarqube_conf 目录路径下面的 sonar.properties 配置文件，添加如下配置\n\n\nsonar.web.javaAdditionalOpts=-javaagent:./extensions/plugins/sonarqube-community-branch-plugin-1.14.0.jar=websonar.ce.javaAdditionalOpts=-javaagent:./extensions/plugins/sonarqube-community-branch-plugin-1.14.0.jar=ce\n\n\n重启 SonarQube\n\n\nGitlab CI 安装与注册\n\n\n版本确认\n\n\n\n\n安装与 Gitlab 一致的 Gitlab-Runner 版本。\n\n\nwget https://mirrors.tuna.tsinghua.edu.cn/gitlab-runner/yum/el7/gitlab-runner-14.9.0-1.x86_64.rpm --no-check-certificatesudo rpm -ivh gitlab-runner-14.9.0-1.x86_64.rpm# 查看是否安装成功gitlab-runner -v\n\n\n指定 gitlab-runner 用户为 root 用户\n\n\nsudo gitlab-runner uninstall sudo gitlab-runner install --working-directory /home/zwadmin --user zwadmin\n\n\n启动 gitlab 服务\n\n\nsystemctl daemon-reload/bin/systemctl start gitlab-runner/bin/systemctl enable gitlab-runner/bin/systemctl restart gitlab-runner\n\n\n设置权限\n\n\nchown -R zwadmin.zwadmin /home/gitlab-runner\n\n\n注册服务\n\n\ngitlab-runner register#输入公司的gitlab公网地址 Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com/): https://gitlab.wuidm.com/#输入gitlab的token Please enter the gitlab-ci token for this runner:  #输入描述这个runner名称 Please enter the gitlab-ci description for this runner: [k8s-node02]: test#输入runner的标签 Please enter the gitlab-ci tags for this runner (comma separated): my-tag,another-tag Registering runner... succeeded runner=8sjydnrs #输入runner执行器的环境 Please enter the executor: custom, docker-ssh, parallels, kubernetes, docker-ssh+machine, docker, shell, ssh, virtualbox, docker+machine: shell \n\nSonarScanner 安装\n\n多模块项目建议用 Maven，这部分可以不看\n\n\n\n官网下载\n\n\n上传服务器后，解压\n\n\n配置环境变量\n\n\nsudo vim /etc/profile# 添加以下语句export SONARRUNNER_HOME=/home/zwadmin/soft/sonar-scanner/sonar-scanner-6.2.1.4610-linux-x64export PATH=$SONARRUNNER_HOME/bin:$PATHsudo source /etc/profile# 查看是否安装成功sonar-scanner -v\nMaven 安装\n\nMaven 更适配多模块项目\n\n\n\n官网下载\n\n\n上传服务器后，解压\n\n\n配置环境变量\n\n\nsudo vim /etc/profile# 添加以下语句export M2_HOME=/opt/maven export PATH=$M2_HOME/bin:$PATHsource /etc/profile# 查看是否安装成功mvn -v\n与 Gitlab 集成\n\n\n登录 gitlab.com，创建一个测试仓库，并在用户设置里面，创建一个个人访问令牌。\n\n\n\n登录 SonarQube，在 project 管理里面即可通过这个个人访问令牌来导入 gitlab 上面的项目\n\n\n\n导入后，选择以 gitlab ci 的方式来执行 ci 流程前提 gitlab ci 开启\n\n\n\n根据提示，完成所有步骤。\n\n\n\n\n在项目中创建 sonar-project.properties， 并粘贴提示内的内容。多分支指定分支需要下载 sonarqube-community-branch-plugin 插件。额外添加 sonar.branch.name=XXX\n\n\n\n在 gitlab 的设置， CI/CD 设置里面，添加环境变量\n\n\n在项目里面创建一个 .gitlab-ci.yml 文件，并按照提示贴入最小化配置内容\n\n\nsonarqube-check:    tags:      - test    variables:      SONAR_USER_HOME: &quot;$&#123;CI_PROJECT_DIR&#125;/.sonar&quot;  # Defines the location of the analysis task cache      GIT_DEPTH: &quot;0&quot;  # Tells git to fetch all the branches of the project, required by the analysis task    cache:      key: &quot;$&#123;CI_JOB_NAME&#125;&quot;      paths:        - .sonar/cache    script:      - sonar-scanner    allow_failure: true    only:      - master  #    - merge_requests  #    - develop\n\n\n在 SonarQube 的通用配置里面，配置好 base URL， 以方便在 gitlab 的评论里面能够正确连接到 SonarQube 平台。\n\n\n\n使用 Maven 与 Gitlab 集成\n\nMaven 更适配多模块项目，1、2、3、5 步骤相同，4 配置如下\n\n\n\n在父项目 pom.xml 文件中添加配置\n\n\n&lt;properties&gt;    &lt;sonar.qualitygate.wait&gt;true&lt;/sonar.qualitygate.wait&gt;&lt;/properties&gt;&lt;build&gt;    &lt;pluginManagement&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.sonarsource.scanner.maven&lt;/groupId&gt;                &lt;artifactId&gt;sonar-maven-plugin&lt;/artifactId&gt;                &lt;version&gt;3.11.0.3922&lt;/version&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/pluginManagement&gt;&lt;/build&gt;\n\n\n在 gitlab 的设置， CI/CD 设置里面，添加环境变量\n\n\n在项目里面创建一个 .gitlab-ci.yml 文件，并按照提示贴入最小化配置内容\n\n\nsonarqube-check:  tags:    - sonar  variables:    SONAR_USER_HOME: &quot;$&#123;CI_PROJECT_DIR&#125;/.sonar&quot;  # Defines the location of the analysis task cache    GIT_DEPTH: &quot;0&quot;  # Tells git to fetch all the branches of the project, required by the analysis task  cache:    key: &quot;$&#123;CI_JOB_NAME&#125;&quot;    paths:      - .sonar/cache  script:    - JAVA_HOME=/home/zwadmin/data/jdk-11/ &amp;&amp; export JAVA_HOME    - mvn verify sonar:sonar -Dsonar.projectKey=com.ydm:zw-ydm -Dsonar.branch.name=feature/sonar-1216  allow_failure: true  only:    - feature/sonar-1216#    - merge_requests\n整合 IDEA 插件\n\n用于同步服务器上的规则、质量配置文件和文件排除设置。\n\n\n\n创建 token 类型为用户\n\n\n\nIDEA Plugins Marketplace 下载 SonarQube for IDE。\n\n\n连接到 SonarQube。\n\n\n\n\n配置项目\n\n\n\n完整版 .gitlab-ci.yml\nstages:    - sonarqube    - notify    - noop  sonarqube-check:    stage: sonarqube    tags:      - sonar    variables:      SONAR_USER_HOME: &quot;$&#123;CI_PROJECT_DIR&#125;/.sonar&quot;  # Defines the location of the analysis task cache      GIT_DEPTH: &quot;0&quot;  # Tells git to fetch all the branches of the project, required by the analysis task    cache:      key: &quot;$&#123;CI_COMMIT_REF_NAME&#125;&quot; # 使用分支名作为缓存的 key    paths:        - .sonar/cache    script:      - JAVA_HOME=*** &amp;&amp; export JAVA_HOME      - export SONAR_JAVA_OPTS=&quot;-Xmx2G -Xms1G&quot;      - mvn verify sonar:sonar -T 10 -Dsonar.projectKey= -Dsonar.branch.name=master -Dmaven.test.skip=true -Dsonar.qualitygate.wait=false -Dsonar.ce.parallel=1 -Dmaven.repo.local=***  allow_failure: false    rules:      # 如果 SKIP_SONAR 为 &quot;true&quot;，跳过任务      - if: &#x27;$SKIP_SONAR == &quot;true&quot;&#x27;        when: never      # 在合并请求时触发      - if: &#x27;$CI_PIPELINE_SOURCE == &quot;merge_request_event&quot;&#x27;    sonar_to_feishu:    stage: notify    tags:      - sonar    script:      - |        response=$(curl -u admin:123456Aa -s &quot;***/api/qualitygates/project_status?projectKey=com.ydm%3Azw-ydm&amp;branch=master&quot;)                echo &quot;$response&quot;                quality_gate_status=$(echo &quot;$response&quot; | grep -o &#x27;&quot;status&quot;:&quot;[^&quot;]*&quot;&#x27; | head -n 1 | sed &#x27;s/&quot;status&quot;:&quot;\\([^&quot;]*\\)&quot;/\\1/&#x27;)                echo &quot;$quality_gate_status&quot;                if [ &quot;$quality_gate_status&quot; == &quot;OK&quot; ]; then          status=&quot;通过 (OK)&quot;        else          status=&quot;未通过 (ERROR)&quot;        fi                echo &quot;请求飞书&quot;                curl -X POST -H &quot;Content-Type: application/json&quot; \\          -d &quot;&#123;              \\&quot;msg_type\\&quot;: \\&quot;post\\&quot;,              \\&quot;content\\&quot;: &#123;                \\&quot;post\\&quot;: &#123;                  \\&quot;zh_cn\\&quot;: &#123;                    \\&quot;title\\&quot;: \\&quot;SonarQube 分析完成\\&quot;,                    \\&quot;content\\&quot;: [                      [&#123;                        \\&quot;tag\\&quot;: \\&quot;text\\&quot;,                        \\&quot;text\\&quot;: \\&quot;项目：zw-ydm\\n分支：master\\n状态：$status\\n仪表盘：\\&quot;                      &#125;, &#123;                        \\&quot;tag\\&quot;: \\&quot;a\\&quot;,                        \\&quot;text\\&quot;: \\&quot;点击查看\\&quot;,                        \\&quot;href\\&quot;: \\&quot;***/dashboard?id=com.ydm%3Azw-ydm&amp;branch=master\\&quot;                      &#125;]                    ]                  &#125;                &#125;              &#125;          &#125;&quot; \\        https://open.feishu.cn/open-apis/bot/v2/hook/***  needs:      - sonarqube-check    rules:      # 如果 SKIP_SONAR 为 &quot;true&quot;，跳过任务      - if: &#x27;$SKIP_SONAR == &quot;true&quot;&#x27;        when: never      # 在合并请求时触发      - if: &#x27;$CI_PIPELINE_SOURCE == &quot;merge_request_event&quot;&#x27;    noop:    tags:      - sonar    stage: noop    script:      - echo &quot;Pipeline skipped all main jobs.&quot;    rules:      # 在合并请求时触发      - if: &#x27;$CI_PIPELINE_SOURCE == &quot;merge_request_event&quot;&#x27;\nBUG 记录\ndocker 拉取失败 (Client.Timeout exceeded while awaiting headers)\n\n内链：[[Docker拉取失败 (Client.Timeout exceeded while awaiting headers)]]\n外链：Docker拉取失败 (Client.Timeout exceeded while awaiting headers)\n\ndocker-compose 加载挂载卷，只加载默认\n\n未完全解决。有一个较麻烦的方法。\n\n\n\n手动挂载卷\n\n\nsudo docker volume create --driver local --opt type=none --opt device=/home/zwadmin/data/docker/sonarqube/data --opt o=bind sonarqube_datasudo docker volume create --driver local --opt type=none --opt device=/home/zwadmin/data/docker/sonarqube/extensions --opt o=bind sonarqube_extensionssudo docker volume create --driver local --opt type=none --opt device=/home/zwadmin/data/docker/sonarqube/logs --opt o=bind sonarqube_logssudo docker volume create --driver local --opt type=none --opt device=/home/zwadmin/data/docker/sonarqube/conf --opt o=bind sonarqube_conf\n\n\n在 docker-compose.yml 中从外部加载卷\n\n\nvolumes:  sonarqube_data:\texternal: true\n","categories":["后端项目","准备工作"],"tags":["GitLab","SonarQube"]},{"title":"SonarQube 与 GitLab 集成（二）","url":"/posts/6041b6ab/","content":"\n\n前言sonar 脚本之前一直在测试分支上跑，虽然有每次构建拉取事件很长的毛病，但影响不大还能忍受。最近把 sonar 上到 master 环境中，出现了大问题。。。\n\n\n更新\n\n\n25-04-11 初始记录\n\n问题\n\n\ngitlab CI cancel 之后，后台 maven 子进程并没有被杀死，导致第二个 runner 服务依旧处于 pedding 状态。前台多次操作 cancel 并重启后，服务器资源直接耗尽，需要重启 sonar 所在的服务器才行。未解决（加了每次服务启动前关闭别的扫描服务，好像并没有什么用）\n\n\n虽然之前添加了插件，但是没有使用 sonar 的 PR/MR 扫描模式，每次都是全量进行扫描，并且加上了 merge 阻断，导致每次都需要 merge 前等待，耗时较久。已解决\n\n\nsonar 的 webhook 要转发到飞书，之前偷懒没有写一个服务进行转发，导致卡片样式比较难看。已解决\n\n\nPR/MR 扫描模式\n\n添加了这种扫描模式之后，由于新代码是与 master 分支进行比较，需要写一个定时的 ci 对 master 分支进行全量的扫描\n\n.gitlab-ci.yml\nstages:    - sonarqube    - noop  sonarqube-check:    stage: sonarqube    tags:      - sonar    variables:      SONAR_USER_HOME: &quot;$&#123;CI_PROJECT_DIR&#125;/.sonar&quot;  # Defines the location of the analysis task cache      GIT_DEPTH: &quot;0&quot;  # Tells git to fetch all the branches of the project, required by the analysis task    cache:      key: sonar-cache      paths:        - .sonar/cache    before_script:      - echo &quot;检查并终止之前的 Maven 进程...&quot;      - |        # 查找并终止之前的 Maven 进程        maven_pids=$(pgrep -f &quot;gitlab_sonarci_run&quot; || true)        if [ -n &quot;$maven_pids&quot; ]; then            echo &quot;发现之前的 Maven 进程，正在终止...&quot;            echo &quot;$maven_pids&quot; | xargs kill -TERM || true            echo &quot;$maven_pids &quot; | xargs wait || true        else            echo &quot;未发现之前的 Maven 进程。&quot;        fi    script:      - JAVA_HOME=你的服务地址 &amp;&amp; export JAVA_HOME      - export SONAR_JAVA_OPTS=&quot;-Xmx2G -Xms1G&quot;      - |        echo &quot;启动 SonarQube 分析...&quot;        run_scan() &#123;          mvn verify sonar:sonar -T 2 \\          -Dsonar.projectKey=你的key \\          # 这部分数据会在 merge_request_event 时由 gitlab 进行填充        -Dsonar.pullrequest.key=$CI_MERGE_REQUEST_IID \\          -Dsonar.pullrequest.branch=$CI_COMMIT_REF_NAME \\          -Dsonar.pullrequest.base=$CI_MERGE_REQUEST_TARGET_BRANCH_NAME \\          -Dmaven.test.skip=true \\          -Dsonar.qualitygate.wait=true \\          -Dsonar.ce.parallel=1 \\          -Dmaven.repo.local=你的本地仓库 \\          -s 你的maven配置地址 \\          -Dci.tag=gitlab_sonarci_run &amp;        &#125;        run_scan    allow_failure: false    rules:      # 如果 SKIP_SONAR 为 &quot;true&quot;，跳过任务      - if: &#x27;$SKIP_SONAR == &quot;true&quot;&#x27;        when: never      # 在合并请求时触发      - if: &#x27;$CI_PIPELINE_SOURCE == &quot;merge_request_event&quot; &amp;&amp; $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == &quot;master&quot;&#x27;    noop:    tags:      - sonar    stage: noop    script:      - echo &quot;Pipeline skipped all main jobs.&quot;    rules:      # 在合并请求时触发      - if: &#x27;$CI_PIPELINE_SOURCE == &quot;merge_request_event&quot; &amp;&amp; $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == &quot;master&quot;&#x27;  sonarqube-master-daily:    tags:      - sonar    stage: sonarqube    script:      - JAVA_HOME=你的服务地址 &amp;&amp; export JAVA_HOME      - export SONAR_JAVA_OPTS=&quot;-Xmx2G -Xms1G&quot;      - |        echo &quot;启动 SonarQube 分析...&quot;        run_scan() &#123;          mvn verify sonar:sonar -T 2 \\          -Dsonar.projectKey=你的key \\          -Dsonar.branch.name=master \\          -Dmaven.test.skip=true \\          -Dsonar.qualitygate.wait=true \\          -Dsonar.ce.parallel=1 \\          -Dmaven.repo.local=你的仓库地址 \\          -s 你的maven配置文件地址 \\          -Dci.tag=gitlab_sonarci_run &amp;        &#125;        run_scan    rules:      - if: &#x27;$CI_COMMIT_BRANCH == &quot;master&quot; &amp;&amp; $CI_PIPELINE_SOURCE == &quot;schedule&quot;&#x27;\n定时 ci 添加\n\ngitlab 定时 CI 会去扫 master 下的 .gitlab-ci.yml 文件，\n\nwebhook 转发\n\nnode.js 代码地址：https://github.com/kiml-rgb/sonar-feishu-webhook.git\n\n\n\n创建一个中间服务（建议使用 Spring Boot 或 Node.js）监听 SonarQube Webhook。\n\n\n接收到 Webhook 后，解析 payload，构造上面的卡片格式 JSON。\n\n\n将卡片格式消息 POST 到飞书机器人地址\n\n\n项目结构\nsonar-feishu-webhook/├── app.js├── feishu.js├── Dockerfile├── package.json└── .env\n部署\n\n\n项目文件准备\n\n\n构建镜像\n\n\ndocker build -t sonar-webhook-feishu .\n\n\n运行容器\n\n\ndocker run -d --name sonar-feishu \\  -p 9999:3000 \\  --env-file .env \\sonar-webhook-feishu\n\n\n在 SonarQube 后台 Webhook 中配置\n\n\nyour-address/webhook/sonar\n","categories":["后端项目","准备工作"],"tags":["GitLab","SonarQube"]},{"title":"第二章：数据结构与算法基础","url":"/posts/92102162/","content":"\n\n更新\n\n\n25-05-18 初始记录\n\n基本概念与三要素\n数据：数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。数据是计算机程序加工的原料。\n数据元素、数据项：数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位。\n数据结构：是相互之间存在一种或多种特定关系d 的数据元素的集合。\n三要素：逻辑结构、物理结构（存储结构）、数据的运算\n三要素 - 逻辑结构\n集合：各个元素同属于一个集合，别无其它关系。\n线性结构：数据元素之间时一对一的关系。除了第一个元素，所有的元素都有唯一前驱；除了最后一个元素，所有元素都有唯一后继。\n树形结构：数据元素之间是一对多的关系。\n图结构：数据元素之间是多对多的关系。\n三要素 - 物理结构\n顺序结构：把逻辑上相邻的元素存储在屋里位置上也相邻的存储单元中\n联是存储：逻辑上相邻的元素在物理位置上可以不相邻\n索引存储：在存储元素信息的同时，还建立附加的索引表\n散列存储：根据元素的关键字直接计算出该元素的存储地址，又称哈希存储\n算法\n五个特性\n有穷性：一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。\n确定性：算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。\n可行性：算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。\n输入：一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合。\n输出：一个算法有一个或多个输出，这些输出是与输入有着某种特定的关系的量。\n算法效率的度量\n时间复杂度：时间开销与问题规模 n 之间的关系\n空间复杂度：空间开销（内存开销）与问题规模 n 之间的关系。\n递归调用带来的内存开销：S(n) = O(n) 空间复杂度 = 递归调用的深度\nO(1) &lt; O(log2n) &lt; O(n) &lt; O(nlog2n) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n)\n线性表\n存储结构\n|- 顺序表|- 链表 |-- 单链表|-- 循环链表|-- 双向链表\n\n\n\n性能类别\n具体项目\n顺序存储\n链式存储\n\n\n\n\n空间性能\n存储密度\n=1\n&lt;1\n\n\n\n容量分配\n事先确定\n动态改变\n\n\n时间性能\n查找运算\nO(n/2)\nO(n/2)\n\n\n\n读运算\nO(1)\nO([n + 1]/2)，最好情况为 1，最坏情况为 n\n\n\n\n插入运算\nO(n/2)，最好情况为 0，最坏情况为 n\nO(1)\n\n\n\n删除运算\n([n - 1]/2)，\nO(1)\n\n\n\n其他\n算法问题直接看之前的算法笔记。\n\n内链：[[面试-数据结构和算法]]\n外链：面试-数据结构和算法\n\n","categories":["面试","软考","中级-软件设计师"]},{"title":"第一章：计算机系统知识","url":"/posts/3f3c39e1/","content":"\n\n更新\n\n\n25-04-06 初始记录\n\n数值及其转换和数据的表示\n二进制（B）、八进制（O）、十进制（D）、十六进制（H）\n任意进制 -&gt; 十进制：位权展开\n十进制 -&gt; 任意进制：短除法\n二进制 -&gt; 十六进制：4 位转 1 位\n\n\n\n2^12\n2^11\n2^10\n2^9\n2^8\n2^7\n2^6\n2^5\n2^4\n2^3\n2^2\n2^1\n2^0\n2^-1\n2^-2\n2^-3\n\n\n\n\n4096\n2048\n1024\n512\n256\n128\n64\n32\n16\n8\n4\n2\n1\n0.5\n0.25\n0.125\n\n\n\n计算机内数据的表示\n真值与机器数\n真值：符合人类习惯的数字\n机器数：各种数据在计算机中表示的形式称为机器数，其特点是数的符号用 0、1 表示。即正负号需要被“数字化”\n机器数- 无符号数：无符号数表示正数，在机器数中没有符号位- 有符号数\t- 原码\t- 反码\t- 补码\t- 移码\n原码\n原码：用数值部分表示真值的绝对值，符号位“0/1”对应“正/负”。\n\n若机器字长 n+1 位，原码整数的表示范围：-(2^n -1) &lt;= x &lt;= 2^n -1若机器字长 n+1 位，则数值部分（尾数）占 n 位，真值 0 有 +0 和 -0 两种形式。\n\n反码\n反码：若符号位为 0，则反码与原码相同。若符号位为 1，则数值位全部取反。\n\n若机器字长 n+1 位，反码整数的表示范围：-(2^n -1) &lt;= x &lt;= 2^n -1真值 0 有 +0 和 -0 两种形式。\n\n补码\n补码：若符号位为 0，则补码与原码相同。若符号位为 1，则补码=反码末位 +1。\n\n若机器字长 n+1 位，补码整数的表示范围：-2^n &lt;= x &lt;= 2^n -1\n真值 0 只有一种形式00000000。定点整数补码 [x]补 = 10000000 表示 -2^7\n\n移码\n移码：补码的基础上将符号位取反。注意：移码只能用于表示整数。\n\n若机器字长 n+1 位，补码整数的表示范围：-2^n &lt;= x &lt;= 2^n -1\n\n定点数 和 浮点数\n定点数：就是小数点的位置固定不变的数。小数点的位置通常有两种约定方式：定点整数（纯整数，小数点在最低有效数值位之后）和定点小数（纯小数，小数点在最高有效数值位之前）\n5D - 0，01001.0.5D - 0.1000\n浮点数：小数点位置不固定的数，他能表示更大范围的数。在浮点表示法中，阶码通常为带符号的纯整数，尾数为带符号的纯小数。浮点数通常表示为 N=MR^E。其中，M 称为尾数，R 称为基数，E 称为阶码。\n\n\n\n阶码（E）\n码价\n数符\n尾数（M）\n\n\n\n\n阶码，决定浮点数所能表示的数值范围\n尾数， 决定浮点数所能表示的数值精度\n\n校验码\n校验码：用来检测传送的数据是否出错。\n码距：指一个编码系统中任意两个合法编码之间至少有多少个二进制位不同。\n奇偶校验\n发现错误。\n循环冗余校验码 CRC\n应用于数据通信领域和磁介质存储系统中。长度 k（数据位） + r（校验位）\n海明码\n海明码的构成方法是：在数据位之间插入 k 个校验码，通过扩大码距来实现检错和纠错。\n\n设数据位是 n 位，校验位是 k 位，则 n 和 k 必须满足以下关系：\n2^k -1 &gt;= n+k\n\n计算机系统组成\n五大部件\n\n输入设备、输出设备、存储器、运算器、控制器。输入/输出设备与存储器之间的数据传输通过运算器完成。\n\n冯·诺依曼计算机的特点：\n\n\n计算机由五大部件组成（输入设备、输出设备、存储器、运算器、控制器）\n\n\n指令和数据以同等地位存于存储器，可按地址寻访\n\n\n指令和数据用二进制表示\n\n\n指令由操作码和地址码组成\n\n\n存储程序\n\n\n以运算器为中心\n\n\n输入设备：将信息转换为机器能识别的形式 0/1\n输出设备：将结果转换为人们熟知的形式\n主存储器：存放数据和程序\n运算器：算术运算、逻辑运算\n控制器：指挥各部件、使程序得以运行\n主存储器\n\n存储体、MAR、MDR\n\n存储单元：每个存储单元存放一串二进制代码。\n存储字：存储单元中二进制代码的组合。\n存储字长：存储单元中二进制代码的位数。\n存储元：即存储二进制的电子元件，每个存储元可存 1 bit。\nMAR：地址寄存器（标记存储单元的个数）\nMDR：数据寄存器\nMAR = 4位 -&gt; 总共有 2*2*2*2 个存储单元MDR = 16位 -&gt; 每个存储单元可存放 16 bit\nCPU - 运算器\n运算器：用于实现算术运算（如：加减乘除）、逻辑运算（如：与或非）\nACC：累加器，用于存放操作数，或运算结果。\nMQ：乘商寄存器，在乘、除运算时，用于存放操作数或结果运算。\nX：通用的操作数寄存器，用于存放操作数。\nALU：算术逻辑单元，通过内部复杂的电路实现算术运算、逻辑运算。\nDR：数据缓存寄存器。\nPSW：状态条件寄存器，用来保存指令运行标志。\nCPU - 控制器\nCU：控制单元，分析指令，给出控制信号。\nIR：指令寄存器，存放当前执行的指令。\nPC：程序计数器，存放下一条指令地址，有自动加 1功能。\nAR：地址寄存器，保存当前 CPU 所访问的内存单元地址。\nID：指令译码器，对操作码进行分析。\n计算机体系结构\nFlynn 分类法\n\n\n\n体系结构类型\n结构\n关键特性\n代表\n\n\n\n\n单指令流单数据流 SISD\n控制部分：一个处理器：一个主存模块：一个\n\n单处理器系统\n\n\n单指令流多数据流 SIMD\n控制部分：一个处理器：多个主存模块：多个\n各处理器以异步的形式执行同一条指令\n并行处理机阵列处理机超级向量处理机\n\n\n多指令流单数据流 MISD\n控制部分：多个处理器：一个主存模块：多个\n被证明不可能，至少是不实际\n目前没有，有文献称流水计算机为此类\n\n\n多指令流多数据流 MIMD\n控制部分：多个处理器：多个主存模块：多个\n能够实现作业、任务、指令等各级全面屏行\n多处理机系统多计算机\n\n\n\n指令系统\n指令\n指令（又称机器指令）：是指令计算机执行某种操作的命令，是计算机运行的最小功能单位。\n一台计算机的所有指令的集合构成该机的指令系统，也称为指令集。\n指令格式\n一条指令就是机器语言的一个语句，它是一组有意义的二进制代码。\n一条指令通常要包括操作码字段（操作的类型）和地址码字段（操作数及运算结果存放的地址）两部分。\n七种寻址方式\n\n\n立即寻址：操作数作为指令的一部分直接写在指令中，这种操作数称为立即数。\n\n\n寄存器寻址：指令所要的操作数已存储在某寄存器中，或把目标操作数存入寄存器。\n\n\n直接寻址：指令所要的操作数存放在内存中，在指令中直接给出该操作数的有效地址。\n\n\n寄存器间接寻址：操作数在存储器中，操作数的有效地址用 SI、DI、BX 和 BP 四个寄存器之一来制定。\n\n\n寄存器相对寻址：操作数在存储器中，其有效地址是一个基址寄存器或变址寄存器中的内容和指令中的 8 位/16 位偏移量之和。\n\n\n基址加变址寻址方式：操作数在存储器中，其有效地址是一个基址寄存器和一个变址寄存器的内容之和。\n\n\n相对基址加变址寻址：操作数在存储器中，其有效地址是一个基址寄存器的值、一个变址寄存器的值和指令中的 8 位/16 位偏移量之和。\n\n\n复杂指令集计算机 - CISC、精简指令集计算机 - RISC\n\n\n\n\nCISC（Complex）\nRISC（Reduced）\n\n\n\n\n指令系统\n复杂、庞大\n简单、精简\n\n\n指令数目\n一般大于 200 条\n一般小于 100 条\n\n\n指令字长\n不固定\n定长\n\n\n可访存指令\n不加限制\n只有 Load/Store 指令\n\n\n各种指令执行时间\n相差较大\n绝大多数一个周期内完成\n\n\n各种指令使用频度\n相差较大\n都比较常用\n\n\n通用寄存器数量\n较少\n多\n\n\n控制方式\n绝大多数为微程序控制\n绝大多数为组合逻辑控制\n\n\n指令流水线\n可以通过一定方式实现\n必须实现\n\n\n\n指令的流水处理\n指令控制方式有顺序方式、重叠方式和流水方式三种。\n流水线的计算\n\n列：若指令流水线把一条指令分为取指、分析和执行三部分，且三部分的时间分别是取指 2ns，分析 2ns，执行 1ns。那么，流水线周期是多少？100 条指令全部执行完毕需要的时间是多少？\n\n流水线周期为执行时间最长的一段\n流水线计算公式为：1 条指令执行时间 +（指令条数 -1） 流水线周期*\n流水线周期：2ns时间：2ns + 2ns + 1ns + (100 - 1) * 2ns = 103 ns\n流水线的吞吐率（TP）：是指在单位时间内流水线所完成的任务数量或输出的结果数量。计算公式：TP=指令条数/流水线执行时间\nTP = 100 / [2ns + 2ns + 1ns + (100 - 1) * 2ns] = 100 / 103\n流水线的加速比：完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间之比。计算公式：S=不使用流水线执行时间/使用流水线执行时间\nS = (2ns + 2ns + 1ns) * 100 / [2ns + 2ns + 1ns + (100 - 1) * 2ns] = 500 / 103\n输入输出技术\nCPU 与外设之间的数据传输方式\n\n\n直接程序控制方式直接程序控制方式是指在完成数据的输入/输出中，整个输入/输出的过程是在 CPU 执行程序的控制下完成的。这种方式还可以分为以下两种：\n\n无条件传输方式：无条件地与 CPU 交换数据。\n程序查询方式：先通过 CPU 查询外设状态，准备好之后再与 CPU 交换数据。\n\n\n\n中断方式中断方式利用中断机制，使 I/O 系统在与外设交换数据时，CPU 无须等待，也不必查询 I/O 状态，即可以抽身出来处理其他任务，因此提高了系统效率。\n\n\n直接存储器存取方式（DMA）是在存储器与 I/O 设备间直接传送数据，即在内存与 I/O 设备之间传送一个数据块的过程中，不需要 CPU 的任何干涉，是一种完全由 DMA 硬件完成 I/O 操作的方式。\n\n\n输入/输出处理机（IOP）是一个专用处理机，用于完成主机的输入/输出操作。IOP 根据主机的 I/O 命令，完成对外设数据的输入/输出。\n\n\n存储系统\n层次结构\nCPU高速缓存（Cache）-辅助硬件主存-辅助硬件/软件辅存\n主存 - 辅存（硬件 + 操作系统）：实现虚拟系统存储，解决了主存容量不够的问题\nCache - 主存（硬件自动完成）：解决了主存与 CPU 速度不匹配的问题\n分类\n\n\n按位置分类：可以分为内存和外存内存（主存）：用来存储当前运行所需要的程序和数据，速度快、容量小。外存（辅存）：用来存储当前不参与运行的数据，容量大，速度慢。\n\n\n按材料分类，可分为磁存储器、半导体存储器和光存储器。磁存储器：用磁性介质做成，如磁芯、磁泡、磁盘、磁带等半导体存储器：根据所用元件又可分为双极型和 MOS 型两类；根据是否需要刷新又可分为静态和动态两类。光存储器：由光学、电学和机械部件等组成，如光盘存储器。\n\n\n按工作方式分，可分为读/写存储器和只读存储器。读/写存储器（RAM）它指既能读取数据也能存入数据的存储器。只读存储器（ROM）工作过程中仅能读取的存储器。\n\n\n\n\n固定只读存储器（ROM）。这种存储器是在厂家生产时就写好数据的，其内容只能读出，不能改变。一般用于存放系统程序 BIOS和用于微程序控制。\n\n\n可编程的只读存储器（PROM）。其中的内容可以由用户一次性地写入，写入后不能再修改。\n\n\n可擦除可编程的的只读存储器（EPROM）。其中的内容既可以读出，也可以由用户写入，写入后还可以修改，紫外线照射擦除信息。\n\n\n电擦除可编程的的只读存储器（EEPROM）。与 EPROM 相似，EEPROM 中的内容既可以读出，也可以进行改写，电擦除的方法进行数据的改写。\n\n\n闪存存储器（Flash Memory）。简称闪存，闪存的特性介于 EPROM 和 EEPROM 之间，类似于 EEPROM，也可以使用电信号进行信息的擦除操作。整块闪存可以在数秒内删除，速度远快于 EPROM。\n\n\n高速缓存 -Cache\n高速缓存（Cache）是位于 CPU 和主存之间的高速存储子系统。\n目的：提高存储器的平均访问速度，使存储器的速度与 CPU 的速度相匹配。\n地址变换和数据块的替换算法均由硬件实现。\n通常被集成到 CPU 内，以提高访问速度，其主要特点是容量小、速度快、成本高。\nCache 的组成\n\n\nCache 存储器部分：用来存放主存的部分复制信息。\n\n\n控制部分的功能：判断 CPU 要访问的信息是否在 Cache 存储器中，若在，即为命中，若不在则没有命中。\n\n\nCache 的三种地址映射\n地址映像：把主存中的地址映射成 Cache 存储器中的地址\n\n\n直接映射：就是主存的块与 Cache 中块的对应关系是固定的。主存中的块只能存放在 Cache 存储器的相同块号中。因此，只要主存地址中的主存区号与 Cache 中的主存区号相同，则表明访问 Cache 命中。优点：地址变换很简单，缺点：灵活性差。Cache 分块，主存分区，每个区再分块，并且每个区的块数和 Cache 的分块相同。\n\n\n全相联映像：允许主存中的任一块可以调入 Cache 的任一块的空间。在地址变换时，将主存地址高位表示的主存块号与 Cache 中的主存块号进行比较，若相同则为命中。优点：主存的块调入 Cache 的位置不受限制，十分灵活。其缺点是无法从主存块号中获得 Cache 的块号，变换比较复杂，速度比较慢\n\n\n组相联映像：这种方式是前面两种方式的折中。具体方法是将 Cache 先分成组再分块。组组相联映像就是组间采用直接映像方式，而组内的块采用全相联映像方式。\n\n\nCache 的性能分析\n\n若 H 为 Cache 的命中率，tc 为 Cache 的存取时间，tm 为主存的访问时间，则 Cache 的等效访问时间 ta 为\n\nta = H * tc + (1 - H) * tm\n使用 Cache 比不使用 Cache 的 CPU 访问存储器速度提高的倍数 r 可以用下式求得\nr = tm / ta\n主存的扩展\n位扩展\n字扩展\n主存的编址\n\n内存地址从 AC000H 到 C7FFFH，共有 ？K 个地址单元，如果该内存地址按字（16bit）编址，由 28 片存储器芯片构成。已知构成此内存的芯片每片有 16K 个存储单元，则该芯片每个存储单元存储 ？位。\n1K=2^10\n1M=2^20\n1G=2^30\n\nC7FFFH - AC000H + 1 = 1C000H = 1 * 2^4^4 + 12 * 2^4^3 = (2^4 + 12)*2^12= 28 * 2^12地址单元 = 28 * 2^12 / 2^10 = 28 * 2^2 = 112 K\n112K * 16 = 28 * 16K * 存储位数存储位数 = 4 bit\n虚拟存储器\n虚拟存储器是由主存、辅存、存储管理单元及操作系统中的存储管理软件组成的存储系统。程序员使用该存储系统时，可以使用的内存空间可远大于主存的物理空间，但实际上并不存在那么大的主存，顾称其为虚拟存储器。\n虚拟存储器使存储系统既具有相当于外存的容量又具有接近于主存的访问速度。\n磁盘存储器\n存取时间 = 寻道时间 + 等待时间（平均定位时间 + 转动延迟）\n注意：寻道时间是指磁头移动到磁道所需的时间；等待时间为等待读写的扇区转到磁头下方所用的时间。\n总线系统\n\n\n片内总线（内部总线）片内总线是芯片内部的总线。它是 CPU 芯片内部寄存器与寄存器之间、寄存器与 ALU 之间的公共连接线。\n\n\n系统总线系统总线是计算机系统内各功能部件（CPU、主存、I/O 接口）之间相互连接的总线。按系统总线传输信息内容的不同，又可以分为 3 类：数据总线、地址总线和控制总线。\n\n\n通信总线（外部总线）用于设备一级的互连，计算机可通过该总线和其他设备进行信息与数据交换。\n\n\n磁盘阵列技术（RAID）\n磁盘阵列由多台磁盘存储器组成，是快速、大容量且高可靠的外存子系统。现在常见的独立冗余磁盘阵列（RAID）就是一种由多块独立磁盘构成的冗余阵列。RAID 技术分为几种不同的等级，分别可以提供不同的速度、安全性和性价比。\n\n\n\nRAID 级\n说明\n\n\n\n\nRAID-0\n一种不具备容错能力的磁盘阵列\n\n\nRAID-1\n是采用镜像容错技术改善可靠性的一种磁盘阵列\n\n\nRAID-2\n是采用海明码进行错误检测的一种磁盘阵列\n\n\nRAID-3\n减少了用于检验的磁盘存储器台数，从而提高了磁盘阵列的有效容量，一般只有一个检验盘\n\n\nRAID-4\n是一种可以独立地对组内各磁盘进行读写的磁盘阵列，该阵列也只用一个检验盘\n\n\nRAID-5\n是对 RAID-4 的一种改进，他不设置专门的检验盘。同一台磁盘上既记录数据，也记录检测信息。这就解决了前面多台磁盘机争用一台检验盘的问题\n\n\nRAID-6\n采用两级数据冗余和新的数据编码以解决数据恢复问题，在两个磁盘出现故障时仍然能够正常工作。在进行写操作时，分别进行两个独立的校验运算，形成两个独立的冗余数据，并写入两个不同的磁盘。\n\n\n\n计算机可靠性\n计算机系统的可靠性是指从它开始运行（t=0）到某个时刻 t 这段时间内能正常运行的概率，用 R(t) 表示\n串联部件的可靠度 = 各部件的可靠度的乘积串联部件的可靠度 = 1 - 各部件失效率的乘积\n","categories":["面试","软考","中级-软件设计师"],"tags":["软考中级"]}]