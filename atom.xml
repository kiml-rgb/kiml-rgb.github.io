<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Keep Theme</title>
  
  <subtitle>Keep theme quick starter</subtitle>
  <link href="https://kiml.github.io/atom.xml" rel="self"/>
  
  <link href="https://kiml.github.io/"/>
  <updated>2024-06-10T14:34:12.495Z</updated>
  <id>https://kiml.github.io/</id>
  
  <author>
    <name>Keep Team</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试-04 Spring</title>
    <link href="https://kiml.github.io/2024/06/10/100000041/"/>
    <id>https://kiml.github.io/2024/06/10/100000041/</id>
    <published>2024-06-10T14:16:35.000Z</published>
    <updated>2024-06-10T14:34:12.495Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>❗表示必掌握，❔表示基本不会问</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24-06-10 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="说说Spring常用的几个注解？">说说Spring常用的几个注解？</h2><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>@Component</td><td>取代.xml中的<bean id="">；用于三层架构类之外。</td></tr><tr><td>@Controller</td><td>衍生注解；用于Controller层</td></tr><tr><td>@Service</td><td>衍生注解；用于Service层</td></tr><tr><td>@Repository</td><td>衍生注解；用于Dao层</td></tr><tr><td>@Bean</td><td>取代.xml中工厂创建bean对象,方法的返回值成为bean对象。</td></tr><tr><td>@Autowired</td><td>取代.xml中<property>中的ref注入，底层是CGLIB动态代理。这个是本地注入。</td></tr><tr><td>@Aspect</td><td>定义在类上；设置当前类为切面类</td></tr><tr><td>@Before</td><td>定义在方法上；标注当前方法作为前置通知</td></tr></tbody></table><h2 id="谈谈你对Spring的理解？">谈谈你对Spring的理解？</h2><p>Spring是一个完整的生态，不单单是一个技术框架。</p><h2 id="Spring两大核心思想是什么？">Spring两大核心思想是什么？</h2><p>IOC：解耦，使代码复用，可维护性大幅提升。</p><p>AOP：提供切面编程，同样增强生产力。</p><h3 id="说一说你对IOC的理解？">说一说你对IOC的理解？</h3><p>❗大白话：最原始的tomcat+servlet的编码原理。使用的时候<code>Myservice myservie = new MyserviceImpl()</code>。耦合度很高，修改一个类要修改很多文件。然后我们引入Spring这个框架。会去由框架Spring容器创建实例Bean，对象间就会直接引用（依赖注入）。然后Spring MVC(核心Servlet Filter 去处理请求)。IOC底层就是反射（+工厂模式）、通过类去创建对象。</p><p>IoC（Inversion Of Control）控制反转，其实是一种思想，用于解决程序间的耦合问题。【解耦】</p><p>原本我们创建对象是直接在类中，通过new的方式创建，控制权在于程序员自己，现在我们把new对象的工作交给spring完成，我们只需要通过配置文件进行配置即可。反转的是对象的创建权力。【便捷】</p><p>ioc容器，可以简单理解为一个工厂，但是他的功能比普通工厂要强大很多，内部帮助我们完成了对象的创建和效果的整个过程管理，同时提供了很多扩展机会。【可扩展】</p>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
❗表示必掌握，❔表示基本不会问&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-06-10 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    
    <category term="面试" scheme="https://kiml.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="八股文" scheme="https://kiml.github.io/tags/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第二十二天-216组合总和III、17电话号码的字母组合</title>
    <link href="https://kiml.github.io/2024/06/10/100000040/"/>
    <id>https://kiml.github.io/2024/06/10/100000040/</id>
    <published>2024-06-10T06:53:08.000Z</published>
    <updated>2024-06-10T08:38:49.144Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：216可以AC。17看了部分解析写出来的。</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24-06-10 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h1>初步题解</h1><h2 id="216组合总和III">216组合总和III</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/combination-sum-iii" >https://leetcode.cn/problems/combination-sum-iii<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LE22</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; combinationSum3 = combinationSum3(<span class="number">9</span>, <span class="number">45</span>);  </span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; integerList : combinationSum3) &#123;  </span><br><span class="line">            System.out.println(Arrays.toString(integerList.stream().mapToInt(n -&gt; n).toArray()));  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;  </span><br><span class="line">        <span class="comment">// 结果集  </span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">        <span class="comment">// 单个结果  </span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">  </span><br><span class="line">        combinationSum(<span class="number">1</span>, k, n, <span class="number">0</span>, list, result);  </span><br><span class="line">        <span class="keyword">return</span> result;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> k, <span class="type">int</span> n, <span class="type">int</span> sum, List&lt;Integer&gt; list, List&lt;List&lt;Integer&gt;&gt; result)</span> &#123;  </span><br><span class="line">        <span class="comment">// 剪枝操作  </span></span><br><span class="line">        <span class="keyword">if</span> (sum &gt; n) &#123;  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (list.size() == k) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (sum == n) &#123;  </span><br><span class="line">                List&lt;Integer&gt; resultOne = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list);  </span><br><span class="line">                result.add(resultOne);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> start; j &lt;= <span class="number">9</span> - (k - list.size()) + <span class="number">1</span>; j++) &#123;  </span><br><span class="line">            list.add(j);  </span><br><span class="line">            combinationSum(j + <span class="number">1</span>, k, n, sum + j, list, result);  </span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="17电话号码的字母组合">17电话号码的字母组合</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number" >https://leetcode.cn/problems/letter-combinations-of-a-phone-number<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> digits 按键数组  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;  </span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    String[] buttonList = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (digits == <span class="literal">null</span> || <span class="string">&quot;&quot;</span>.equals(digits)) &#123;  </span><br><span class="line">        <span class="keyword">return</span> list;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    combinations(<span class="number">0</span>, digits, buttonList, <span class="string">&quot;&quot;</span>, list);  </span><br><span class="line">    <span class="keyword">return</span> list;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * * <span class="doctag">@param</span> i 遍历的层数  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">combinations</span><span class="params">(<span class="type">int</span> i, String digits, String[] buttonList, String str, List&lt;String&gt; list)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (i == digits.length()) &#123;  </span><br><span class="line">        list.add(str);  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> Integer.parseInt(digits.charAt(i) + <span class="string">&quot;&quot;</span>);  </span><br><span class="line">    <span class="type">String</span> <span class="variable">letter</span> <span class="operator">=</span> buttonList[digit];  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; letter.length(); j++) &#123;  </span><br><span class="line">        str+=letter.charAt(j);  </span><br><span class="line">        combinations(i + <span class="number">1</span>, digits, buttonList, str, list);  </span><br><span class="line">        str = str.substring(<span class="number">0</span>, str.length() - <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>看解析</h1><h2 id="216组合总和III-2">216组合总和III</h2><p>题目链接/文章讲解：<a class="link"   href="https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html" >https://programmercarl.com/0216.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII.html<i class="fas fa-external-link-alt"></i></a></p><p>视频讲解：<a class="link"   href="https://www.bilibili.com/video/BV1wg411873x" >https://www.bilibili.com/video/BV1wg411873x<i class="fas fa-external-link-alt"></i></a></p><h2 id="17电话号码的字母组合-2">17电话号码的字母组合</h2><p>题目链接/文章讲解：<a class="link"   href="https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html" >https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html<i class="fas fa-external-link-alt"></i></a></p><p>视频讲解：<a class="link"   href="https://www.bilibili.com/video/BV1yV4y1V7Ug" >https://www.bilibili.com/video/BV1yV4y1V7Ug<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：216可以AC。17看了部分解析写出来的。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-06-10 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="回溯算法" scheme="https://kiml.github.io/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第二十一天-理论基础、77组合</title>
    <link href="https://kiml.github.io/2024/06/10/100000039/"/>
    <id>https://kiml.github.io/2024/06/10/100000039/</id>
    <published>2024-06-10T01:33:43.000Z</published>
    <updated>2024-06-10T03:58:57.813Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：理论基础总结在[[面试-数据结构和算法]]中。</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24-05-10 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h1>初步题解</h1><h2 id="77组合">77组合</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/combinations/" >https://leetcode.cn/problems/combinations/<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;  </span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    combineBFS(<span class="number">1</span>, n, k, list, result);  </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * * <span class="doctag">@param</span> start 当前开始节点  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n n  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k k  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> list 每个list  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> result 最后的结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">combineBFS</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> n, <span class="type">int</span> k, List&lt;Integer&gt; list, List&lt;List&lt;Integer&gt;&gt; result)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (list.size() == k) &#123;  </span><br><span class="line">        List&lt;Integer&gt; resultOne = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(k);  </span><br><span class="line">        resultOne.addAll(list);  </span><br><span class="line">        result.add(resultOne);  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> start; j &lt;= n; j++) &#123;  </span><br><span class="line">        list.add(j);  </span><br><span class="line">        combineBFS(j + <span class="number">1</span>, n, k, list, result);  </span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>看解析</h1><h2 id="77组合-2">77组合</h2><p>题目链接/文章讲解：<a class="link"   href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html" >https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html<i class="fas fa-external-link-alt"></i></a></p><p>视频讲解：<a class="link"   href="https://www.bilibili.com/video/BV1ti4y1L7cv" >https://www.bilibili.com/video/BV1ti4y1L7cv<i class="fas fa-external-link-alt"></i></a></p><p>剪枝操作：<a class="link"   href="https://www.bilibili.com/video/BV1wi4y157er" >https://www.bilibili.com/video/BV1wi4y157er<i class="fas fa-external-link-alt"></i></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;  </span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    combineBFS(<span class="number">1</span>, n, k, list, result);  </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * * <span class="doctag">@param</span> start 当前开始节点  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n n  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k k  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> list 每个list  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> result 最后的结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">combineBFS</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> n, <span class="type">int</span> k, List&lt;Integer&gt; list, List&lt;List&lt;Integer&gt;&gt; result)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (list.size() == k) &#123;  </span><br><span class="line">        List&lt;Integer&gt; resultOne = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(k);  </span><br><span class="line">        resultOne.addAll(list);  </span><br><span class="line">        result.add(resultOne);  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 附带剪枝操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> start; j &lt;= (n - (k - list.size())) + <span class="number">1</span>; j++) &#123;  </span><br><span class="line">        list.add(j);  </span><br><span class="line">        combineBFS(j + <span class="number">1</span>, n, k, list, result);  </span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：理论基础总结在[[面试-数据结构和算法]]中。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-05-10 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="回溯算法" scheme="https://kiml.github.io/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第二十天-669修剪二叉搜索树、108将有序数组转换为二叉搜索树、538把二叉搜索树转换为累加树</title>
    <link href="https://kiml.github.io/2024/06/09/100000037/"/>
    <id>https://kiml.github.io/2024/06/09/100000037/</id>
    <published>2024-06-09T07:54:48.000Z</published>
    <updated>2024-06-09T13:30:46.295Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：669通过，但是有更简单的方法。108AC。538没有思路，看了解题思路写出来了。</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24-06-09 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h1>初步题解</h1><h2 id="669修剪二叉搜索树">669修剪二叉搜索树</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/trim-a-binary-search-tree" >https://leetcode.cn/problems/trim-a-binary-search-tree<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 思路：查找节点，删除节点</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root 根节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> low  区间左范围</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> high 区间右范围</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先剪枝</span></span><br><span class="line">        cut(root, low, high);</span><br><span class="line">        <span class="comment">// 再减单个</span></span><br><span class="line">        <span class="keyword">return</span> travel(root, low, high);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TreeNode <span class="title function_">travel</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (low &lt;= root.val &amp;&amp; root.val &lt;= high) &#123;</span><br><span class="line">            root.left = travel(root.left, low, high);</span><br><span class="line">            root.right = travel(root.right, low, high);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> root.right;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> root.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 删除这个节点</span></span><br><span class="line">                <span class="comment">// 1.右子树补位(找到右子树的最左侧节点)</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root.right;</span><br><span class="line">                <span class="keyword">while</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    cur = cur.left;</span><br><span class="line">                &#125;</span><br><span class="line">                cur.left = root.left;</span><br><span class="line">                root = root.right;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        root.left = travel(root.left, low, high);</span><br><span class="line">        root.right = travel(root.right, low, high);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">cut</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 整条剪掉</span></span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; high) &#123;</span><br><span class="line">            root.right = <span class="literal">null</span>;</span><br><span class="line">            root.left = trimBST(root.left, low, high);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; low) &#123;</span><br><span class="line">            root.left = <span class="literal">null</span>;</span><br><span class="line">            root.right = trimBST(root.right, low, high);</span><br><span class="line">        &#125;</span><br><span class="line">        cut(root.left, low, high);</span><br><span class="line">        cut(root.right, low, high);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为时间复杂度太高，后面又写了一个版本，但是这个版本AC不了</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span> root;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; high) &#123;  </span><br><span class="line"><span class="keyword">return</span> root.left;  </span><br><span class="line">            <span class="comment">// return trimBST(root.left, low, high);  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; low) &#123;  </span><br><span class="line">            <span class="comment">// 继续向右遍历  </span></span><br><span class="line"><span class="keyword">return</span> root.right;  </span><br><span class="line">            <span class="comment">// return trimBST(root.right, low, high);  </span></span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (low &lt;= root.val &amp;&amp; root.val &lt;= high) &#123;  </span><br><span class="line">            root.left = trimBST(root.left, low, high);  </span><br><span class="line">            root.right = trimBST(root.right, low, high);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">null</span> &amp;&amp; (root.val &lt; low || root.val &gt; high)) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="literal">null</span>) &#123;  </span><br><span class="line">                root = root.right;  </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.right == <span class="literal">null</span>) &#123;  </span><br><span class="line">                root = root.left;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                <span class="comment">// 删除这个节点  </span></span><br><span class="line">                <span class="comment">// 1.右子树补位(找到右子树的最左侧节点)  </span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root.right;  </span><br><span class="line">                <span class="keyword">while</span> (cur.left != <span class="literal">null</span>) &#123;  </span><br><span class="line">                    cur = cur.left;  </span><br><span class="line">                &#125;  </span><br><span class="line">                cur.left = root.left;  </span><br><span class="line">                root = root.right;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> root;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="108将有序数组转换为二叉搜索树">108将有序数组转换为二叉搜索树</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/" >https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> sortedBFS(nums, <span class="number">0</span>, nums.length);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> TreeNode <span class="title function_">sortedBFS</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (i &gt;= j) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (j - i) / <span class="number">2</span> + i;  </span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">treeNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);  </span><br><span class="line">    treeNode.left = sortedBFS(nums, i, mid);  </span><br><span class="line">    treeNode.right = sortedBFS(nums , mid + <span class="number">1</span>, j);  </span><br><span class="line">    <span class="keyword">return</span> treeNode;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="538把二叉搜索树转换为累加树">538把二叉搜索树转换为累加树</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/convert-bst-to-greater-tree" >https://leetcode.cn/problems/convert-bst-to-greater-tree<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 看了题解之后写出来的  </span></span><br><span class="line"><span class="comment"> * 思路：  </span></span><br><span class="line"><span class="comment"> * 1.二叉搜索树，中序遍历（左中右）有序  </span></span><br><span class="line"><span class="comment"> * 2.要按倒序相加，遍历方向相反  </span></span><br><span class="line"><span class="comment"> * 3.取一个指针指向前节点不断累加  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(<span class="number">0</span>);  </span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">convertBST</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    getTreeNodeTravel(root);  </span><br><span class="line">    <span class="keyword">return</span> root;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getTreeNodeTravel</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    getTreeNodeTravel(root.right);  </span><br><span class="line">  </span><br><span class="line">    root.val = pre.val + root.val;  </span><br><span class="line">    pre = root;  </span><br><span class="line">    getTreeNodeTravel(root.left);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>看解析</h1><h2 id="669修剪二叉搜索树-2">669修剪二叉搜索树</h2><p>题目链接/文章讲解： <a class="link"   href="https://programmercarl.com/0669.%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html" >https://programmercarl.com/0669.%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html<i class="fas fa-external-link-alt"></i></a></p><p>视频讲解： [<a class="link"   href="https://www.bilibili.com/video/BV17P41177ud" >https://www.bilibili.com/video/BV17P41177ud<i class="fas fa-external-link-alt"></i></a>](<a class="link"   href="https://www.bilibili.com/video/BV17P41177ud" >https://www.bilibili.com/video/BV17P41177ud<i class="fas fa-external-link-alt"></i></a></p><p>看了题解发现是下面两行导致不能AC。这里不能直接剪掉，忽略了情况。并且用了下面的继续递归，就不用再删除节点了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (root.val &gt; high) &#123;  </span><br><span class="line"><span class="keyword">return</span> root.left;  </span><br><span class="line">    <span class="comment">// return trimBST(root.left, low, high);  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">if</span> (root.val &lt; low) &#123;  </span><br><span class="line">    <span class="comment">// 继续向右遍历  </span></span><br><span class="line"><span class="keyword">return</span> root.right;  </span><br><span class="line">    <span class="comment">// return trimBST(root.right, low, high);  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><strong>正确方法</strong>（🥴好难）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> root;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; high) &#123;  </span><br><span class="line">        <span class="keyword">return</span> trimBST(root.left, low, high);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (root.val &lt; low) &#123;   </span><br><span class="line">        <span class="keyword">return</span> trimBST(root.right, low, high);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (low &lt;= root.val &amp;&amp; root.val &lt;= high) &#123;  </span><br><span class="line">        root.left = trimBST(root.left, low, high);  </span><br><span class="line">        root.right = trimBST(root.right, low, high);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> root;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="108将有序数组转换为二叉搜索树-2">108将有序数组转换为二叉搜索树</h2><p>题目链接/文章讲解： <a class="link"   href="https://programmercarl.com/0108.%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html" >https://programmercarl.com/0108.%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html<i class="fas fa-external-link-alt"></i></a></p><p>视频讲解：[<a class="link"   href="https://www.bilibili.com/video/BV1uR4y1X7qL" >https://www.bilibili.com/video/BV1uR4y1X7qL<i class="fas fa-external-link-alt"></i></a>](<a class="link"   href="https://www.bilibili.com/video/BV1uR4y1X7qL" >https://www.bilibili.com/video/BV1uR4y1X7qL<i class="fas fa-external-link-alt"></i></a></p><h2 id="538把二叉搜索树转换为累加树-2">538把二叉搜索树转换为累加树</h2><p>题目链接/文章讲解： <a class="link"   href="https://programmercarl.com/0538.%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91.html" >https://programmercarl.com/0538.%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91.html<i class="fas fa-external-link-alt"></i></a></p><p>视频讲解：<a class="link"   href="https://www.bilibili.com/video/BV1d44y1f7wP" >https://www.bilibili.com/video/BV1d44y1f7wP<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：669通过，但是有更简单的方法。108AC。538没有思路，看了解题思路写出来了。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-06-09 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="二叉树" scheme="https://kiml.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="二叉搜索树" scheme="https://kiml.github.io/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
    <category term="累加树" scheme="https://kiml.github.io/tags/%E7%B4%AF%E5%8A%A0%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第十九天-235二叉搜索树的最近公共祖先、701二叉搜索树中的插入操作、450删除二叉搜索树中的节点</title>
    <link href="https://kiml.github.io/2024/06/09/100000036/"/>
    <id>https://kiml.github.io/2024/06/09/100000036/</id>
    <published>2024-06-09T01:30:05.000Z</published>
    <updated>2024-06-09T13:30:27.580Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：235、701AC，701还有更简单的写法。450通过失败。</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24-06-09 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h1>初步题解</h1><h2 id="235二叉搜索树的最近公共祖先">235二叉搜索树的最近公共祖先</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree" >https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree<i class="fas fa-external-link-alt"></i></a>)</p><p>看了一部分的解析。主要在于<strong>当我们从上向下去递归遍历，第一次遇到 cur节点是数值在<code>[q, p]</code>区间中，那么cur就是 q和p的最近公共祖先。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (p.val &lt; q.val) &#123;  </span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestorTravel(root, p, q);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestorTravel(root, q, p);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">lowestCommonAncestorTravel</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span> || (p.val &lt;= root.val &amp;&amp; root.val &lt;= q.val)) &#123;  </span><br><span class="line">        <span class="keyword">return</span> root;  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; q.val) &#123;  </span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="701二叉搜索树中的插入操作">701二叉搜索树中的插入操作</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/description/" >https://leetcode.cn/problems/insert-into-a-binary-search-tree/description/<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用双指针</span></span><br><span class="line">TreeNode pre;  </span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (pre == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (pre.val &gt; val)&#123;  </span><br><span class="line">                pre.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);  </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pre.val &lt; val) &#123;  </span><br><span class="line">                pre.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">return</span> root;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    pre = root;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; val) &#123;  </span><br><span class="line">        insertIntoBST(root.left, val);  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; val) &#123;  </span><br><span class="line">        insertIntoBST(root.right, val);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> root;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="450删除二叉搜索树中的节点">450删除二叉搜索树中的节点</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/delete-node-in-a-bst" >https://leetcode.cn/problems/delete-node-in-a-bst<i class="fas fa-external-link-alt"></i></a>)</p><p>想的是左子树顶位子的情况。看了解析用了右子树顶位，好像确实好理解一点。（包括讲解中的普通二叉树删除，也是用了右子树顶位）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这样子用例85不能通过</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;  </span><br><span class="line">    <span class="comment">// 为空直接返回  </span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> root;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (root.val == key) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span>) &#123;  </span><br><span class="line">            root = root.right;  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.right == <span class="literal">null</span>) &#123;  </span><br><span class="line">            root = root.left;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">// 应该是这里写得不对</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> root.right;  </span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">leftRight</span> <span class="operator">=</span> root.left.right;  </span><br><span class="line">            root = root.left;  </span><br><span class="line">            <span class="keyword">if</span> (leftRight != <span class="literal">null</span>) &#123;  </span><br><span class="line">                root.right = leftRight;  </span><br><span class="line">                root.right.right = right;  </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">                root.right = right;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> root;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (root.val &gt; key) &#123;  </span><br><span class="line">        root.left = deleteNode(root.left, key);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        root.right = deleteNode(root.right, key);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> root;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>看解析</h1><h2 id="235二叉搜索树的最近公共祖先-2">235二叉搜索树的最近公共祖先</h2><p>题目链接/文章讲解：<a class="link"   href="https://programmercarl.com/0235.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html" >https://programmercarl.com/0235.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html<i class="fas fa-external-link-alt"></i></a></p><p>视频讲解：[<a class="link"   href="https://www.bilibili.com/video/BV1Zt4y1F7ww" >https://www.bilibili.com/video/BV1Zt4y1F7ww<i class="fas fa-external-link-alt"></i></a>](<a class="link"   href="https://www.bilibili.com/video/BV1Zt4y1F7ww" >https://www.bilibili.com/video/BV1Zt4y1F7ww<i class="fas fa-external-link-alt"></i></a></p><h2 id="701二叉搜索树中的插入操作-2">701二叉搜索树中的插入操作</h2><p>题目链接/文章讲解：<a class="link"   href="https://programmercarl.com/0701.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.html" >https://programmercarl.com/0701.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C.html<i class="fas fa-external-link-alt"></i></a></p><p>视频讲解：<a class="link"   href="https://www.bilibili.com/video/BV1Et4y1c78Y" >https://www.bilibili.com/video/BV1Et4y1c78Y<i class="fas fa-external-link-alt"></i></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文章中给的简化版本，确实这样子思路更清晰了</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">insertIntoBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="comment">// 如果当前节点为空，也就意味着val找到了合适的位置，此时创建节点直接返回。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(val);</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; val)&#123;</span><br><span class="line">            root.right = insertIntoBST(root.right, val); <span class="comment">// 递归创建右子树</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; val)&#123;</span><br><span class="line">            root.left = insertIntoBST(root.left, val); <span class="comment">// 递归创建左子树</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="450删除二叉搜索树中的节点-2">450删除二叉搜索树中的节点</h2><p>题目链接/文章讲解：<a class="link"   href="https://programmercarl.com/0450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html" >https://programmercarl.com/0450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html<i class="fas fa-external-link-alt"></i></a></p><p>视频讲解：<a class="link"   href="https://www.bilibili.com/video/BV1tP41177us" >https://www.bilibili.com/video/BV1tP41177us<i class="fas fa-external-link-alt"></i></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">  <span class="keyword">if</span> (root.val == key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> root.right;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> root.left;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 只有这部分不一样</span></span><br><span class="line">      <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root.right;</span><br><span class="line">      <span class="keyword">while</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        cur = cur.left;</span><br><span class="line">      &#125;</span><br><span class="line">      cur.left = root.left;</span><br><span class="line">      root = root.right;</span><br><span class="line">      <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (root.val &gt; key) root.left = deleteNode(root.left, key);</span><br><span class="line">  <span class="keyword">if</span> (root.val &lt; key) root.right = deleteNode(root.right, key);</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：235、701AC，701还有更简单的写法。450通过失败。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-06-09 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="二叉树" scheme="https://kiml.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="二叉搜索树" scheme="https://kiml.github.io/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode与本地结果不一致问题</title>
    <link href="https://kiml.github.io/2024/06/08/100000034/"/>
    <id>https://kiml.github.io/2024/06/08/100000034/</id>
    <published>2024-06-08T02:50:13.000Z</published>
    <updated>2024-06-08T14:05:05.901Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>参考文章：<a class="link"   href="https://www.jianshu.com/p/2e8f7621953d" >Leetcode与本地结果不一致问题解决及分析<i class="fas fa-external-link-alt"></i></a></p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24.06.08 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h1>问题</h1><p>Leetcode提交的代码，测试用例不通过。想在本地调式查看，但是本地是没有问题的。</p><h1>原因</h1><p>本地在main方法中直接调试，部分全局变量使用了<code>static</code>关键字，Leetcode只加载了一次Solution类。导致全局变量没有恢复初始值。</p><h1>解决</h1><p>全部变量再提交到Leetcode时，手动删除<code>static</code>关键字。</p>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
参考文章：&lt;a class=&quot;link&quot;   href=&quot;https://www.jianshu.com/p/2e8f7621953d&quot; &gt;Leetcode与本地结果不一致问题解决及分析&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24.06.08 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="bug记录" scheme="https://kiml.github.io/categories/bug%E8%AE%B0%E5%BD%95/"/>
    
    <category term="2024" scheme="https://kiml.github.io/categories/bug%E8%AE%B0%E5%BD%95/2024/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第十八天-530二叉搜索树的最小绝对差、501二叉搜索树中的众数、236二叉树的最近公共祖先</title>
    <link href="https://kiml.github.io/2024/06/08/100000035/"/>
    <id>https://kiml.github.io/2024/06/08/100000035/</id>
    <published>2024-06-08T01:02:07.000Z</published>
    <updated>2024-06-09T14:32:46.798Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：530暴力遍历、501暴力、236不会。看了昨天的题解把530改成了双指针。</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24.06.08 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h1>初步题解</h1><h2 id="530二叉搜索树的最小绝对差">530二叉搜索树的最小绝对差</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst" >https://leetcode.cn/problems/minimum-absolute-difference-in-bst<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暴力遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    getMinDiff(root, list);  </span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Math.abs(list.get(<span class="number">0</span>) - list.get(<span class="number">1</span>));  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; list.size(); i++) &#123;  </span><br><span class="line">        min = Math.min(Math.abs(list.get(i) - list.get(i - <span class="number">1</span>)), min);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> min;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getMinDiff</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    getMinDiff(root.left, list);  </span><br><span class="line">    list.add(root.val);  </span><br><span class="line">    getMinDiff(root.right, list);  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 后面看了昨天最后一题的题解，这里可以用双指针</span></span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 双指针的解法  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="type">Integer</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;  </span><br><span class="line">TreeNode pre;  </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference1</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> min;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    getMinimumDifference1(root.left);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 中间遍历  </span></span><br><span class="line">    <span class="keyword">if</span> (pre != <span class="literal">null</span>) &#123;  </span><br><span class="line">        min = Math.min(Math.abs(root.val - pre.val), min);  </span><br><span class="line">    &#125;  </span><br><span class="line">    pre = root;  </span><br><span class="line">  </span><br><span class="line">    getMinimumDifference1(root.right);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> min;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="501二叉搜索树中的众数">501二叉搜索树中的众数</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/find-mode-in-binary-search-tree" >https://leetcode.cn/problems/find-mode-in-binary-search-tree<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] findMode(TreeNode root) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();  </span><br><span class="line">    find(root, map);  </span><br><span class="line">    List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; collect = map.entrySet().stream()  </span><br><span class="line">            .sorted((o1, o2) -&gt; o2.getValue() - o1.getValue())  </span><br><span class="line">            .collect(Collectors.toList());  </span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    list.add(collect.get(<span class="number">0</span>).getKey());  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; collect.size(); i++) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (collect.get(i).getValue().equals(collect.get(<span class="number">0</span>).getValue())) &#123;  </span><br><span class="line">            list.add(collect.get(i).getKey());  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> list.stream().mapToInt(i -&gt; i).toArray();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">find</span><span class="params">(TreeNode root, Map&lt;Integer, Integer&gt; map)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    find(root.left, map);  </span><br><span class="line">    map.put(root.val, map.getOrDefault(root.val, <span class="number">0</span>) + <span class="number">1</span>);  </span><br><span class="line">    find(root.right, map);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="236二叉树的最近公共祖先">236二叉树的最近公共祖先</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree" >https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree<i class="fas fa-external-link-alt"></i></a>)</p><p>没有思路。</p><h1>看解析</h1><h2 id="530二叉搜索树的最小绝对差-2">530二叉搜索树的最小绝对差</h2><p>题目链接/文章讲解：<a class="link"   href="https://programmercarl.com/0530.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE.html" >https://programmercarl.com/0530.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE.html<i class="fas fa-external-link-alt"></i></a></p><p>视频讲解：<a class="link"   href="https://www.bilibili.com/video/BV1DD4y11779" >https://www.bilibili.com/video/BV1DD4y11779<i class="fas fa-external-link-alt"></i></a></p><h2 id="501二叉搜索树中的众数-2">501二叉搜索树中的众数</h2><p>题目链接/文章讲解：<a class="link"   href="https://programmercarl.com/0501.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0.html" >https://programmercarl.com/0501.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0.html<i class="fas fa-external-link-alt"></i></a></p><p>视频讲解：<a class="link"   href="https://www.bilibili.com/video/BV1fD4y117gp" >https://www.bilibili.com/video/BV1fD4y117gp<i class="fas fa-external-link-alt"></i></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双指针的前一个节点  </span></span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;  </span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line"><span class="type">int</span> <span class="variable">maxCount</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 双指针解法  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] findMode(TreeNode root) &#123;  </span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 递归逻辑  </span></span><br><span class="line">    findModeTravel(root, list);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> list.stream().mapToInt(i -&gt; i).toArray();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">findModeTravel</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    findModeTravel(root.left, list);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (pre == <span class="literal">null</span>) &#123;  </span><br><span class="line">        count = <span class="number">1</span>;  </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (pre.val == root.val)&#123;  </span><br><span class="line">        count++;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        count = <span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    pre = root;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (count == maxCount) &#123;  </span><br><span class="line">        list.add(root.val);  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count &gt; maxCount) &#123;  </span><br><span class="line">        maxCount = count;  </span><br><span class="line">        list.clear();  </span><br><span class="line">        list.add(root.val);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    findModeTravel(root.right, list);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="236二叉树的最近公共祖先-2">236二叉树的最近公共祖先</h2><p>题目链接/文章讲解：<a class="link"   href="https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html" >https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html<i class="fas fa-external-link-alt"></i></a></p><p>视频讲解：<a class="link"   href="https://www.bilibili.com/video/BV1jd4y1B7E2" >https://www.bilibili.com/video/BV1jd4y1B7E2<i class="fas fa-external-link-alt"></i></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;  </span><br><span class="line">    <span class="comment">// return root也是空 可以和下面一起写  </span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (root == p || root == q) &#123;  </span><br><span class="line">        <span class="keyword">return</span> root;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);  </span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (left!= <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> root;  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> left;  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (right != <span class="literal">null</span> &amp;&amp; left == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> right;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：530暴力遍历、501暴力、236不会。看了昨天的题解把530改成了双指针。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24.06.08 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="双指针" scheme="https://kiml.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="二叉树" scheme="https://kiml.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="二叉搜索树" scheme="https://kiml.github.io/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第十七天-654最大二叉树、617合并二叉树、700二叉搜索树中的搜索、98验证二叉搜索树</title>
    <link href="https://kiml.github.io/2024/06/07/100000033/"/>
    <id>https://kiml.github.io/2024/06/07/100000033/</id>
    <published>2024-06-07T08:56:26.000Z</published>
    <updated>2024-06-09T13:29:55.470Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：654AC、617AC可优化、700AC、98不会</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24.06.07 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h1>初步题解</h1><h2 id="654最大二叉树">654最大二叉树</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/maximum-binary-tree/" >https://leetcode.cn/problems/maximum-binary-tree/<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">maxIndex</span> <span class="operator">=</span> getMaxIndex(nums);  </span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[maxIndex]);  </span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">1</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> root;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    root.left = constructMaximumBinaryTree(Arrays.copyOfRange(nums, <span class="number">0</span>, maxIndex));  </span><br><span class="line">    root.right = constructMaximumBinaryTree(Arrays.copyOfRange(nums, maxIndex + <span class="number">1</span>, nums.length));  </span><br><span class="line">    <span class="keyword">return</span> root;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getMaxIndex</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">maxIndex</span> <span class="operator">=</span> -<span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; max) &#123;  </span><br><span class="line">            maxIndex = i;  </span><br><span class="line">            max = nums[i];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> maxIndex;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="617合并二叉树">617合并二叉树</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/merge-two-binary-trees/" >https://leetcode.cn/problems/merge-two-binary-trees/<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="literal">null</span> &amp;&amp; root2 == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">value1</span> <span class="operator">=</span> root1 == <span class="literal">null</span> ? <span class="number">0</span> : root1.val;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">value2</span> <span class="operator">=</span> root2 == <span class="literal">null</span> ? <span class="number">0</span> : root2.val;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(value1 + value2);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="literal">null</span>) &#123;  </span><br><span class="line">        node.left = mergeTrees(<span class="literal">null</span>, root2.left);  </span><br><span class="line">        node.right = mergeTrees(<span class="literal">null</span>, root2.right);  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root2 == <span class="literal">null</span>)&#123;  </span><br><span class="line">        node.left = mergeTrees(root1.left, <span class="literal">null</span>);  </span><br><span class="line">        node.right = mergeTrees(root1.right, <span class="literal">null</span>);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        node.left = mergeTrees(root1.left, root2.left);  </span><br><span class="line">        node.right = mergeTrees(root1.right, root2.right);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> node;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="700二叉搜索树中的搜索">700二叉搜索树中的搜索</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/search-in-a-binary-search-tree" >https://leetcode.cn/problems/search-in-a-binary-search-tree<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * BFS </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">searchBST</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (val == root.val) &#123;  </span><br><span class="line">        <span class="keyword">return</span> root;  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; root.val) &#123;  </span><br><span class="line">        <span class="keyword">return</span> searchBST(root.left, val);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> searchBST(root.right, val);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * DFS </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> TreeNode <span class="title function_">searchBSTDFS</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;  </span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (val == root.val) &#123;  </span><br><span class="line">            <span class="keyword">return</span> root;  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (val &lt; root.val)&#123;  </span><br><span class="line">            root = root.left;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            root = root.right;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="98验证二叉搜索树">98验证二叉搜索树</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/validate-binary-search-tree/" >https://leetcode.cn/problems/validate-binary-search-tree/<i class="fas fa-external-link-alt"></i></a>)</p><p>只比较了<strong>左节点小于中间节点，右节点大于中间节点</strong>，实际上要加上<strong>左子树所有节点小于中间节点，右子树所有节点大于中间节点</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有通过，少算了一种情况</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 左子树不为空并且大于  </span></span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="literal">null</span> &amp;&amp; root.left.val &gt;= root.val) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">        <span class="comment">// 右子树不为空并且小于  </span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.right != <span class="literal">null</span> &amp;&amp; root.right.val &lt;= root.val) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> isValidBST(root.left) &amp;&amp; isValidBST(root.right);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>看解析</h1><h2 id="654最大二叉树-2">654最大二叉树</h2><p>题目链接/文章讲解：(<a class="link"   href="https://programmercarl.com/0654.%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91.html" >https://programmercarl.com/0654.最大二叉树.html<i class="fas fa-external-link-alt"></i></a>)</p><p>视频讲解：<a class="link"   href="https://www.bilibili.com/video/BV1MG411G7ox" >https://www.bilibili.com/video/BV1MG411G7ox<i class="fas fa-external-link-alt"></i></a></p><h2 id="617合并二叉树-2">617合并二叉树</h2><p>题目链接/文章讲解：(<a class="link"   href="https://programmercarl.com/0617.%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91.html" >https://programmercarl.com/0617.合并二叉树.html<i class="fas fa-external-link-alt"></i></a>)</p><p>视频讲解：<a class="link"   href="https://www.bilibili.com/video/BV1m14y1Y7JK" >https://www.bilibili.com/video/BV1m14y1Y7JK<i class="fas fa-external-link-alt"></i></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优化后</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees1</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root1 == <span class="literal">null</span> &amp;&amp; root2 != <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> root2;  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root1 != <span class="literal">null</span> &amp;&amp; root2 == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> root1;  </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root1 == <span class="literal">null</span> &amp;&amp; root2 == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(root1.val + root2.val);  </span><br><span class="line">        node.left = mergeTrees(root1.left, root2.left);  </span><br><span class="line">        node.right = mergeTrees(root1.right, root2.right);  </span><br><span class="line">        <span class="keyword">return</span> node;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="700二叉搜索树中的搜索-2">700二叉搜索树中的搜索</h2><p>题目链接/文章讲解：(<a class="link"   href="https://programmercarl.com/0700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2.html" >https://programmercarl.com/0700.二叉搜索树中的搜索.html<i class="fas fa-external-link-alt"></i></a>)</p><p>视频讲解：<a class="link"   href="https://www.bilibili.com/video/BV1wG411g7sF" >https://www.bilibili.com/video/BV1wG411g7sF<i class="fas fa-external-link-alt"></i></a></p><p>二叉搜索树是一个有序树：</p><ul class="lvl-0"><li class="lvl-2"><p>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</p></li><li class="lvl-2"><p>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</p></li><li class="lvl-2"><p>它的左、右子树也分别为二叉搜索树</p></li></ul><h2 id="98验证二叉搜索树-2">98验证二叉搜索树</h2><p>题目链接/文章讲解：(<a class="link"   href="https://programmercarl.com/0098.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html" >https://programmercarl.com/0098.验证二叉搜索树.html<i class="fas fa-external-link-alt"></i></a>)</p><p>视频讲解：<a class="link"   href="https://www.bilibili.com/video/BV18P411n7Q4" >https://www.bilibili.com/video/BV18P411n7Q4<i class="fas fa-external-link-alt"></i></a></p><p>关键在于：<strong>中序遍历下，输出的二叉搜索树节点的数值是有序序列。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    inorder(root, list);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (list.size() &lt;= <span class="number">1</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size() - <span class="number">1</span>; i++) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (list.get(i) &gt;= list.get(i + <span class="number">1</span>)) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; list)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    inorder(root.left, list);  </span><br><span class="line">    list.add(root.val);  </span><br><span class="line">    inorder(root.right, list);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 单次循环搞定</span></span><br><span class="line"><span class="comment"> * 双指针法</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line">TreeNode max;  </span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST1</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 左  </span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">left</span> <span class="operator">=</span> isValidBST1(root.left);  </span><br><span class="line">    <span class="keyword">if</span> (!left) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 中  </span></span><br><span class="line">    <span class="keyword">if</span> (max != <span class="literal">null</span> &amp;&amp; root.val &lt;= max.val) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    max = root;  </span><br><span class="line">    <span class="comment">// 右  </span></span><br><span class="line">    <span class="keyword">return</span> isValidBST1(root.right);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：654AC、617AC可优化、700AC、98不会&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24.06.07 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="双指针" scheme="https://kiml.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="二叉树" scheme="https://kiml.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="二叉搜索树" scheme="https://kiml.github.io/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第十六天-513找树左下角的值、112路径总和、113路径总和ii、106从中序与后序遍历序列构造二叉树、105从前序与中序遍历序列构造二叉树</title>
    <link href="https://kiml.github.io/2024/06/07/100000032/"/>
    <id>https://kiml.github.io/2024/06/07/100000032/</id>
    <published>2024-06-07T01:10:00.000Z</published>
    <updated>2024-06-09T13:29:40.991Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：513用层序AC、112AC（但时间复杂度较高））（解析中给的方法和想的不一样），113AC、106不会</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24.06.07 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h1>初步题解</h1><h2 id="513找树左下角的值">513找树左下角的值</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/find-bottom-left-tree-value" >https://leetcode.cn/problems/find-bottom-left-tree-value<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 看题目感觉层序遍历简单一点  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValue</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    findBottomDFS(root, <span class="number">0</span>, list);  </span><br><span class="line">    List&lt;Integer&gt; theLastLayer = list.get(list.size() - <span class="number">1</span>);  </span><br><span class="line">    <span class="keyword">return</span> theLastLayer.stream().filter(Objects::nonNull).collect(Collectors.toList()).get(<span class="number">0</span>);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">findBottomDFS</span><span class="params">(TreeNode root, <span class="type">int</span> i, List&lt;List&lt;Integer&gt;&gt; list)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 深度增加  </span></span><br><span class="line">    i++;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (list.size() &lt; i) &#123;  </span><br><span class="line">        ArrayList&lt;Integer&gt; innerList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">        list.add(innerList);  </span><br><span class="line">    &#125;  </span><br><span class="line">    list.get(i - <span class="number">1</span>).add(root.val);  </span><br><span class="line">  </span><br><span class="line">    findBottomDFS(root.left, i, list);  </span><br><span class="line">    findBottomDFS(root.right, i, list);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="112路径总和、113路径总和ii">112路径总和、113路径总和ii</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/path-sum/description/" >https://leetcode.cn/problems/path-sum/description/<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 感觉之前做过求路径的题（递归+迭代）这题应该变换一下  </span></span><br><span class="line"><span class="comment"> * 时间复杂度好像有点高，剩下那题等看完解析后再写</span></span><br><span class="line"><span class="comment"> * 后面改用sum直接加减不遍历求总和，但是leetcode不通过，本地倒是测试没问题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetSum 目标和  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();  </span><br><span class="line">    <span class="keyword">return</span> hasPathSumBFS(root, list, targetSum);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasPathSumBFS</span><span class="params">(TreeNode root, List&lt;Integer&gt; list, <span class="type">int</span> targetSum)</span> &#123;  </span><br><span class="line">    list.add(root.val);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="comment">// 求list中的总和  </span></span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> list.stream().collect(Collectors.summarizingInt(value -&gt; value)).getSum();  </span><br><span class="line">        <span class="keyword">return</span> sum == targetSum;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">boolean</span> <span class="variable">left</span> <span class="operator">=</span> <span class="literal">false</span>;  </span><br><span class="line">    <span class="type">boolean</span> <span class="variable">right</span> <span class="operator">=</span> <span class="literal">false</span>;  </span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;  </span><br><span class="line">        left = hasPathSumBFS(root.left, list, targetSum);  </span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;  </span><br><span class="line">        right = hasPathSumBFS(root.right, list, targetSum);  </span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> left || right;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/path-sum-ii/" >https://leetcode.cn/problems/path-sum-ii/<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;  </span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    pathSumBFS(root, targetSum, result, list);  </span><br><span class="line">    <span class="keyword">return</span> result;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">pathSumBFS</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum, List&lt;List&lt;Integer&gt;&gt; result, List&lt;Integer&gt; list)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    targetSum -= root.val;  </span><br><span class="line">    list.add(root.val);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (targetSum == <span class="number">0</span>) &#123;  </span><br><span class="line">            List&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list);  </span><br><span class="line">            result.add(arrayList);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;  </span><br><span class="line">        pathSumBFS(root.left, targetSum, result, list);  </span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;  </span><br><span class="line">        pathSumBFS(root.right, targetSum, result, list);  </span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="106从中序与后序遍历序列构造二叉树、105从前序与中序遍历序列构造二叉树">106从中序与后序遍历序列构造二叉树、105从前序与中序遍历序列构造二叉树</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/" >https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不会，直接看解析</span><br></pre></td></tr></table></figure><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" >https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/<i class="fas fa-external-link-alt"></i></a>)</p><p>更快的解法是把inorder放到map内，这样查找不用遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (preorder.length == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[<span class="number">0</span>]);  </span><br><span class="line">    <span class="keyword">if</span> (preorder.length == <span class="number">1</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> root;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">indexIn</span> <span class="operator">=</span> -<span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (inorder[i] == preorder[<span class="number">0</span>]) &#123;  </span><br><span class="line">            indexIn = i;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 左子树  </span></span><br><span class="line">    <span class="type">int</span>[] leftTreeInorder = Arrays.copyOfRange(inorder, <span class="number">0</span>, indexIn);  </span><br><span class="line">    <span class="comment">// 右子树  </span></span><br><span class="line">    <span class="type">int</span>[] rightTreeInorder = Arrays.copyOfRange(inorder, indexIn + <span class="number">1</span>, inorder.length);  </span><br><span class="line">  </span><br><span class="line">    root.left = buildTree(Arrays.copyOfRange(preorder, <span class="number">1</span>, leftTreeInorder.length + <span class="number">1</span>), leftTreeInorder);  </span><br><span class="line">    root.right = buildTree(Arrays.copyOfRange(preorder, inorder.length - rightTreeInorder.length, inorder.length), rightTreeInorder);  </span><br><span class="line">    <span class="keyword">return</span> root;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>看解析</h1><h2 id="513找树左下角的值-2">513找树左下角的值</h2><p>题目链接/文章讲解/视频讲解：(<a class="link"   href="https://programmercarl.com/0513.%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC.html" >https://programmercarl.com/0513.找树左下角的值.html<i class="fas fa-external-link-alt"></i></a>)</p><p>那么如何找最左边的呢？可以使用前序遍历（当然中序，后序都可以，因为本题没有 中间节点的处理逻辑，只要左优先就行），保证优先左边搜索，然后记录深度最大的叶子节点，此时就是树的最后一行最左边的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归法</span></span><br><span class="line"><span class="type">int</span> value;  </span><br><span class="line"><span class="type">int</span> <span class="variable">maxDeep</span> <span class="operator">=</span> Integer.MIN_VALUE;  </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findBottomLeftValueBFS</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    value = root.val;  </span><br><span class="line">    findLeftValue(root,<span class="number">0</span>);  </span><br><span class="line">    <span class="keyword">return</span> value;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">findLeftValue</span><span class="params">(TreeNode root, <span class="type">int</span> deep)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (deep &gt; maxDeep) &#123;  </span><br><span class="line">            value = root.val;  </span><br><span class="line">            maxDeep = deep;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;  </span><br><span class="line">        findLeftValue(root.left, deep + <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;  </span><br><span class="line">        findLeftValue(root.right, deep + <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="112路径总和、113路径总和ii-2">112路径总和、113路径总和ii</h2><p>题目链接/文章讲解/视频讲解：(<a class="link"   href="https://programmercarl.com/0112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.html" >https://programmercarl.com/0112.路径总和.html<i class="fas fa-external-link-alt"></i></a>)</p><p>绕晕了，如果把<code>targetSum -= root.val;</code>这句话写在函数最前面，就不用回溯。可以看三行简化的那个注释。我理解的是Java里int不能传递值，递归内层对targetSum的值进行改变，外层不会变化，所以就不用回溯了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没搞懂怎么就不用回溯了，因为int不能传值吗？</span></span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 感觉之前做过求路径的题（递归+迭代）这题应该变换一下  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targetSum 目标和  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    targetSum -= root.val;  </span><br><span class="line">    <span class="keyword">return</span> hasPathSumBFS(root, targetSum);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">hasPathSumBFS</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="comment">// 求list中的总和  </span></span><br><span class="line">        <span class="keyword">return</span> targetSum == <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;  </span><br><span class="line">        targetSum -= root.left.val;  </span><br><span class="line">        <span class="keyword">if</span> (hasPathSumBFS(root.left, targetSum)) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 这里的回溯就是把当前节点减掉（数值加上）。包括之前也是，但是之前是list不太好移除，所以选择移除最后一位</span></span><br><span class="line">        targetSum += root.left.val;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 上面三行可以简化成  </span></span><br><span class="line"><span class="comment">if (root.left != null) &#123;  </span></span><br><span class="line"><span class="comment">    // 这里targetSum的值是没有变化的。减完的值进入循环，就不用回溯了  </span></span><br><span class="line"><span class="comment">    hasPathSumBFS(root.left, targetSum - root.left.val);  </span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;  </span><br><span class="line">        targetSum -= root.right.val;  </span><br><span class="line">        <span class="keyword">if</span> (hasPathSumBFS(root.right, targetSum)) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        targetSum += root.right.val;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 简化版本  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> targetSum == <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">return</span> hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="106从中序与后序遍历序列构造二叉树、105从前序与中序遍历序列构造二叉树-2">106从中序与后序遍历序列构造二叉树、105从前序与中序遍历序列构造二叉树</h2><p>题目链接/文章讲解/视频讲解：(<a class="link"   href="https://programmercarl.com/0106.%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html" >https://programmercarl.com/0106.从中序与后序遍历序列构造二叉树.html<i class="fas fa-external-link-alt"></i></a>)</p><p>更快的解法是把inorder放到map内，这样查找不用遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 1.后序最后一个节点为根节点  </span></span><br><span class="line"><span class="comment"> * 2.根据这个节点切割中序数组（节点前为左子树，节点后为右子树）  </span></span><br><span class="line"><span class="comment"> * 3.根据中序数组的切割切割后序数组  </span></span><br><span class="line"><span class="comment"> * 4.递归  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inorder 中序遍历结果  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> postorder 后序遍历结果  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 树  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (inorder.length != postorder.length) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (postorder.length == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(postorder[postorder.length - <span class="number">1</span>]);  </span><br><span class="line">    <span class="keyword">if</span> (postorder.length == <span class="number">1</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> root;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">indexIn</span> <span class="operator">=</span> -<span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (inorder[i] == postorder[postorder.length - <span class="number">1</span>]) &#123;  </span><br><span class="line">            indexIn = i;  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 左子树  </span></span><br><span class="line">    <span class="type">int</span>[] leftTreeInorder = Arrays.copyOfRange(inorder, <span class="number">0</span>, indexIn);  </span><br><span class="line">    <span class="comment">// 右子树  </span></span><br><span class="line">    <span class="type">int</span>[] rightTreeInorder = Arrays.copyOfRange(inorder, indexIn + <span class="number">1</span>, inorder.length);  </span><br><span class="line">  </span><br><span class="line">    root.left = buildTree(leftTreeInorder, Arrays.copyOfRange(postorder, <span class="number">0</span>, leftTreeInorder.length));  </span><br><span class="line">    root.right = buildTree(rightTreeInorder, Arrays.copyOfRange(postorder, leftTreeInorder.length, postorder.length - <span class="number">1</span>));  </span><br><span class="line">    <span class="keyword">return</span> root;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：513用层序AC、112AC（但时间复杂度较高））（解析中给的方法和想的不一样），113AC、106不会&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24.06.07 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="二叉树" scheme="https://kiml.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>WebStorm常用设置</title>
    <link href="https://kiml.github.io/2024/06/06/100000030/"/>
    <id>https://kiml.github.io/2024/06/06/100000030/</id>
    <published>2024-06-06T09:54:58.000Z</published>
    <updated>2024-06-06T13:32:09.621Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>WebStorm常用设置</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24.06.06 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h1>基本设置</h1><p>因为是同一家公司，一些基本的配置与IntelliJ IDEA是相同的，这里就不再赘述了。</p><blockquote><p>[[IntelliJ IDEA常用设置]]<br><a class="link"   href="https://kiml.site/2023/07/02/100000003/" >IntelliJ IDEA常用设置<i class="fas fa-external-link-alt"></i></a></p></blockquote><h1>推荐插件</h1><h2 id="ESLint-Restart-Service-Action">ESLint Restart Service Action</h2><blockquote><p>使用 ESLint自动格式化代码。<br><img                       lazyload                     alt="image"                     data-src="https://blog-resources.oss-cn-hangzhou.aliyuncs.com/240606/Snipaste_2024-06-06_21-16-59.png"                      alt=""                ></p></blockquote><h2 id="GitToolBox">GitToolBox</h2><blockquote><p>显示更详细的git信息很多 Git 的功能增强，比如自动 fetch 代码，状态栏中显示当前 Git 分支的未提交和落后提交数显示，过时分支清理，commit 窗口支持 emoji 表情，Inline Blame 可以看到每行代码是谁提交的、什么时候提交的、以及 commit 信息等等，如果你经常用 Git，这个插件必装了。</p></blockquote><h2 id="HighlightBracketPair">HighlightBracketPair</h2><blockquote><p>高亮括号</p></blockquote><h2 id="Key-Promoter-X">Key Promoter X</h2><blockquote><p>快捷键提示</p></blockquote><h2 id="IntelliVue">IntelliVue</h2><blockquote><p>Webstorm 上对 Vue 支持很棒的插件，现在已经支持 Vue3 的一些语法，可以快速创建 Vue2 的 data、methods 等，或者 Vue3 的 setup method 等，帮你少些一些模板代码。</p></blockquote><h2 id="ignore">.ignore</h2><blockquote><p><code>.ignore</code> 插件支持创建多种 <code>.ignore</code> 文件比如 <code>.gitignore</code>、<code>.eslintignore</code>、<code>.dockerignore</code> 等等，我们最常用的基本都支持，新建的时候支持选择不同类型的框架或库常用的忽略配置，如 <code>node_modules</code>、<code>dist</code>、<code>.cache</code> 等。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
WebStorm常用设置&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24.06.06 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="环境搭建" scheme="https://kiml.github.io/categories/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>Long长度大于17位时，精度丢失</title>
    <link href="https://kiml.github.io/2024/06/06/100000029/"/>
    <id>https://kiml.github.io/2024/06/06/100000029/</id>
    <published>2024-06-06T09:07:38.000Z</published>
    <updated>2024-06-06T09:16:17.861Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24.06.06 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h1>问题</h1><p>前端JS在Long长度大于17位时，出现精度丢失的问题</p><h1>解决</h1><p>在此处添加注 解将返回给前端的门店ID自动转为string类型。</p><ol><li class="lvl-3"><p>使用jackson来完成自动转换，添加依赖</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li class="lvl-3"><p>在对应的实体类中添加注解</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonSerialize(using= ToStringSerializer.class)</span> </span><br><span class="line"><span class="keyword">private</span> Long id;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24.06.06 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="bug记录" scheme="https://kiml.github.io/categories/bug%E8%AE%B0%E5%BD%95/"/>
    
    <category term="2024" scheme="https://kiml.github.io/categories/bug%E8%AE%B0%E5%BD%95/2024/"/>
    
    
    <category term="Java" scheme="https://kiml.github.io/tags/Java/"/>
    
    <category term="BUG" scheme="https://kiml.github.io/tags/BUG/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第十五天-110平衡二叉树 、257二叉树的所有路径、404左叶子之和</title>
    <link href="https://kiml.github.io/2024/06/06/100000028/"/>
    <id>https://kiml.github.io/2024/06/06/100000028/</id>
    <published>2024-06-06T01:07:13.000Z</published>
    <updated>2024-06-09T14:16:44.293Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：110，404AC，257不会。迭代法没有写</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24.06.06 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h1>初步题解</h1><h2 id="110平衡二叉树">110平衡二叉树</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/balanced-binary-tree/" >https://leetcode.cn/problems/balanced-binary-tree/<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LE110</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">        <span class="keyword">return</span> getHeight(root) != -<span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getHeight</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="type">int</span> <span class="variable">leftHeight</span> <span class="operator">=</span> getHeight(root.left);  </span><br><span class="line">        <span class="keyword">if</span> (leftHeight == -<span class="number">1</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="type">int</span> <span class="variable">rightHeight</span> <span class="operator">=</span> getHeight(root.right);  </span><br><span class="line">        <span class="keyword">if</span> (rightHeight == -<span class="number">1</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (Math.abs(leftHeight - rightHeight) &gt; <span class="number">1</span>) &#123;  </span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(leftHeight, rightHeight);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="257二叉树的所有路径">257二叉树的所有路径</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/binary-tree-paths/description/" >https://leetcode.cn/problems/binary-tree-paths/description/<i class="fas fa-external-link-alt"></i></a>)</p><p>(不会)</p><h2 id="404左叶子之和">404左叶子之和</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="literal">null</span> &amp;&amp; root.left.left == <span class="literal">null</span> &amp;&amp; root.left.right == <span class="literal">null</span>) &#123;  </span><br><span class="line">        sum += root.left.val;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> sum + sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>看解析</h1><h2 id="110平衡二叉树-2">110平衡二叉树</h2><p>题目链接/文章讲解/视频讲解：(<a class="link"   href="https://programmercarl.com/0110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html" >https://programmercarl.com/0110.平衡二叉树.html<i class="fas fa-external-link-alt"></i></a>)</p><p>分别求出其左右子树的高度，然后如果差值小于等于1，则返回当前二叉树的高度，否则返回-1，表示已经不是二叉平衡树了。</p><h2 id="257二叉树的所有路径-2">257二叉树的所有路径</h2><p>题目链接/文章讲解/视频讲解：(<a class="link"   href="https://programmercarl.com/0257.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84.html" >https://programmercarl.com/0257.二叉树的所有路径.html<i class="fas fa-external-link-alt"></i></a>)</p><p>主要是这个回溯有点懵，不知道怎么写了。但是写完代码跟着断点跑一遍，可以看到：在有下个节点时，会一直递归，直到进入到最后一个节点。在返回的途中，会把所有的进入操作，回退回去（即回退到交叉节点那个位置）。可能表述的不是很清楚，写完代码跑一遍就清楚了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    List&lt;String&gt; pathString = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> pathString;  </span><br><span class="line">    &#125;  </span><br><span class="line">    List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    binaryTree(root, path, pathString);  </span><br><span class="line">    <span class="keyword">return</span> pathString;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">binaryTree</span><span class="params">(TreeNode root, List&lt;Integer&gt; path, List&lt;String&gt; pathString)</span> &#123; </span><br><span class="line">    path.add(root.val);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span> &amp;&amp; (root.right == <span class="literal">null</span> &amp;&amp; root.left == <span class="literal">null</span>)) &#123;  </span><br><span class="line">        pathString.add(path.stream().map(Object::toString).collect(Collectors.joining(<span class="string">&quot;-&gt;&quot;</span>)));  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;  </span><br><span class="line">        binaryTree(root.left, path, pathString);  </span><br><span class="line">        path.remove(path.size() - <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;  </span><br><span class="line">        binaryTree(root.right, path, pathString);  </span><br><span class="line">        path.remove(path.size() - <span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="404左叶子之和-2">404左叶子之和</h2><p>题目链接/文章讲解/视频讲解：(<a class="link"   href="https://programmercarl.com/0404.%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C.html" >https://programmercarl.com/0404.左叶子之和.html<i class="fas fa-external-link-alt"></i></a>)</p>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：110，404AC，257不会。迭代法没有写&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24.06.06 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="二叉树" scheme="https://kiml.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>使用mapstruct转换对象，报错Cannot find implementation for……</title>
    <link href="https://kiml.github.io/2024/06/05/100000027/"/>
    <id>https://kiml.github.io/2024/06/05/100000027/</id>
    <published>2024-06-05T08:31:33.000Z</published>
    <updated>2024-06-05T08:39:12.205Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>参考文章：<a class="link"   href="https://blog.csdn.net/qq_41169544/article/details/127664756" >mapstruct 报错 java.lang.ClassNotFoundException: Cannot find implementation for<i class="fas fa-external-link-alt"></i></a></p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24.06.05 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h1>问题</h1><p>使用mapstruct转换对象，接口可以启动，但是执行报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.ClassNotFoundException: Cannot find implementation for com.…….convert.AuthorizationPrivilegeConvert</span><br></pre></td></tr></table></figure><h1>原因</h1><p>注解没有引用全。</p><h1>解决</h1><p>添加依赖，重启服务。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mapstruct<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapstruct-jdk8<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>……<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mapstruct<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapstruct-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>……<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
参考文章：&lt;a class=&quot;link&quot;   href=&quot;https://blog.csdn.net/qq_41169544/article/details/127664756&quot; &gt;mapstruct 报错 java.lang.ClassNotFoundException: Cannot find implementation for&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24.06.05 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="bug记录" scheme="https://kiml.github.io/categories/bug%E8%AE%B0%E5%BD%95/"/>
    
    <category term="2024" scheme="https://kiml.github.io/categories/bug%E8%AE%B0%E5%BD%95/2024/"/>
    
    
    <category term="Java" scheme="https://kiml.github.io/tags/Java/"/>
    
    <category term="BUG" scheme="https://kiml.github.io/tags/BUG/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第十四天-104二叉树的最大深度、111二叉树的最小深度、222完全二叉树的节点个数</title>
    <link href="https://kiml.github.io/2024/06/05/100000026/"/>
    <id>https://kiml.github.io/2024/06/05/100000026/</id>
    <published>2024-06-05T01:07:38.000Z</published>
    <updated>2024-06-09T13:24:04.490Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：104、111可以AC，222没有思路</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24.06.04 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h1>初步题解</h1><h2 id="104二叉树的最大深度">104二叉树的最大深度</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/" >https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 思路：递归计算左右子树的深度。取较大值  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">leftLength</span> <span class="operator">=</span> maxDepth(root.left);  </span><br><span class="line">    <span class="type">int</span> <span class="variable">rightLength</span> <span class="operator">=</span> maxDepth(root.right);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + Math.max(leftLength, rightLength);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="111二叉树的最小深度">111二叉树的最小深度</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/" >https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 思路：  </span></span><br><span class="line"><span class="comment"> * 递归终止条件  </span></span><br><span class="line"><span class="comment"> * 1.根节点为空，直接返回0  </span></span><br><span class="line"><span class="comment"> * 2.根节点的左右节点有一个为空，返回另一个节点的最小深度  </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (root.right == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + minDepth(root.left);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + minDepth(root.right);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + Math.min(minDepth(root.right), minDepth(root.left));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="222完全二叉树的节点个数">222完全二叉树的节点个数</h2><p>题目链接:(<a class="link"   href="https://leetcode.cn/problems/count-complete-tree-nodes/description/" >https://leetcode.cn/problems/count-complete-tree-nodes/description/<i class="fas fa-external-link-alt"></i></a>)</p><p>没有AC，思路只有一半。根据题解：递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后按满二叉树的情况来算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误解法，正确解法在看解析部分。</span></span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 思路：既然是完全二叉树。深度可以很简单的求出来  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> getDepth(root);  </span><br><span class="line">    <span class="comment">// n - 1 层的节点数量  </span></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> (depth - <span class="number">1</span>) ^ <span class="number">2</span> - <span class="number">1</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 求完全二叉树的深度  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getDepth</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;  </span><br><span class="line">        depth++;  </span><br><span class="line">        root = root.left;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> depth;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>看解析</h1><h2 id="104二叉树的最大深度-2">104二叉树的最大深度</h2><p>题目链接/文章讲解/视频讲解：(<a class="link"   href="https://programmercarl.com/0104.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6.html" >https://programmercarl.com/0104.二叉树的最大深度.html<i class="fas fa-external-link-alt"></i></a>)</p><p>本题可以使用前序（中左右），也可以使用后序遍历（左右中），使用前序求的就是深度，使用后序求的是高度。</p><ul class="lvl-0"><li class="lvl-2"><p>二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数或者节点数（取决于深度从0开始还是从1开始）</p></li><li class="lvl-2"><p>二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数或者节点数（取决于高度从0开始还是从1开始）<br><strong>根节点的高度就是二叉树的最大深度</strong>。</p></li></ul><h3 id="559-N-叉树的最大深度">559. N 叉树的最大深度</h3><p>题目链接(<a class="link"   href="https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/" >https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(Node root)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (Node child : root.children) &#123;  </span><br><span class="line">        max = Math.max(maxDepth(child), max);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + max;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="111二叉树的最小深度-2">111二叉树的最小深度</h2><p>题目链接/文章讲解/视频讲解：(<a class="link"   href="https://programmercarl.com/0111.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6.html" >https://programmercarl.com/0111.二叉树的最小深度.html<i class="fas fa-external-link-alt"></i></a>)</p><p><strong>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</strong> 注意是<strong>叶子节点</strong>。（左右孩子都为空的节点才是叶子节点）</p><h2 id="222完全二叉树的节点个数-2">222完全二叉树的节点个数</h2><p>题目链接/文章讲解/视频讲解：(<a class="link"   href="https://programmercarl.com/0222.%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0.html" >https://programmercarl.com/0222.完全二叉树的节点个数.html<i class="fas fa-external-link-alt"></i></a>)</p><p>递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后按满二叉树的情况来算。<strong>所以需要判断是否是满二叉树</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 完全二叉树求节点  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> root.left;  </span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> root.right;  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">leftLength</span> <span class="operator">=</span> <span class="number">0</span>, rightLength = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (left != <span class="literal">null</span>) &#123;  </span><br><span class="line">        left = left.left;  </span><br><span class="line">        leftLength++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">while</span> (right != <span class="literal">null</span>) &#123;  </span><br><span class="line">        right = right.right;  </span><br><span class="line">        rightLength++;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (leftLength == rightLength) &#123;  </span><br><span class="line">        <span class="keyword">return</span> (<span class="number">2</span> &lt;&lt; leftLength) - <span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> countNodes(root.left) + countNodes(root.right) + <span class="number">1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：104、111可以AC，222没有思路&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24.06.04 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="二叉树" scheme="https://kiml.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>面试-并发🤕</title>
    <link href="https://kiml.github.io/2024/06/03/100000024/"/>
    <id>https://kiml.github.io/2024/06/03/100000024/</id>
    <published>2024-06-03T13:42:40.000Z</published>
    <updated>2024-06-10T14:15:28.013Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>❗表示必掌握，❔表示基本不会问</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">24.06.03 初始记录</span><br><span class="line">24.06.04 AQS</span><br><span class="line">24.06.05 线程池</span><br><span class="line">24.06.06 高并发</span><br><span class="line">24.06.10 总结</span><br></pre></td></tr></table></figure><span id="more"></span><h1>高并发（锁）</h1><h2 id="❗Java内存模型的理解">❗Java内存模型的理解</h2><p>大白话：Java的对象都是处于主内存之中，而线程拥有自己的工作内存（CPU级别的缓存）。操作过程，1) 线程把主内存中的数据读出read，2) 线程把值加载到工作内存中load，3) 线程使用这个值use，4) 线程把算好的值设置到工作内存assign，5) 把值存入store，6) 写入主内存write。如果有两个线程，会同时操作，即并发（操作结果可能只有一次的结果）。</p><blockquote><p>首先，JAVA内存模型是指JMM，而不是指内存结构，内存结构是在物理上的区域划分，而JMM则是抽象概念上的划分。</p><p>JMM（内存模型）主要包括两块：<strong>主内存</strong>+<strong>工作内存</strong>。</p><p>主内存：多个线程间通信的共享内存称之为主内存，即，数据是多个线程工共享的，在物理内存结构上通常对应“堆”中的线程共享数据。</p><p>工作内存：多个线程各自对应自己的本地内存，即，数据只属于该线程自己的，在物理内存结构上通常对应“本地方法栈”中的线程私有数据。</p><p>Java内存模型规定了所有的变量都存储在主内存(Main Memory)中，每条线程还有自己的工作内存(Working Memory)，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作(读取、赋值等)都必须在工作内存中进行，而不能直接读写主内存中的变量，不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值得传递均需要通过主内存来实现。</p></blockquote><h3 id="❗Java内存模型中的原子性、有序性、可见性">❗Java内存模型中的原子性、有序性、可见性</h3><p>可见性：一个线程操作完，另一个线程必须读取操作后的数据。原子性：同时只有一个线程能操作。（不加操作默认情况下就是没有原子性的）有序性：编译之后，可能会指令重排。如果具备有序性，就不会发生指令重排。</p><h3 id="❗从Java底层角度聊聊volatile关键字的原理">❗从Java底层角度聊聊volatile关键字的原理</h3><blockquote><p>volatile关键字与可见性的关系</p></blockquote><p>volatile关键字是用来解决可见性和有序性。给数据加上volatile关键字，在线程更新数据时，会把其他线程内缓存的数据值失效，这时其他线程会强制重新从主内存加载数据值（变成新的缓存）。</p><p>在很多开源中间件系统中，大量使用volatile。例子：在main方法中，会有一段逻辑，如果主线程在执行，不可以后台退出（这里的执行状态用一个值表示，根据值判断系统是否在运行）。如果提供了一个方法，需要关闭主线程，如果不加volatile关键字，其他线程更新状态，主线程没有同步，就会出问题。（<strong>这个类似的用法会在多处使用</strong>）</p><h3 id="❗指令重排以及happens-before原则">❗指令重排以及happens-before原则</h3><blockquote><p>volatile关键字与有序性的关系、连带问题</p></blockquote><p>❔<strong>happens-before原则</strong>：</p><ol><li class="lvl-3"><p>程序次序规则：一个线程内，代码按写的顺序执行</p></li><li class="lvl-3"><p>锁定规则：一个unLock操作先行与后一个Lock的操作（先解锁，后加锁）</p></li><li class="lvl-3"><p>volatile变量规则：加了volatile关键字，写操作先，读操作后</p></li><li class="lvl-3"><p>传递规则：如果A先于B，B先于C，那么A一定先于C</p></li><li class="lvl-3"><p>线程启动规则：线程的启动<code>start()</code>方法先于此线程的每个操作</p></li><li class="lvl-3"><p>线程中断规则：对线程的<code>interrupt()</code>调用，先于检测到终端的发生</p></li><li class="lvl-3"><p>线程终结规则：线程的所有操作都先于线程的终止检测操作</p></li><li class="lvl-3"><p>对象终结规则：对象的初始化在<code>finalize()</code>之前</p></li></ol><p>这个规则制定了在特殊情况下，不允许指令重排。而因为这个规则，volatile关键字有一定的防止指令重排的效果（只能先写后读）。</p><p>同时，volatile关键字本身，就有其他避免指令重排的规则（就是底层。。。最好不要问这个，谁记得住啊）。</p><h3 id="❗volatile底层是如何基于内存屏障保证可见性和有序性的">❗volatile底层是如何基于内存屏障保证可见性和有序性的</h3><p>volatile不能保证原子性。（只能加锁synchronized、lock）。</p><p>volatile保证可见性：对于volatile修饰的变量，执行写操作，JVM会发送一条lock前缀指令给CPU，CPU在计算完之后将值强制刷回主内存。其他线程有一个嗅探机制（<strong>MESI缓存一致性协议</strong>），会去失效线程内的缓存。</p><p>volatile保证有序性：加入内存屏障，可以禁止指令重排。</p><blockquote><p>对于volatile修改变量的读写操作，都会加入内存屏障。每个volatile写操作前面，加StoreStore屏障，禁止上面的普通写和他重排；每个volatile写操作后面，加StoreLoad屏障，禁止跟下面的volatile读/写重排。每个volatile读操作后面，加LoadLoad屏障，禁止下面的普通读和voaltile读重排；每个volatile读操作后面，加LoadStore屏障，禁止下面的普通写和volatile读重排。</p></blockquote><h2 id="synchronized为什么又叫内置锁？">synchronized为什么又叫内置锁？</h2><p>synchronized是内置于JDK中的，底层实现是native，由C/C++语言实现；同时，加锁、解锁都是JDK自动完成，不需要用户显示控制，非常方便。</p><h3 id="❗说说synchronized关键字的底层原理">❗说说synchronized关键字的底层原理</h3><p><strong>因为synchronized可以同时保证原子性、可见性和有序性，所以在并发编程中经常会用到他，synchronized主要有三种用法</strong>：修饰实例方法、修饰静态方法、修饰代码块。</p><p>synchronized 修饰代码块时，JVM 采用monitorenter 、monitorexit 两个指令来实现同步，monitorenter 指令指向同步代码块的开始位置， monitorexit 指令则指向同步代码块的结束位置。</p><p>synchronized 修饰同步方法时，JVM 采用ACC_SYNCHRONIZED 标记符来实现同步，这个标了该方法是一个同步方法。</p><p>❗大白话（修饰代码块）：每个对象实例都会关联一个monitor，一个类的class对象也会关联一个monitor。一个线程过来，把monitor置1（可以重复加锁，二次加monitor变成2、3…）。当线程走出synchronized，执行monitorexit，底层获取对应的monitor进行释放。线程2加锁失败，陷入一个阻塞等待的状态。</p><h4 id="Syncrhronized怎么保证可见性？">Syncrhronized怎么保证可见性？</h4><p>JMM中使用happens-before语义：</p><ul class="lvl-0"><li class="lvl-2"><p>线程解锁前，必须把共享变量的最新值刷新到主内存中。</p></li><li class="lvl-2"><p>线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新获取最新的值。（注意：加锁与解锁需要是同一把锁）</p></li></ul><h4 id="Synchronized怎么保证原子性？">Synchronized怎么保证原子性？</h4><h5 id="为什么会有两个monitorexit呢？">为什么会有两个monitorexit呢？</h5><p>这个主要是防止在同步代码块中线程因异常退出，而锁没有得到释放，这必然会造成死锁（等待的线程永远获取不到锁）。因此最后一个monitorexit是保证在异常情况下，锁也可以得到释放，避免死锁，它由编译器自动产生的一个异常处理器来执行。</p><h5 id="synchronized可重入的原理">synchronized可重入的原理</h5><p>重入锁是指一个线程获取到该锁之后，该线程可以继续获得该锁，且不再被阻塞。底层原理维护一个计数器，当线程获取该锁时，计数器加一，再次获得该锁时继续加一，释放锁时，计数器减一，当计数器值为0时，表明该锁未被任何线程所持有，其它线程可以竞争获取锁。</p><h3 id="Synchronized怎么保证有序性？">Synchronized怎么保证有序性？</h3><p>首先，Synchronized保证有序性，但不表示他能禁止指令重排。</p><p>而之所以会有序性问题，是因为硬件层面做了很多优化，比如处理器做强化和指令重排等，这些技术引入会导致有序性问题。这有序性问题主要出在多线程中，因为单线程中是遵循JMM的as-if-serial语义的，能保证数据间的依赖关系的，比如A依赖于B，B依赖于C，那A的实现之前，必须会先执行C。as-if-serial语义的意思是：不管怎么重排序，单线程程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。</p><p>但是多线程就可能因为指令重排导致在另一个线程中先执行到了C，多线程程序的语义就被重排序破坏了！Synchronized同步代码块可以锁住当前线程，这样每个线程单独执行，就可以保证有序性了。</p><h3 id="Synchronized和监视器（monitor）有什么关系？为什么Synchronized可以使用任意对象？">Synchronized和监视器（monitor）有什么关系？为什么Synchronized可以使用任意对象？</h3><p>首先，每个对象都可以被认为是一个“监视器monitor”，这个监视器由三部分组成：<strong>独占锁、入口队列，等待队列</strong>。</p><p>注意：一个对象只能有一个独占锁，但是任意线程都可以拥有这个独占锁（说白了，锁占锁就是一个标记）。</p><p>Synchronized需要获取对象锁，实际上就是获取的是对象中的独占锁，通过这个标记来判断是否已有线程进入占用（所以synchronized无论使用什么对象都可以，每个对象在堆中都有独占锁）。</p><p>而入口队列中放的则是要竞争锁资源的其他线程，如果线程使用了wait方法，则进入对象的等待列队中。</p><h3 id="Synchronized中的锁中什么是重量锁（对象锁），自旋锁，自适应自旋锁，轻量锁，偏向锁，锁消除，锁粗化？">Synchronized中的锁中什么是重量锁（对象锁），自旋锁，自适应自旋锁，轻量锁，偏向锁，锁消除，锁粗化？</h3><p>线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。同时我们发现在许多应用上面，对象锁的锁状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的，所以引入自旋锁。</p><p>就是等待锁的线程并不进入阻塞状态，而是执行一个无意义的循环。在循环结束后查看锁是否已经被释放，若已经释放则直接进入执行状态。因为长时间无意义循环也会大量浪费系统资源，因此自旋锁适用于间隔时间短的加锁场景。</p><p><strong>自适应自旋锁：</strong></p><ul class="lvl-0"><li class="lvl-2"><p>自适应就意味着<strong>自旋的次数不再是固定</strong>的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。</p></li></ul><p><strong>偏向锁：</strong></p><ul class="lvl-0"><li class="lvl-2"><p>偏向于第一个获得它的线程。当线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程 ID，以后该线程在进入和退出同步块时不需要花进行CAS加锁和解锁操作。适用于只有1个线程的情况。无法代替重量锁。</p></li></ul><p><strong>轻量锁：</strong></p><ul class="lvl-0"><li class="lvl-2"><p>如果有第二线程过来竞争，则从偏向锁升级为轻量锁，线程尝试使用 CAS 将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败。适用于只有2个线程情况。无法代替重量锁。</p></li></ul><p><strong>重量锁：</strong></p><ul class="lvl-0"><li class="lvl-2"><p>当有3个及以上的线程竞争时，升级为重量锁，获得锁的执行，没获得锁的阻塞挂起，直到持有锁的线程执行完同步块唤醒它们。重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。</p></li></ul><p><strong>锁消除：</strong></p><ul class="lvl-0"><li class="lvl-2"><p>JVM检测到不可能存在共享数据竞争，这时JVM会对这些同步锁进行锁消除。比如一个方法中使用变量是属于自己方法中的，那么这个变量是只属于该线程自己的，其他线程抢不走，这时候这个方法中的变量就没必要加锁了。锁消除的依据是逃逸分析（底层判断该数据是否有被全局引用或者程序指向无法被访问到的地方等）的数据支持。</p></li></ul><p><strong>锁粗化：</strong></p><ul class="lvl-0"><li class="lvl-2"><p>锁粗化就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。如上面实例：vector每次add的时候都需要加锁操作，JVM检测到对同一个对象（vector）连续加锁、解锁操作，会合并一个更大范围的加锁、解锁操作，即加锁解锁操作会移到for循环之外。</p></li></ul><h4 id="多线程中-synchronized-锁升级的原理是什么？">多线程中 synchronized 锁升级的原理是什么？</h4><p>偏向所锁，轻量级锁都是乐观锁，重量级锁是悲观锁。</p><p>一个对象刚开始实例化的时候，没有任何线程来访问它的时候。它是可偏向的，意味着，它现在认为只可能有一个线程来访问它，所以当第一个线程来访问它的时候，它会偏向这个线程，此时，对象持有偏向锁。偏向第一个线程，这个线程在修改对象头成为偏向锁的时候使用CAS操作，并将对象头中的ThreadID改成自己的ID，之后再次访问这个对象时，只需要对比ID，不需要再使用CAS在进行操作。</p><p>一旦有第二个线程访问这个对象，因为偏向锁不会主动释放，所以第二个线程可以看到对象时偏向状态，这时表明在这个对象上已经存在竞争了，检查原来持有该对象锁的线程是否依然存活，如果挂了，则可以将对象变为无锁状态，然后重新偏向新的线程，如果原来的线程依然存活，则马上执行那个线程的操作栈，检查该对象的使用情况，如果仍然需要持有偏向锁，则偏向锁升级为轻量级锁，（偏向锁就是这个时候升级为轻量级锁的）。如果不存在使用了，则可以将对象回复成无锁状态，然后重新偏向。</p><p>轻量级锁认为竞争存在，但是竞争的程度很轻，一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。 但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。</p><p><strong>Synchronized锁只会自动升级，不会降级（ReentrantReadWriteLock读写锁可以降级）。</strong></p><h2 id="synchronized-和-volatile-的区别是什么？">synchronized 和 volatile 的区别是什么？</h2><p>synchronized 表示只有一个线程可以获取作用对象的锁，执行代码，阻塞其他线程。</p><p>volatile 表示变量在 CPU 的寄存器中是不确定的，必须从主存中读取。保证多线程环境下变量的可见性；禁止指令重排序。</p><p>区别：</p><ul class="lvl-0"><li class="lvl-2"><p>volatile 是变量修饰符；synchronized 可以修饰类、方法、变量。</p></li><li class="lvl-2"><p>volatile 仅能实现变量的修改可见性，不能保证原子性；而 synchronized 则可以保证变量的修改可见性和原子性。</p></li><li class="lvl-2"><p>volatile 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</p></li><li class="lvl-2"><p>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。</p></li></ul><h2 id="❗对CAS的理解及其底层实现原理">❗对CAS的理解及其底层实现原理</h2><p>CAS 叫做比较并交换，CAS 指令包含 3 个参数：新值，旧值，内存值（内存位置），线程会先获取内存值，然后复制到变量副本，生成旧值，旧值在一系列操作后生成新值。</p><p>若旧值=内存值，说明没有被其他线程抢先占有，则修改内存值为新值；</p><p>若旧值≠内存值，说明内存值已经被其他线程修改，则自旋获取新的内存值，然后重新操作。</p><p>大白话：比如说使用synchronized对于代码块进行加锁，这个时候多个线程的执行是串行的。比如一个累加的计数器，优化可以把int类型的累加字段改成<strong>AtomicInteger</strong>类型（<strong>原子类</strong>），方法改为incrementAndGet，此时不用synchronized也是线程安全的。这个原子类底层就是CAS（Compare and Set）。在线程执行incrementAndGet时，会先读取，再尝试设置：当一个线程成功执行CAS操作（就是对比旧值是否是原来的值），另一个就会失败，失败就会重新读取，再次设置。</p><h3 id="❗CAS会出现经典的ABA问题">❗CAS会出现经典的ABA问题</h3><p>原因：第一个线程刚获得A，第二个线程就抢走也获得A，然后改成B后又改成A，这时候第一个线程发现变量是A，就继续执行。但是这样会出现潜藏的问题，比如修改的是金额，存一笔和存两笔是两个概念。</p><p>解决：加入版本号解决。</p><h2 id="❗对JDK中的AQS的理解，AQS的实现原理">❗对JDK中的AQS的理解，AQS的实现原理</h2><p>多线程访问数据除了synchronized，CAS，ConcurrentHashMap，还有Lock。ReentrantLock的底层就是AQS（Abstract Queue Synchronizer）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); <span class="comment">// 默认使用非公平锁</span></span><br><span class="line"><span class="comment">// 传入参数true，就使用公平锁</span></span><br><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br><span class="line">lock.lock();</span><br><span class="line"></span><br><span class="line">look.unlock();</span><br></pre></td></tr></table></figure><p>大白话：AQS底层有个state，多个线程执行CAS更新state；还有一个变量记录加锁线程。AQS中会有一个等待队列的概念。当前一个线程释放了锁，会去唤醒等待队列中的队首元素。</p><p>非公平锁：在唤醒等待队列的过程中，如果有另一个线程抢占锁，是可以成功的。公平锁：在唤醒等待队列的过程中，如果需要抢占锁，需要加入到等待队列内，进行等待。</p><h3 id="ReetrantReadWriteLock读写锁和RenntrantLock有什么区别？">ReetrantReadWriteLock读写锁和RenntrantLock有什么区别？</h3><p>ReentrantLock有一定的局限性，它的读锁与读锁间也会互斥，但读数据并不会改动数据，没有必要加锁保护，这就降低了程序的性能。</p><p>因以上问题，诞生了读写锁，读写锁一种读写分离技术，它的读锁是共享的，写锁是独占的，也就是说，多个线程是可以一起读数据的，只有写数据的时候，才会同步线程。</p><h3 id="读写锁ReentrantReadWriteLock有什么特点？">读写锁ReentrantReadWriteLock有什么特点？</h3><ol><li class="lvl-3"><p>公平性可以选择：支持非公平(默认)和公平的锁获取，吞吐量非公平优于公平。</p></li><li class="lvl-3"><p>重进入：读锁和写锁都支持线程重进入。</p></li><li class="lvl-3"><p>锁降级：获取写锁，再获取读锁，然后释放写锁，这样写锁就降级为了读锁。（注：Synchronized是不能进行锁降级的，意义不一样）。</p></li></ol><h2 id="ReentrantLock与Synchronized的区别。">ReentrantLock与Synchronized的区别。</h2><ul class="lvl-0"><li class="lvl-2"><p>二者的本质区别：synchronized 是关键字，ReentrantLock 是一个类 相同点：这两个都是可重入锁。</p></li><li class="lvl-2"><p>ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁</p></li><li class="lvl-2"><p>ReentrantLock 只适用于代码块锁，而 synchronized 可以修饰类、方法、变量等。</p></li></ul><h2 id="什么是死锁？">什么是死锁？</h2><p>A需要B解锁，B需要A解锁，两个都在中间互相等待，却谁也无法满足条件，从而发生阻塞，就是死锁。</p><p><strong>怎么防止死锁？</strong></p><ol><li class="lvl-3"><p>不要写嵌套锁，容易死锁；</p></li><li class="lvl-3"><p>尽量少用同步代码块(Synchronized);</p></li><li class="lvl-3"><p>尽量使用ReentrantLock的tryLock方法设置超时时间，超时可以退出，防止死锁；</p></li><li class="lvl-3"><p>尽量降低锁粒度，尽量不要几个功能一把锁；</p></li><li class="lvl-3"><p>尽量使用JUC包；</p></li></ol><h2 id="❗ConcurrentHashMap实现线程安全的底层原理">❗ConcurrentHashMap实现线程安全的底层原理</h2><p>JDK1.8以前，多个数组，分段加锁，一个数组一个锁。他将一个大的 ConcurrentHashMap分成16个小的 Segment。也就是说可以同时承受16个线程的并发。<br>JDK1.8以后，数组里每个元素进行put操作，都是有一个不同的锁，对当个位置进行put操作时，采取的是CAS的策略。如果CAS操作失败，就使用synchronized对这个位置的对象进行锁定，然后基于链表或红黑树，对数组元素进行写入。</p><h1>多线程</h1><h2 id="❗创建线程的4种方法">❗创建线程的4种方法</h2><ol><li class="lvl-3"><p>继承 Thread 类通过继承 Thread 类，并重写它的 run 方法，我们就可以创建一个线程。</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p>首先定义一个类来继承 Thread 类，重写 run 方法。</p></li><li class="lvl-2"><p>然后创建这个子类对象，并调用 start 方法启动线程。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">5</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**  </span></span><br><span class="line"><span class="comment">     * 重写父类中的run()， 执行具体的业务逻辑  </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">        count--;  </span><br><span class="line">        System.out.println(count);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="comment">//1. 创建线程对象的实例， 该对象必须继承Thread类及重写了run()  </span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">my</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//2. 创建多个线程的实例， 进入线程的初始化状态  </span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(my);  </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(my);  </span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(my);  </span><br><span class="line">  </span><br><span class="line">      <span class="comment">/*3. 启动线程， 线程只有执行start()之后才算是真正的启动, 才会执行run()方法里面的具体逻辑  </span></span><br><span class="line"><span class="comment">         线程启动后会进入线程的就绪状态，等待CPU的调用*/</span>  </span><br><span class="line">        t1.start();  </span><br><span class="line">        t2.start();  </span><br><span class="line">        t3.start();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li class="lvl-3"><p>实现 Runnable 接口通过实现 Runnable ，并实现 run 方法，也可以创建一个线程。</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p>首先定义一个类实现 Runnable 接口，并实现 run 方法。</p></li><li class="lvl-2"><p>然后创建 Runnable 实现类对象，并把它作为 target 传入 Thread 的构造函数中</p></li><li class="lvl-2"><p>最后调用 start 方法启动线程。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunnableThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;thread run ......&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">RunnableThread</span>()).run();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li class="lvl-3"><p>实现 Callable 接口，并结合 Future 实现</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p>首先定义一个 Callable 的实现类，并实现 call 方法。call 方法是带返回值的。</p></li><li class="lvl-2"><p>然后通过 FutureTask 的构造方法，把这个 Callable 实现类传进去。</p></li><li class="lvl-2"><p>把 FutureTask 作为 Thread 类的 target ，创建 Thread 线程对象。</p></li><li class="lvl-2"><p>通过 FutureTask 的 get 方法获取线程的执行结果。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFuture</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123; </span><br><span class="line">        <span class="type">FutureTask</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">CallableThread</span>());  </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();  </span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> futureTask.get();  </span><br><span class="line">        System.out.println(o);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CallableThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span> &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;call一下&quot;</span>);  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li class="lvl-3"><p>通过线程池创建线程此处用 JDK 自带的 Executors 来创建线程池对象。</p></li></ol><ul class="lvl-0"><li class="lvl-2"><p>首先，定一个 Runnable 的实现类，重写 run 方法。</p></li><li class="lvl-2"><p>然后创建一个拥有固定线程数的线程池。</p></li><li class="lvl-2"><p>最后通过 ExecutorService 对象的 execute 方法传入线程对象。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ExecutorThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">        System.out.println(<span class="string">&quot;run一下&quot;</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);  </span><br><span class="line">        executorService.execute(<span class="keyword">new</span> <span class="title class_">ExecutorThread</span>());  </span><br><span class="line">        executorService.shutdown();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="说一下-runnable-和-callable-有什么区别？">说一下 runnable 和 callable 有什么区别？</h3><p>相同点：</p><ol><li class="lvl-3"><p>都是接口</p></li><li class="lvl-3"><p>都可以编写多线程程序</p></li><li class="lvl-3"><p>都采用Thread.start()启动线程</p></li></ol><p>主要区别：</p><ol><li class="lvl-3"><p>Runnable 接口 run 方法无返回值；Callable 接口 call 方法有返回值，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。</p></li><li class="lvl-3"><p>Runnable 接口 run 方法只能抛出运行时异常，且无法捕获处理；Callable 接口 call 方法允许抛出异常，可以获取异常信息。</p></li></ol><p><strong>注：Callalbe接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。</strong></p><h3 id="线程的-run-和-start-有什么区别？">线程的 run()和 start()有什么区别？</h3><p>每个线程都是通过某个特定Thread对象所对应的方法run()来完成其操作的，run()方法称为线程体。通过调用Thread类的start()方法来启动一个线程。</p><p>start() 方法用于启动线程，run() 方法用于执行线程的运行时代码。run() 可以重复调用，而 start() 只能调用一次。</p><p>start()方法来启动一个线程，真正实现了多线程运行。调用start()方法无需等待run方法体代码执行完毕，可以直接继续执行其他的代码； 此时线程是处于就绪状态，并没有运行。 然后通过此Thread类调用方法run()来完成其运行状态， run()方法运行结束， 此线程终止。然后CPU再调度其它线程。</p><p>run()方法是在本线程里的，只是线程里的一个函数，而不是多线程的。 如果直接调用run()，其实就相当于是调用了一个普通函数而已，直接待用run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本就没有线程的特征，所以在多线程执行时要使用start()方法而不是run()方法。</p><h3 id="为什么我们调用-start-方法时会执行-run-方法，为什么我们不能直接调用-run-方法？">为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</h3><p>new 一个 Thread，线程进入了新建状态。调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。</p><p>而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p><p>总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。</p><h4 id="start-方法为什么能开启多线程？">start()方法为什么能开启多线程？</h4><p>真正实现开启多线程的是start() 方法中的 start0() 方法。</p><p>调用start0()方法后，该线程并不一定会立马执行，只是将线程变成了可运行状态（NEW —&gt; RUNNABLE）；具体什么时候执行，取决于 CPU ，由 CPU 统一调度；我们又知道 Java 是跨平台的，可以在不同系统上运行，每个系统的 CPU 调度算法不一样，所以就需要做不同的处理，这件事情就只能交给 JVM 来实现了，start0() 方法自然就表标记成了 native。</p><h2 id="如何避免线程死锁">如何避免线程死锁</h2><p>我们只要破坏产生死锁的四个条件中的其中一个就可以了。</p><p><strong>破坏互斥条件</strong></p><ul class="lvl-0"><li class="lvl-2"><p>这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。</p></li></ul><p><strong>破坏请求与保持条件</strong></p><ul class="lvl-0"><li class="lvl-2"><p>一次性申请所有的资源。</p></li></ul><p><strong>破坏不剥夺条件</strong></p><ul class="lvl-0"><li class="lvl-2"><p>占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p></li></ul><p><strong>破坏循环等待条件</strong></p><ul class="lvl-0"><li class="lvl-2"><p>靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p></li></ul><h2 id="线程的6种状态是什么？">线程的6种状态是什么？</h2><ol><li class="lvl-3"><p>新建状态（new）：创建线程对象。</p></li><li class="lvl-3"><p>就绪状态（runnable）：start方法。</p></li><li class="lvl-3"><p>阻塞状态（blocked）：无法获得锁对象（线程没抢到）。</p></li><li class="lvl-3"><p>等待状态（waiting）：wait方法。</p></li><li class="lvl-3"><p>计时状态（timed_waiting）：sleep方法。</p></li><li class="lvl-3"><p>死亡状态（terminated）：全部代码运行完毕。</p></li></ol><h2 id="线程的调度模式是什么？">线程的调度模式是什么？</h2><p>分时调度：轮流获取CPU使用权。</p><p>抢占式调度：优先级高的线程占用CPU。</p><h2 id="请说出与线程同步以及线程调度相关的方法。">请说出与线程同步以及线程调度相关的方法。</h2><ol><li class="lvl-3"><p>wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁；</p></li><li class="lvl-3"><p>sleep()：使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要处理 InterruptedException 异常；</p></li><li class="lvl-3"><p>notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由 JVM 确定唤醒哪个线程，而且与优先级无关；</p></li><li class="lvl-3"><p>notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态；</p></li></ol><h2 id="sleep-和-wait-有什么区别？">sleep() 和 wait() 有什么区别？</h2><p>相同点：两者都可以暂停线程的执行。</p><p>不同点：</p><ul class="lvl-0"><li class="lvl-2"><p>sleep方法，不会释放资源（本质是占用线程），如果占具锁资源，则其他线程不可进；wait方法会释放锁资源，即其他线程可进来。</p></li><li class="lvl-2"><p>wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用wait(long timeout)超时后线程会自动苏醒。</p></li></ul><h2 id="Java-中你怎样唤醒一个阻塞的线程？">Java 中你怎样唤醒一个阻塞的线程？</h2><p>首先 ，wait()、notify() 方法是针对对象的，调用任意对象的 wait()方法都将导致线程阻塞，阻塞的同时也将释放该对象的锁，相应地，调用任意对象的 notify()方法则将随机解除该对象阻塞的线程，但它需要重新获取该对象的锁，直到获取成功才能往下执行；</p><p>其次，wait、notify 方法必须在 synchronized 块或方法中被调用，并且要保证同步块或方法的锁对象与调用 wait、notify 方法的对象是同一个，如此一来在调用 wait 之前当前线程就已经成功获取某对象的锁，执行 wait 阻塞后当前线程就将之前获取的对象锁释放。</p><h2 id="notify-和-notifyAll-有什么区别？">notify() 和 notifyAll() 有什么区别？</h2><p>如果线程调用了对象的 wait()方法，那么线程便会处于该对象的等待池中，等待池中的线程不会去竞争该对象的锁。</p><p>notifyAll() 会唤醒所有的线程，notify() 只会唤醒一个线程。</p><p>notifyAll() 调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而 notify()只会唤醒一个线程，具体唤醒哪一个线程由虚拟机控制。</p><h2 id="为什么-wait-notify-和-notifyAll-必须在同步方法或者同步块中被调用？">为什么 wait(), notify()和 notifyAll()必须在同步方法或者同步块中被调用？</h2><p>这是 JDK 强制的，wait()方法和 notify()/notifyAll()方法在调用前都必须先获得对象的锁，也就是synchronized对象锁。</p><h2 id="Java-线程数过多会造成什么异常？">Java 线程数过多会造成什么异常？</h2><ol><li class="lvl-3"><p>线程的生命周期开销非常高</p></li><li class="lvl-3"><p>消耗过多的 CPU资源如果可运行的线程数量多于可用处理器的数量，那么有线程将会被闲置。大量空闲的线程会占用许多内存，给垃圾回收器带来压力，而且大量的线程在竞争 CPU资源时还将产生其他性能的开销。</p></li><li class="lvl-3"><p>降低稳定性.JVM在可创建线程的数量上存在一个限制，这个限制值将随着平台的不同而不同，并且承受着多个因素制约，包括 JVM 的启动参数、Thread 构造函数中请求栈的大小，以及底层操作系统对线程的限制等。如果破坏了这些限制，那么可能抛出OutOfMemoryError 异常。</p></li></ol><h2 id="ThreadLocal">ThreadLocal</h2><p>Threadlocal是一个线程内部的存储类，提供了线程内存储变量的能力,可以在指定线程内存储数据，数据存储以后，只有指定线程可以得到存储数据。这些变量不同之处在于每一个线程读取的变量是对应的互相独立的。</p><p>其内部维护了一个ThreadLocalMap，该Map用于存储每一个线程的变量副本。并且key为线程对象，value为对应线程的变量副本。</p><h1>线程池</h1><h2 id="Executors类有哪几种常见的线程池？">Executors类有哪几种常见的线程池？</h2><p>4种：单例线程池、固定大小线程池、可缓存线程池、大小无限线程池。</p><p>（1）newSingleThreadExecutor：创建一个单例线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p><p>（2）newFixedThreadPool：创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。如果希望在服务器上使用线程池，建议使用 newFixedThreadPool方法来创建线程池，这样能获得更好的性能。</p><p>（3） newCachedThreadPool：创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60 秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 JVM）能够创建的最大线程大小。</p><p>（4）newScheduledThreadPool：创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</p><h2 id="❗说说线程池的底层工作原理">❗说说线程池的底层工作原理</h2><p>避免频繁的创建线程，销毁线程……</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>) <span class="comment">// corePoolSize</span></span><br></pre></td></tr></table></figure><p>如果线程池内数量小于corePoolSize，就会创建一个线程执行任务。线程池一般会带一个队列，当线程执行任务完成，会等待阻塞在队列上（队首），尝试从队列继续获取任务。如果任务多于corePoolSize，会进入阻塞队列。如果阻塞队列满了，可以根据maximumPoolSize创建额外的线程。额外线程的空闲时间根据keepAliveTime进行自行销毁。</p><p>如果额外的线程都创建完了，队列还是满的，还有新来的任务。会reject掉，有几种reject策略，可以传入RejectedExecutionHandler。</p><ol><li class="lvl-3"><p>AbortPolicy：抛异常</p></li><li class="lvl-3"><p>DiscardPolicy：扔掉</p></li><li class="lvl-3"><p>DiscardOldestPolicy：删除最旧的任务</p></li><li class="lvl-3"><p>CallerRunsPolicy</p></li><li class="lvl-3"><p>自定义</p></li></ol><p>（常用）FixedThreadPool的队列是LinkedBlockingQueue，无界阻塞队列，即队列长度无线大。corePoolSize与maximumPoolSize一样大。</p><h3 id="❗线程池的核心配置参数">❗线程池的核心配置参数</h3><p>代表线程池的类是ThreadPoolExecutor。corePoolSize（核心线程数），maximumPoolSize（线程池），keepAliveTime（多余的空闲线程在终止之前等待新任务的最长时间），workQueue（阻塞队列）。</p><p>七个核心参数：</p><ul class="lvl-0"><li class="lvl-2"><p>参数一：核心线程数（不能小于0）</p></li><li class="lvl-2"><p>参数二：最大线程数（&gt;=核心线程数）</p></li><li class="lvl-2"><p>参数三：临时线程最大存活时间（不能小于0）</p></li><li class="lvl-2"><p>参数四：时间单位（参数三的单位）</p></li><li class="lvl-2"><p>参数五：等待列队（不能为null）</p></li><li class="lvl-2"><p>参数六：创建线程工厂（不能为null，一般用默认线程工厂）</p></li><li class="lvl-2"><p>参数七：任务的拒绝策略（不能为null）</p></li></ul><h4 id="拒绝策略有哪些">拒绝策略有哪些</h4><ol><li class="lvl-3"><p>ThreadPoolExecutor.AbortPolicy：丢弃任务并抛出异常（默认）；</p></li><li class="lvl-3"><p>ThreadPoolExecutor.DiscardPolicy：丢弃任务，不抛异常（不推荐）；</p></li><li class="lvl-3"><p>ThreadPoolExecutor.DiscardOldestPolicy：丢弃等待最久的线程；</p></li><li class="lvl-3"><p>ThreadPoolExecutor.CallerRunsPolicy：调用执行自己的线程（main）运行run方法。</p></li></ol><h3 id="❗如果在线程池中使用无界阻塞队列会发生什么问题？">❗如果在线程池中使用无界阻塞队列会发生什么问题？</h3><blockquote><p>面试题：在远程服务异常的情况下，使用无界阻塞队列，是否会导致内存异常飙升？</p><p>调用超时，队列变得越来越大，会导致内存飙升，可能还会导致OOM</p></blockquote><h3 id="❗线程池队列满了之后，会发生什么事情">❗线程池队列满了之后，会发生什么事情</h3><p>无界队列，内存溢出。有界队列，但是如果maximumPoolSize数量很大，可以无限制创建线程，但是每个线程占用栈内存，可能会导致内存资源耗尽，或者线程太多，CPU负载太高。有界队列，maximumPoolSize数量固定，多余的任务会被拒绝。</p><p>建议：自定义一个reject策略，如果线程池无法执行更多任务，可以把任务信息持久化写入磁盘。等负载降低重新执行这些任务。</p><h3 id="❗如果线上机器突然宕机，线程池的阻塞队列中的请求怎么办？">❗如果线上机器突然宕机，线程池的阻塞队列中的请求怎么办？</h3><p>线程池内积压的任务丢失。解决：在提交任务前，在数据库内插入任务信息，并更新他的状态：已提交、未提交、已完成……。系统重启后把任务状态重新提交。</p>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
❗表示必掌握，❔表示基本不会问&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24.06.03 初始记录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24.06.04 AQS&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24.06.05 线程池&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24.06.06 高并发&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24.06.10 总结&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="八股文" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    
    <category term="面试" scheme="https://kiml.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="八股文" scheme="https://kiml.github.io/tags/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    <category term="多线程" scheme="https://kiml.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="线程池" scheme="https://kiml.github.io/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>面试-基础</title>
    <link href="https://kiml.github.io/2024/06/03/100000025/"/>
    <id>https://kiml.github.io/2024/06/03/100000025/</id>
    <published>2024-06-03T13:09:05.000Z</published>
    <updated>2024-06-04T06:03:53.754Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>❗表示必掌握，❔表示基本不会问</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24.06.03 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="❗Java的基本数据类型">❗Java的基本数据类型</h2><p>byte，short，int，long，float，double，char，boolean</p><h2 id="面向对象的三大特性">面向对象的三大特性</h2><p>继承、多态、封装</p><h2 id="JDK和JRE的区别">JDK和JRE的区别</h2><p>JRE：Java 运⾏时环境。它是运⾏已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，Java 命令和其他的⼀些基础构件。但是，它不能⽤于创建新程序。</p><p>JDK(Java Development Kit)：它是功能⻬全的 Java SDK。它拥有 JRE 所拥有的⼀切，还有编译器（javac）和⼯具（如 javadoc 和 jdb）。它能够创建和编译程序。</p><p><strong>简单来说，JDK 包含 JRE，JRE 包含 JVM。</strong></p><h2 id="Java支持多继承和多实现吗">Java支持多继承和多实现吗</h2><p>不支持多继承，支持多实现。</p><h2 id="构造函数和一般函数有什么区别">构造函数和一般函数有什么区别</h2><ol><li class="lvl-3"><p>定义格式不同</p></li><li class="lvl-3"><p>构造函数是在对象创建时，就被调用，用于初始化，而且初始化动作只执行一次。 一般函数，是对象创建后，需要调用才执行，可以被调用多次。</p></li></ol><h2 id="Java怎么创建对象">Java怎么创建对象</h2><ol><li class="lvl-3"><p>使用 new 关键字</p></li><li class="lvl-3"><p>使用newInstance方法</p></li></ol><blockquote><p>Java 反射中有一个 newInstance() 方法，可以创建对象，步骤如下：获取要创建的类的 Class 对象。如果只需要调用这个类的访问权限为 public 无参构造器，<strong>直接使用 Class 类的实例方法 newInstance()</strong>。获取 Class 对象的构造器对象，通过调用 Class 类的实例方法 getDeclaredConstractors() 来获取构造器对象的数组。(获取所有构造器，无视访问权限的限制，数组顺序按照代码中的顺序决定)如果调用的构造器是 private 的，需要调用 Constractor 类的父类 AccessibleObject 类的实例方法 setAccessible(true) 来打破访问限制。使用 Constractor 类的实例方法 newInstance()。获取 Class 对象的方法有3个，此处不多赘述。获取Constractor 对象的方法有4个，此处不多赘述。</p></blockquote><ol start="3"><li class="lvl-3"><p>使用clone()方法</p></li></ol><blockquote><p>Object 类是所有类的直接或间接父类，Object 类中提供了 实例方法 native()，在给定对象的基础上，创建一个完全相同的对象。步骤如下：想要使用 clone() 方法创建对象的类，实现 Cloneable 接口。在类的内部，重写 Object 类的 clone() 方法。备注：没有实现 Cloneable 接口，会抛出 CloneNotSupportedException 异常。Object 类提供的 clone() 方法，访问权限是 protected，所以如果不重写 clone() 方法，是没有权限调用的。Object 类的 clone() 方法，是 native 方法。</p></blockquote><ol start="4"><li class="lvl-3"><p>❔使用反序列化的readObject()方法</p></li></ol><blockquote><p>这个方法一共分两步：将对象序列化，存储到一个文件中。从文件中反序列化，得到类对象。</p><p>序列化：想要序列化对象的类，实现Serializable接口。使用文件输出流FileOutputStream创建存储序列化之后对象的文件。使用对象输出流ObjectOutputStream的实例方法writeObject(obj)。判断类中是否存在，名为writeReplace()，返回类型为Object的方法，若有，写入这个方法的返回值；否则，写入obj对象。</p><p>反序列化：使用文件输入流FileInputStream找到存储序列化对象的文件。使用对象输入流ObjectInputStream的实例方法readObject()。判断类中是否存在，名为readResolve()，返回类型为Object的方法，若有读取这个对象；否则，反序列化文件中的对象流。</p><p>备注：在类中，writeReplace()和readResoleve()是两个非常特殊的方法，其特征签名需要严格限制：方法名限定，参数个数限定为0，返回类型必须是Object，不能为Object的子类，但是可以抛出不同的异常。访问修饰符没有限制，但一般推荐为private，防止误操作。其特殊的地方还在于将其设为private方法，没有其他方法调用的情况下，编译器不会发出警告。</p></blockquote><h2 id="Java中的异常">Java中的异常</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Throwable -&gt;Exception -&gt; ClassNotFoundException</span><br><span class="line">  -&gt; IOException</span><br><span class="line">  -&gt; RuntimeException      -&gt; NullPointerException</span><br><span class="line">  -&gt; NumberFormatException</span><br><span class="line">  -&gt; IndexOutOfBoundsException</span><br><span class="line">  ......</span><br><span class="line">          -&gt;Error</span><br></pre></td></tr></table></figure><h2 id="❗抽象类和接口的区别">❗抽象类和接口的区别</h2><ol><li class="lvl-3"><p>定义：接口定义：interface；抽象类：abstrat class;</p></li><li class="lvl-3"><p>抽象类可以定义构造方法供子类调用，接口不可以；</p></li><li class="lvl-3"><p>接口的所有方法都是抽象方法，所有属性都是常量：static final 类型；而抽象类中可以有不是抽象的方法和不是常量的属性；</p></li><li class="lvl-3"><p>抽象类只能单继承，而接口之间可以多继承，接口之间的继承用extexds,类实现接口用implements.</p></li></ol><h2 id="和equals"><code>==</code>和<code>equals()</code></h2><p><code>==</code>：</p><ol><li class="lvl-3"><p>如果比较的对象是基本数据类型，则比较的是其存储的值是否相等；</p></li><li class="lvl-3"><p>如果比较的是引用数据类型，则比较的是所指向对象的地址值是否相等（是否是同一个对象）。<code>equals</code>：</p></li><li class="lvl-3"><p>如果没有对 equals 方法进行重写，则相当于<code>==</code>，比较的是引用类型的变量所指向的对象的地址值。</p></li><li class="lvl-3"><p>一般情况下，类会重写equals方法用来比较两个对象的内容是否相等。比如String类中的equals()是被重写了，比较的是对象的值。</p></li></ol><h2 id="为什么重写equals方法，还必须要重写hashcode方法">为什么重写equals方法，还必须要重写hashcode方法</h2><ol><li class="lvl-3"><p>保证是同一个对象，如果重写了equals方法，而没有重写hashcode方法，会出现equals相等的对象，hashcode不相等的情况，重写hashcode方法就是为了避免这种情况的出现。</p></li><li class="lvl-3"><p>使用hashcode方法提前校验，可以避免每一次比对都调用equals方法，提高效率</p></li></ol><p>重写后：</p><ol><li class="lvl-3"><p>equals()相等的两个对象，hashcode()一定相等；</p></li><li class="lvl-3"><p>hashcode()不等，一定能推出equals()也不等；</p></li><li class="lvl-3"><p>hashcode()相等，equals()可能相等，也可能不等。</p></li><li class="lvl-3"><p>所以先进行hashcode（）判断，不等就不用equals（）方法了。</p></li><li class="lvl-3"><p>但equels是是根据对象的特征进行重写的，有时候特征相同，但hash值不同，也不是一个对象。 所以两个都重写才能保障是同一个对象。</p></li></ol>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
❗表示必掌握，❔表示基本不会问&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24.06.03 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="八股文" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    
    <category term="面试" scheme="https://kiml.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="八股文" scheme="https://kiml.github.io/tags/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第十三天-层序遍历、226翻转二叉树、101对称二叉树</title>
    <link href="https://kiml.github.io/2024/06/03/100000038/"/>
    <id>https://kiml.github.io/2024/06/03/100000038/</id>
    <published>2024-06-03T02:22:57.000Z</published>
    <updated>2024-06-09T14:08:05.871Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>状态：层序遍历直接看解析。226、101看了部分解析。可以完成递归法。</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24.06.03 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h1>初步题解</h1><h2 id="102二叉树的层序遍历">102二叉树的层序遍历</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/" >https://leetcode.cn/problems/binary-tree-level-order-traversal/description/<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    ArrayList&lt;List&lt;Integer&gt;&gt; resultList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    levelOrderDFS(root, <span class="number">0</span>, resultList);  </span><br><span class="line">    levelOrderBFS(root, resultList);  </span><br><span class="line">    <span class="keyword">return</span> resultList;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 迭代法实现层序遍历（广度优先）  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resultList 返回的list  </span></span><br><span class="line"><span class="comment"> */</span><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">levelOrderBFS</span><span class="params">(TreeNode root, ArrayList&lt;List&lt;Integer&gt;&gt; resultList)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();  </span><br><span class="line">    queue.offer(root);  </span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;  </span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 遍历当前层所有节点  </span></span><br><span class="line">        <span class="keyword">while</span> (size &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();  </span><br><span class="line">            list.add(node.val);  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 把这层所有的左节点加入  </span></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;  </span><br><span class="line">                queue.offer(node.left);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">// 把这层所有的右节点加入  </span></span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;  </span><br><span class="line">                queue.offer(node.right);  </span><br><span class="line">            &#125;  </span><br><span class="line">            size--;  </span><br><span class="line">        &#125;  </span><br><span class="line">        resultList.add(list);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 递归方式实现层序遍历(深度优先)  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i 层数  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resultList 遍历结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">levelOrderDFS</span><span class="params">(TreeNode root, <span class="type">int</span> i, ArrayList&lt;List&lt;Integer&gt;&gt; resultList)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    i++;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 如果小于，说明第一次进这层，需要初始化这个位置的list  </span></span><br><span class="line">    <span class="keyword">if</span> (resultList.size() &lt; i) &#123;  </span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">        resultList.add(list);  </span><br><span class="line">    &#125;  </span><br><span class="line">    resultList.get(i - <span class="number">1</span>).add(root.val);  </span><br><span class="line">  </span><br><span class="line">    levelOrderDFS(root.left, i, resultList);  </span><br><span class="line">    levelOrderDFS(root.right, i, resultList);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="226翻转二叉树">226翻转二叉树</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/invert-binary-tree/description/" >https://leetcode.cn/problems/invert-binary-tree/description/<i class="fas fa-external-link-alt"></i></a>)</p><p>看了一部分的题目解析，突然反应过来tree不用自己构建，直接用方法简单很多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * DFS递归  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 翻转结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    invertTreePreorder(root);  </span><br><span class="line">    <span class="keyword">return</span> root;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">invertTreePreorder</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>();  </span><br><span class="line">    <span class="comment">// 指针交换  </span></span><br><span class="line">    temp = root.left;  </span><br><span class="line">    root.left = root.right;  </span><br><span class="line">    root.right = temp;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;  </span><br><span class="line">        invertTreePreorder(root.left);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;  </span><br><span class="line">        invertTreePreorder(root.right);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="101对称二叉树">101对称二叉树</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/symmetric-tree/description/" >https://leetcode.cn/problems/symmetric-tree/description/<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 这题和翻转放在一起  </span></span><br><span class="line"><span class="comment"> * 第一思路就是翻转之后比较是否相等(但是是指针引用，翻转之后是不能进行比较的)  </span></span><br><span class="line"><span class="comment"> * 看了部分讲解，说是把左子，右子拆分成两棵树来看.  </span></span><br><span class="line"><span class="comment"> * 可以拆分之后翻转一棵树，然后比较是否相等。  </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> root.right;  </span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> root.left;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 左子树翻转  </span></span><br><span class="line">    invertTreePreorder(left);  </span><br><span class="line">    <span class="keyword">return</span> isEqual(right, left);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isEqual</span><span class="params">(TreeNode right, TreeNode left)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (right == <span class="literal">null</span> &amp;&amp; left == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> ((right == <span class="literal">null</span> &amp;&amp; left != <span class="literal">null</span>) || (right != <span class="literal">null</span> &amp;&amp; left == <span class="literal">null</span>)) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (right.val != left.val) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> isEqual(right.right, left.right) &amp;&amp; isEqual(right.left, left.left);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invertTreePreorder</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    TreeNode temp;  </span><br><span class="line">    <span class="comment">// 指针交换  </span></span><br><span class="line">    temp = root.left;  </span><br><span class="line">    root.left = root.right;  </span><br><span class="line">    root.right = temp;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="literal">null</span>) &#123;  </span><br><span class="line">        invertTreePreorder(root.left);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="literal">null</span>) &#123;  </span><br><span class="line">        invertTreePreorder(root.right);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>看解析</h1><h2 id="102二叉树的层序遍历-2">102二叉树的层序遍历</h2><p>题目链接/文章讲解/视频讲解：(<a class="link"   href="https://programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html" >https://programmercarl.com/0102.二叉树的层序遍历.html<i class="fas fa-external-link-alt"></i></a>)</p><p>层序遍历一个二叉树。需要借用一个辅助数据结构即队列来实现，<strong>队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。</strong></p><p><strong>而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。</strong></p><h2 id="226翻转二叉树-2">226翻转二叉树</h2><p>题目链接/文章讲解/视频讲解：(<a class="link"   href="https://programmercarl.com/0226.%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91.html" >https://programmercarl.com/0226.翻转二叉树.html<i class="fas fa-external-link-alt"></i></a>)</p><p><strong>递归的中序遍历是不行的，因为使用递归的中序遍历，某些节点的左右孩子会翻转两次。</strong></p><h2 id="101对称二叉树-2">101对称二叉树</h2><p>题目链接/文章讲解/视频讲解：(<a class="link"   href="https://programmercarl.com/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.html" >https://programmercarl.com/0101.对称二叉树.html<i class="fas fa-external-link-alt"></i></a>)</p><p>本题遍历只能是“后序遍历”，因为我们要通过递归函数的返回值来判断两个子树的内侧节点和外侧节点是否相等。<br><strong>正是因为要遍历两棵树而且要比较内侧和外侧节点，所以准确的来说是一个树的遍历顺序是左右中，一个树的遍历顺序是右左中。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**   </span></span><br><span class="line"><span class="comment"> * 看完解析后的思路，不用翻转直接比较是否相等  </span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> root.right;  </span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> root.left;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> compare(right, left);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(TreeNode right, TreeNode left)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (right == <span class="literal">null</span> &amp;&amp; left == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> ((right == <span class="literal">null</span> &amp;&amp; left != <span class="literal">null</span>) || (right != <span class="literal">null</span> &amp;&amp; left == <span class="literal">null</span>)) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span> (right.val != left.val) &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> compare(right.right, left.left) &amp;&amp; compare(right.left, left.right);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代法</span></span><br><span class="line"><span class="comment">     * 使用双端队列，相当于两个栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric2</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        deque.offerFirst(root.left);</span><br><span class="line">        deque.offerLast(root.right);</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> deque.pollFirst();</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> deque.pollLast();</span><br><span class="line">            <span class="keyword">if</span> (leftNode == <span class="literal">null</span> &amp;&amp; rightNode == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            if (leftNode == null &amp;&amp; rightNode != null) &#123;</span></span><br><span class="line"><span class="comment">//                return false;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            if (leftNode != null &amp;&amp; rightNode == null) &#123;</span></span><br><span class="line"><span class="comment">//                return false;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            if (leftNode.val != rightNode.val) &#123;</span></span><br><span class="line"><span class="comment">//                return false;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">            <span class="comment">// 以上三个判断条件合并</span></span><br><span class="line">            <span class="keyword">if</span> (leftNode == <span class="literal">null</span> || rightNode == <span class="literal">null</span> || leftNode.val != rightNode.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            deque.offerFirst(leftNode.left);</span><br><span class="line">            deque.offerFirst(leftNode.right);</span><br><span class="line">            deque.offerLast(rightNode.right);</span><br><span class="line">            deque.offerLast(rightNode.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迭代法</span></span><br><span class="line"><span class="comment">     * 使用普通队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric3</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        deque.offer(root.left);</span><br><span class="line">        deque.offer(root.right);</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> deque.poll();</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> deque.poll();</span><br><span class="line">            <span class="keyword">if</span> (leftNode == <span class="literal">null</span> &amp;&amp; rightNode == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            if (leftNode == null &amp;&amp; rightNode != null) &#123;</span></span><br><span class="line"><span class="comment">//                return false;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            if (leftNode != null &amp;&amp; rightNode == null) &#123;</span></span><br><span class="line"><span class="comment">//                return false;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            if (leftNode.val != rightNode.val) &#123;</span></span><br><span class="line"><span class="comment">//                return false;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">            <span class="comment">// 以上三个判断条件合并</span></span><br><span class="line">            <span class="keyword">if</span> (leftNode == <span class="literal">null</span> || rightNode == <span class="literal">null</span> || leftNode.val != rightNode.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这里顺序与使用Deque不同</span></span><br><span class="line">            deque.offer(leftNode.left);</span><br><span class="line">            deque.offer(rightNode.right);</span><br><span class="line">            deque.offer(leftNode.right);</span><br><span class="line">            deque.offer(rightNode.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
状态：层序遍历直接看解析。226、101看了部分解析。可以完成递归法。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24.06.03 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="二叉树" scheme="https://kiml.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>面试-总览</title>
    <link href="https://kiml.github.io/2024/06/02/100000021/"/>
    <id>https://kiml.github.io/2024/06/02/100000021/</id>
    <published>2024-06-02T13:59:58.000Z</published>
    <updated>2024-06-02T14:30:11.967Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>这个部分作为一个背题打卡List。展示面试前必须掌握的东西。</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24.06.02 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h1>集合HashMap</h1><ul class="lvl-0"><li class="lvl-2"><p><input type="checkbox" id="checkbox0"><label for="checkbox0">put的过程</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox1"><label for="checkbox1">头插法和尾插法的区别</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox2"><label for="checkbox2">1.7和1.8的扩容机制(先扩容在添加调整为先添加在扩容)</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox3"><label for="checkbox3">链表和红黑树的转化过程</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox4"><label for="checkbox4">线程不安全的问题(解决方案)</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox5"><label for="checkbox5">ConcurrentHashMap的1.7和1.8原理和区别</label></p></li></ul><h1>ArrayList</h1><ul class="lvl-0"><li class="lvl-2"><p><input type="checkbox" id="checkbox6"><label for="checkbox6">什么是双向链表</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox7"><label for="checkbox7">底层原理</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox8"><label for="checkbox8">和LinkedList的区别</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox9"><label for="checkbox9">线程不安全如何解决</label></p></li></ul><h1>多线程</h1><ul class="lvl-0"><li class="lvl-2"><p><input type="checkbox" id="checkbox10"><label for="checkbox10">实现方式，每种实现方式的区别</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox11"><label for="checkbox11">Volatile关键字</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox12"><label for="checkbox12">CAS自旋锁</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox13"><label for="checkbox13">Lock锁是公平锁还是非公平锁</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox14"><label for="checkbox14">你了解AQS机制它的核心原理是什么</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox15"><label for="checkbox15">公平锁，非公平锁，偏向锁，轻量锁</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox16"><label for="checkbox16">线程的6种状态</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox17"><label for="checkbox17">线程池的7大核心参数</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox18"><label for="checkbox18">4个拒绝策略</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox19"><label for="checkbox19">多线程的执行流程</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox20"><label for="checkbox20">线程池的常用实现方法</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox21"><label for="checkbox21">ThreadLocal的原理</label></p></li></ul><h1>JVM</h1><ul class="lvl-0"><li class="lvl-2"><p><input type="checkbox" id="checkbox22"><label for="checkbox22">说一下 JVM 的主要组成部分及其作用</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox23"><label for="checkbox23">说一下 JVM 运行时数据区</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox24"><label for="checkbox24">堆里面的分区：Eden，survival （from+ to），老年代，各自的特点是什么</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox25"><label for="checkbox25">说一下 JVM 调优的工具</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox26"><label for="checkbox26">常用的 JVM 调优的参数都有哪些</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox27"><label for="checkbox27">简述Java垃圾回收机制</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox28"><label for="checkbox28">什么是Full GC</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox29"><label for="checkbox29">什么情况下会触发</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox30"><label for="checkbox30">说一下 JVM 有哪些垃圾回收算法</label></p></li></ul><h1>数据库</h1><ul class="lvl-0"><li class="lvl-2"><p><input type="checkbox" id="checkbox31"><label for="checkbox31">索引的机制和底层原理</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox32"><label for="checkbox32">什么是组合索引</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox33"><label for="checkbox33">最左匹配原则</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox34"><label for="checkbox34">数据库的事务</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox35"><label for="checkbox35">引擎的原理</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox36"><label for="checkbox36">数据库悲观锁和乐观锁的实现</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox37"><label for="checkbox37">b+树的好处</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox38"><label for="checkbox38">数据库的优化</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox39"><label for="checkbox39">多个数据源如何操作</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox40"><label for="checkbox40">数据库的优化</label></p></li></ul><h1>框架</h1><ul class="lvl-0"><li class="lvl-2"><p><input type="checkbox" id="checkbox41"><label for="checkbox41">Spring的事务传播机制</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox42"><label for="checkbox42">bean 的生命周期</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox43"><label for="checkbox43">SpringMVC的执行流程</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox44"><label for="checkbox44">ioc</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox45"><label for="checkbox45">di</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox46"><label for="checkbox46">aop</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox47"><label for="checkbox47">SpringBoot异常处理机制</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox48"><label for="checkbox48">简化操作的原理</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox49"><label for="checkbox49">自定义注解</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox50"><label for="checkbox50">Springcloud的组件</label></p></li></ul><h1>Redis</h1><ul class="lvl-0"><li class="lvl-2"><p><input type="checkbox" id="checkbox51"><label for="checkbox51">Redis的数据类型</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox52"><label for="checkbox52">常用命令</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox53"><label for="checkbox53">持久化方法</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox54"><label for="checkbox54">雪崩、击穿、穿透</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox55"><label for="checkbox55">过期策略</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox56"><label for="checkbox56">淘汰策略</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox57"><label for="checkbox57">与数据库的一致性</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox58"><label for="checkbox58">哨兵模式</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox59"><label for="checkbox59">集群</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox60"><label for="checkbox60">分布式锁</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox61"><label for="checkbox61">异步队列</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox62"><label for="checkbox62">延时队列</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox63"><label for="checkbox63">线程模型</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox64"><label for="checkbox64">分区</label></p></li></ul><h1>MQ</h1><ul class="lvl-0"><li class="lvl-2"><p><input type="checkbox" id="checkbox65"><label for="checkbox65">为什么要用MQ</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox66"><label for="checkbox66">MQ的优势</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox67"><label for="checkbox67">消息补偿机制</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox68"><label for="checkbox68">一致性</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox69"><label for="checkbox69">预防消息丢失</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox70"><label for="checkbox70">可靠性</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox71"><label for="checkbox71">不重复消费</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox72"><label for="checkbox72">集群镜像模式</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox73"><label for="checkbox73">MQ的工作模式</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox74"><label for="checkbox74">项目应用场景</label></p></li></ul><h1>场景</h1><ul class="lvl-0"><li class="lvl-2"><p><input type="checkbox" id="checkbox75"><label for="checkbox75">请求量大如何拦截</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox76"><label for="checkbox76">如何去两个库查数据</label></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
这个部分作为一个背题打卡List。展示面试前必须掌握的东西。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24.06.02 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="八股文" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    
  </entry>
  
  <entry>
    <title>面试-集合</title>
    <link href="https://kiml.github.io/2024/06/01/100000020/"/>
    <id>https://kiml.github.io/2024/06/01/100000020/</id>
    <published>2024-06-01T03:32:49.000Z</published>
    <updated>2024-06-03T13:14:41.547Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>集合常见问题，其中HashMap很重要❗表示必掌握，❔表示基本不会问</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24.06.01 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h1>Java集合</h1><p>集合分为单列集合(collection)和双列集合(map)。单列集合又包括List(可重复)和Set(不可重复)，List分为ArrayList和LinkedList，Set分为HashSet和TreeSet。双列集合Map分为TreeMap和HashMap。单列集合是实现Iterable接口产成的对象，支持迭代器和增强for。</p><h2 id="迭代器">迭代器</h2><h3 id="基础">基础</h3><p><strong>所有的单列集合都可以使用迭代器，因为他们都继承了Iterable接口</strong>，这个接口里的Iterator方法可以返回一个Iterator对象，这个Iterator对象就是迭代器对象，底层针对不同类型的集合都写了不同的实现类，所以集合可以直接使用迭代器进行遍历查询。这种只需要提供一种方法（iterator方法）访问一个容器对象中各个元素，而又不暴露该对象的内部细节的方式就是迭代器设计模式。</p><h3 id="迭代器倒序">迭代器倒序</h3><p>List集合可以使用迭代器倒着遍历，ListIterator有previous()方法和hasprevious()方法，可以自动指向并取出上一个元素。Set集合不能用迭代器倒着遍历，但可以根据它的大小顺序倒着取出。</p><h3 id="使用foreach、iterator、for在有什么区别？效率上哪个更高？">使用foreach、iterator、for在有什么区别？效率上哪个更高？</h3><p>区别上：普通for循环一般用来处理比较简单的有序的，可预知大小的集合或数组.<br>foreach可用于遍历任何集合或数组，而且操作简单易懂，唯一的不好就是需要了解集合内部类型，它的底层有函数式编程注解 @FunctionalInterface，也就是说它可以进行Lamda形式简写。<br>iterator是最强大的，他可以随时修改或者删除集合内部的元素，并且是在不需要知道元素和集合的类型的情况下进行的，当你需要对不同的容器实现同样的遍历方式时，迭代器是最好的选择！至于增强for和iterator其实是一样的，增强for编译后的.class文件中，就是iterator，所以二者除了写法是用第三方参数来表示，效率上没有任何区别。</p><p>效率上：这个需要多方考虑，比如普通for循环用在数组是遍历最快的，它是直接获取数据，但普通for不能用在不知道长度的集合中，这就需要用iterator或者foreach，相对来说，iterator效率会高于foreach，因为foreach在访问过程中产生一个额外的Enumerator对象，这个对象会进行版本检查处理，所以它是线安全的。对于ArrayList来说，它是通过一个数组实现的，可以随机存取；但是LinkedList是通过链表实现的，当要遍历依个取出时，for循环时要取的每个元素都必须从头开始遍历，而iterator遍历则从头开始，边遍历边取，取完只需要一次遍历，所以for循环需要的时间远远超过foreach循环。 对于数组来说，for和foreach循环效率差不多，但是对于链表来说，for循环效率明显比foreach低。</p><h2 id="ArrayList和LinkedList的底层原理">ArrayList和LinkedList的底层原理</h2><p>首先，List集合是有序集合，即存取有序，List集合的特点是存取顺序一致，存储元素可重复，都有索引。<br>ArrayList的底层是数组，一个索引对应一个元素，所以查询速度快；但是在增删时，需要调整整组数据的移动，所以增删较慢。而LinkedList的底层是双向链表，每次查询时都要从两头开始查询（离头近就从头查，离尾近就从尾查），所以查询较慢；但是增删时，只需要将链表头结点和尾结点指向新插入的结点即可，所以增删速度较快。但如果是新增的数据量较大的情况下，ArrayList的新增效率反面比LinkedList的效率更高。因为ArrayListr底层数组的扩容是1.5倍，数据量越大，扩容的速度就越快，而链表仍需一个个断开链接和重续新链接。最后，<strong>jdk8版还对ArrayList做了懒加载优化，在之前是构造ArrayList时就默认开辟10个空间，jdk8之后变成了只有放入第1个元素时，才会开辟10个空间。</strong><br>❗❗<strong>数组的起始长度是0，在向数组中添加第一个元素时，数组容量扩为10。</strong> 后续扩容因子为1.5倍。每次扩容都是复制到新的数组。</p><h2 id="分别讲一下Set集合和Tree这种数据结构">分别讲一下Set集合和Tree这种数据结构</h2><p>Set集合的特点是必须排序，没有索引，不可重复。Set集合分为HashSet和TreeSet，HashSet底层使用的是哈希表，它的排序规则是按照底Hash函数决定的，无法人为设置；而TreeSet的底层则是使用红黑树，可以使用自然排序（自定义类中实现Comparable接口，重写CompareTo方法）或比较器排序（在创建TreeSet对象创建一个Comparator的匿名内部类，并重写Compare方法），扩容时通过结点链接。<br> <br> ### TreeSet使用Iterator遍历的过程是怎么样的？<br> 因为TreeSet是按大小排序的，所以会根据从左往右，从下往上的顺序打印。<br> <br> ## List集合是线程不安全的，你是怎么使用List集合的呢？<br> 使用Collections集合工具类，对集合进行同步处理：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  List&lt;String&gt; list = Collections.synchronizedList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()); </span><br></pre></td></tr></table></figure><br>但是在多线程开发中，对其进行遍历，需要添加 synchronized 关键字，因为List的 add、index 等方法中都是带有synchronized 关键字，但是在 iterator 中没有synchronized 关键字。</p><h2 id="HashMap">HashMap</h2><h3 id="❗HashMap底层的数据结构">❗HashMap底层的数据结构</h3><p>数组 + 最简单的原理。对存入的key进行hash计算，根据计算出的hash值，对数组长度进行取模，获取到要存入的位置。<br><strong>JDK8以前，Hash表的底层是【数组】+【链表】<br>JDK8及之后，变成了【数组】+【链表】+【红黑树】</strong></p><h3 id="❗JDK-1-8-中对hash算法和寻址算法是如何优化的？">❗JDK 1.8 中对hash算法和寻址算法是如何优化的？</h3><p>hash算法：hash值与hash值右移16位进行异或计算。得到结果位高16位+高16位与低16位的异或值。（<strong>这一步主要为了低16位在下一步寻址的时候，使低16位保留高16位的特征，减少哈希冲突</strong>）寻址：<code>(n - 1)&amp;hash</code> 算出数组内的一个位置。</p><p>为什么使用&amp;运算不使用取模运算？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">取模运算性能比较差，而且(n - 1)&amp;hash的效果和hash对n取模，效果是一样的。</span><br><span class="line"></span><br><span class="line">为什么效果是一样的？</span><br><span class="line">因为数组的长度一直是2的n次方，只要他保持数组长度是2的n次方，那么效果就是一样的。</span><br></pre></td></tr></table></figure><h3 id="❗HashMap如何解决hash碰撞？">❗HashMap如何解决hash碰撞？</h3><p>hash冲突，链表+红黑树，O(n)和O(logn)</p><h3 id="❗HashMap如何进行扩容？">❗HashMap如何进行扩容？</h3><p>2倍扩容。扩容之后要进行rehash。即hash值与新数组长度<code>(n - 1)</code>进行与操作。如果值与原来不一样，新的index就是<code>旧index + oldCap</code>，通过这个方式，避免了rehash的时候，进行取模（效率不高）。</p><p>Hash表中数组的分手手动初始化，和自动初始化，自动初初始会在第一次插入元素时开辟空间，<strong>默认长度为16</strong>，扩容因子为0.75，<strong>每次扩容量为自身的2倍长度</strong>，扩容之后存入数组的新索引位置就会改变。手动初始化的话，可以在创建对象时自定义初始数组长度，但HashMap不一定会自主设置的数值初始化数组，而按2的n次方创建。</p><p>HashMap1.7版本的的扩容时机是先判断是否达到阈值，达到先扩容，再添加元素，并且采用的是头插法，也就是旧元素挂在新元素下。而HashMap1.8的扩容时机是先添加元素是否达到阈值，达到直接扩容，且使用的是尾插法，即新元素挂在旧元素下面。</p><p>初始化后，当存入新的键值对时，会先判断数组长度是否大于64，再判断链表元素是否大于等于8时，如果两者都成立，链表会自动转换成红黑树，如果数组小于64，会从第9个开始先扩容，直到数组大于等于64时，链表长度再增加，就会转为红黑树。</p><h4 id="❔为什么要转为红黑树呢？">❔为什么要转为红黑树呢？</h4><p>链表取一个数需要遍历链表，而红黑树相对效率要高。</p><h4 id="❔为什么不直接使用红黑树呢？">❔为什么不直接使用红黑树呢？</h4><p>HashMap源码中有相关描述： “因为树节点的大小是链表节点大小的两倍，所以只有在容器中包含足够的节点保证使用才用它”，显然尽管转为树使得查找的速度更快，但是在节点数比较小的时候，此时对于红黑树来说内存上的劣势会超过查找等操作的优势，自然使用链表更加好，但是在节点数比较多的时候，综合考虑，红黑树比链表要好。</p><h4 id="❔为什么转为红黑树的条件是8而不是第9第10个呢？">❔为什么转为红黑树的条件是8而不是第9第10个呢？</h4><p>源码中有对这个进行计算，正常的随机哈希码下，哈希冲突多到超过8个的概率不到千万分之一，几乎可以忽略不计了，再往后调整并没有很大意义。如果哈希冲突有那么多，说明极大可能是人为设置，故意制造哈希冲突导致，这时候就转为化红黑树，来保证查询效率。</p><h4 id="❔那什么时候退出红黑树呢？">❔那什么时候退出红黑树呢？</h4><p>当哈希冲突个数从第8个变到第6个时，红黑树转化为链表。</p><h4 id="❔6与8之间的第7个冲突时，会是什么状态？">❔6与8之间的第7个冲突时，会是什么状态？</h4><p>分情况看。8退6，是红黑树转链表，6进8，是链表转红黑树，中间的7是防止频繁变动做的一个预留位，如果是8退6，中间的7就是红黑树；如果是6进8，中间的7就是链表。</p><h3 id="为什么1-7是头插法，1-8是尾插法？">为什么1.7是头插法，1.8是尾插法？</h3><p>1.7版本使用头插法是因为头插法是操作速度最快的，找到数组位置就直接找到插入位置了，但这样插入方法在并发场景下会因为多个线程同时扩容出现循环列表，也就是Hashmap的死锁问题。</p><p>1.8版本加入了红黑树来优化哈希桶中的遍历效率，相比头插法而言，尾插法在操作额外的遍历消耗（指遍历哈希桶）已经小很多，也可以避免之前的循环列表问题，同时如果已经变成红黑树了，也不能再用头插法了，而是按红黑树自己的规则排列了。</p><h4 id="❗多线程下的HashMap线程安全吗？为什么？">❗多线程下的HashMap线程安全吗？为什么？</h4><p>HashMap本身就是不安全的，多线程下，在添加元素时容易出现数据覆盖情况而丢失数据，也可能在扩容时，迁移数据出现数据覆盖情况而丢失数据。</p>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
集合常见问题，其中HashMap很重要❗表示必掌握，❔表示基本不会问&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24.06.01 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="八股文" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    
    <category term="Java" scheme="https://kiml.github.io/tags/Java/"/>
    
    <category term="Java基础" scheme="https://kiml.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
    <category term="HashMap" scheme="https://kiml.github.io/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>代码随想录算法训练营第十二天-二叉树理论基础、递归遍历、迭代遍历、统一迭代</title>
    <link href="https://kiml.github.io/2024/06/01/100000019/"/>
    <id>https://kiml.github.io/2024/06/01/100000019/</id>
    <published>2024-06-01T03:17:20.000Z</published>
    <updated>2024-06-09T13:23:35.157Z</updated>
    
    <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p>前言<br>递归、迭代、统一迭代。都是看完解析之后完成的。统一迭代有点难理解。</p></li><li class="lvl-2"><p>更新</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24-06-03 初始记录</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="144二叉树的前序遍历">144二叉树的前序遍历</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/binary-tree-preorder-traversal/description/" >https://leetcode.cn/problems/binary-tree-preorder-traversal/description/<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    preOrder(root, list);  </span><br><span class="line">    <span class="keyword">return</span> list;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 前序遍历</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 节点  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> list 遍历结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; list)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 当前  </span></span><br><span class="line">    list.add(root.val);  </span><br><span class="line">    <span class="comment">// 左子树  </span></span><br><span class="line">    preOrder(root.left, list);  </span><br><span class="line">    <span class="comment">// 右子树  </span></span><br><span class="line">    preOrder(root.right, list);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 迭代法  </span></span><br><span class="line"><span class="comment"> * 前序遍历 中左右  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> list;  </span><br><span class="line">    &#125;  </span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();  </span><br><span class="line">    stack.push(root);  </span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;  </span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();  </span><br><span class="line">        list.add(pop.val);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 栈先进后出，先进右  </span></span><br><span class="line">        <span class="keyword">if</span> (pop.right != <span class="literal">null</span>) &#123;  </span><br><span class="line">            stack.push(pop.right);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (pop.left != <span class="literal">null</span>) &#123;  </span><br><span class="line">            stack.push(pop.left);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> list;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();  </span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;  </span><br><span class="line">        stack.push(root);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;  </span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.peek();  </span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;  </span><br><span class="line">            stack.pop();  </span><br><span class="line">            <span class="comment">// 判断右节点  </span></span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;  </span><br><span class="line">                stack.push(node.right);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">// 左节点  </span></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;  </span><br><span class="line">                stack.push(node.left);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">// 中间节点  </span></span><br><span class="line">            stack.push(node);  </span><br><span class="line">            stack.push(<span class="literal">null</span>);  </span><br><span class="line">            <span class="comment">// 只有到最后一个节点，才会进这个else  </span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="comment">// 遇到空节点，说明后一个是要处理的节点，先弹出空节点  </span></span><br><span class="line">            stack.pop();  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 再把要处理的节点弹出并加入到列表中  </span></span><br><span class="line">            node = stack.peek();  </span><br><span class="line">            stack.pop();  </span><br><span class="line">            list.add(node.val);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> list;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="94二叉树的中序遍历">94二叉树的中序遍历</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/" >https://leetcode.cn/problems/binary-tree-inorder-traversal/description/<i class="fas fa-external-link-alt"></i></a>)</p><p>中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了<strong>处理顺序和访问顺序是不一致的。</strong><br>那么<strong>在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    inOrder(root, list);  </span><br><span class="line">    <span class="keyword">return</span> list;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 中序遍历  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 节点  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> list 遍历结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; list)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    inOrder(root.left, list);  </span><br><span class="line">    list.add(root.val);  </span><br><span class="line">    inOrder(root.right, list);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 迭代法  </span></span><br><span class="line"><span class="comment"> * 中序遍历 左中右  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> list;  </span><br><span class="line">    &#125;  </span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();  </span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;  </span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty() || cur != <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (cur != <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="comment">// 先遍历左子节点(直至到最后一个左子节点)  </span></span><br><span class="line">            stack.push(cur);  </span><br><span class="line">            cur = cur.left;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="comment">// 此时从栈里弹出的数据，就是要处理的数据  </span></span><br><span class="line">            cur = stack.pop();  </span><br><span class="line">            list.add(cur.val);  </span><br><span class="line">            cur = cur.right;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> list;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 中序遍历  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回遍历结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();  </span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;  </span><br><span class="line">        stack.push(root);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;  </span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.peek();  </span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;  </span><br><span class="line">            stack.pop();  </span><br><span class="line">            <span class="comment">// 判断右节点  </span></span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;  </span><br><span class="line">                stack.push(node.right);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">// 中间节点  </span></span><br><span class="line">            stack.push(node);  </span><br><span class="line">            stack.push(<span class="literal">null</span>);  </span><br><span class="line">            <span class="comment">// 左节点  </span></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;  </span><br><span class="line">                stack.push(node.left);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">// 只有到最后一个节点，才会进这个else  </span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="comment">// 遇到空节点，说明后一个是要处理的节点，先弹出空节点  </span></span><br><span class="line">            stack.pop();  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 再把要处理的节点弹出并加入到列表中  </span></span><br><span class="line">            node = stack.peek();  </span><br><span class="line">            stack.pop();  </span><br><span class="line">            list.add(node.val);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> list;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="145二叉树的后序遍历">145二叉树的后序遍历</h2><p>题目链接：(<a class="link"   href="https://leetcode.cn/problems/binary-tree-postorder-traversal/description/" >https://leetcode.cn/problems/binary-tree-postorder-traversal/description/<i class="fas fa-external-link-alt"></i></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归法</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    postOrder(root, list);  </span><br><span class="line">    <span class="keyword">return</span> list;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 后序遍历  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 节点  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> list 遍历结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; list)</span> &#123;  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    postOrder(root.left, list);  </span><br><span class="line">    postOrder(root.right, list);  </span><br><span class="line">    list.add(root.val);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * 后序遍历 左右中  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root 根节点  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">return</span> list;  </span><br><span class="line">    &#125;  </span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();  </span><br><span class="line">    stack.push(root);  </span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;  </span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">pop</span> <span class="operator">=</span> stack.pop();  </span><br><span class="line">        list.add(pop.val);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 栈先进后出，先进右  </span></span><br><span class="line">        <span class="keyword">if</span> (pop.left != <span class="literal">null</span>) &#123;  </span><br><span class="line">            stack.push(pop.left);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span> (pop.right != <span class="literal">null</span>) &#123;  </span><br><span class="line">            stack.push(pop.right);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 上部分代码与前序相同，left和right遍历顺序颠倒。得到的数组为中右左遍历得出的结果  </span></span><br><span class="line">    <span class="comment">// 翻转得到的结果，即为左右中遍历得出的结果  </span></span><br><span class="line">    Collections.reverse(list);  </span><br><span class="line">    <span class="keyword">return</span> list;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();  </span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();  </span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;  </span><br><span class="line">        stack.push(root);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;  </span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.peek();  </span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">null</span>) &#123;  </span><br><span class="line">            stack.pop();  </span><br><span class="line">            <span class="comment">// 中间节点  </span></span><br><span class="line">            stack.push(node);  </span><br><span class="line">            stack.push(<span class="literal">null</span>);  </span><br><span class="line">            <span class="comment">// 判断右节点  </span></span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;  </span><br><span class="line">                stack.push(node.right);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">// 左节点  </span></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;  </span><br><span class="line">                stack.push(node.left);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">// 只有到最后一个节点，才会进这个else  </span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            <span class="comment">// 遇到空节点，说明后一个是要处理的节点，先弹出空节点  </span></span><br><span class="line">            stack.pop();  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// 再把要处理的节点弹出并加入到列表中  </span></span><br><span class="line">            node = stack.peek();  </span><br><span class="line">            stack.pop();  </span><br><span class="line">            list.add(node.val);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> list;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>看解析</h1><h2 id="❗递归的三要素">❗递归的三要素</h2><p>文章讲解：(<a class="link"   href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86.html" >https://programmercarl.com/二叉树的递归遍历.html<i class="fas fa-external-link-alt"></i></a>)</p><ol><li class="lvl-3"><p><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</p></li><li class="lvl-3"><p><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</p></li><li class="lvl-3"><p><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</p></li></ol><h2 id="迭代法">迭代法</h2><p><strong>递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中</strong>所以所有递归的题目，理论上都可以使用栈解决。</p><p>题目链接/文章讲解/视频讲解：(<a class="link"   href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86.html" >https://programmercarl.com/二叉树的迭代遍历.html<i class="fas fa-external-link-alt"></i></a>)</p><h2 id="统一迭代">统一迭代</h2><p><strong>迭代法实现的先中后序，其实风格也不是那么统一，除了先序和后序，有关联，中序完全就是另一个风格了，一会用栈遍历，一会又用指针来遍历。</strong><br>在迭代法的中序遍历中提到说使用栈的话，<strong>无法同时解决访问节点（遍历节点）和处理节点（将元素放进结果集）不一致的情况</strong>。<strong>那我们就将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。</strong> 这种方法也可以叫做标记法。</p><p>题目链接/文章讲解：(<a class="link"   href="https://programmercarl.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95.html" >https://programmercarl.com/二叉树的统一迭代法.html<i class="fas fa-external-link-alt"></i></a>)</p>]]></content>
    
    
    <summary type="html">&lt;ul class=&quot;lvl-0&quot;&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;前言&lt;br&gt;
递归、迭代、统一迭代。都是看完解析之后完成的。统一迭代有点难理解。&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;lvl-2&quot;&gt;
&lt;p&gt;更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;24-06-03 初始记录&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="面试" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    <category term="代码随想录" scheme="https://kiml.github.io/categories/%E9%9D%A2%E8%AF%95/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95/"/>
    
    
    <category term="二叉树" scheme="https://kiml.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
</feed>
